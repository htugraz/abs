diff -u -Nr gst-libav-1.2.4/gst-libs/ext/libav/avconv.c gst-libav-1.2.4-9.14/gst-libs/ext/libav/avconv.c
--- gst-libav-1.2.4/gst-libs/ext/libav/avconv.c	2014-04-18 12:30:33.000000000 +0200
+++ gst-libav-1.2.4-9.14/gst-libs/ext/libav/avconv.c	2014-06-28 17:33:25.350191159 +0200
@@ -346,6 +346,25 @@
         bsfc = bsfc->next;
     }
 
+    if (!(s->oformat->flags & AVFMT_NOTIMESTAMPS) &&
+        ost->last_mux_dts != AV_NOPTS_VALUE &&
+        pkt->dts < ost->last_mux_dts + !(s->oformat->flags & AVFMT_TS_NONSTRICT)) {
+        av_log(NULL, AV_LOG_WARNING, "Non-monotonous DTS in output stream "
+               "%d:%d; previous: %"PRId64", current: %"PRId64"; ",
+               ost->file_index, ost->st->index, ost->last_mux_dts, pkt->dts);
+        if (exit_on_error) {
+            av_log(NULL, AV_LOG_FATAL, "aborting.\n");
+            exit(1);
+        }
+        av_log(NULL, AV_LOG_WARNING, "changing to %"PRId64". This may result "
+               "in incorrect timestamps in the output file.\n",
+               ost->last_mux_dts + 1);
+        pkt->dts = ost->last_mux_dts + 1;
+        if (pkt->pts != AV_NOPTS_VALUE)
+            pkt->pts = FFMAX(pkt->pts, pkt->dts);
+    }
+    ost->last_mux_dts = pkt->dts;
+
     pkt->stream_index = ost->index;
     ret = av_interleaved_write_frame(s, pkt);
     if (ret < 0) {
@@ -720,6 +739,19 @@
     return 0;
 }
 
+static void finish_output_stream(OutputStream *ost)
+{
+    OutputFile *of = output_files[ost->file_index];
+    int i;
+
+    ost->finished = 1;
+
+    if (of->shortest) {
+        for (i = 0; i < of->ctx->nb_streams; i++)
+            output_streams[of->ost_index + i]->finished = 1;
+    }
+}
+
 /*
  * Read as many frames from possible from lavfi and encode them.
  *
@@ -730,7 +762,7 @@
  */
 static int poll_filters(void)
 {
-    int i, j, ret = 0;
+    int i, ret = 0;
 
     while (ret >= 0 && !received_sigterm) {
         OutputStream *ost = NULL;
@@ -757,15 +789,7 @@
         ret = poll_filter(ost);
 
         if (ret == AVERROR_EOF) {
-            OutputFile *of = output_files[ost->file_index];
-
-            ost->finished = 1;
-
-            if (of->shortest) {
-                for (j = 0; j < of->ctx->nb_streams; j++)
-                    output_streams[of->ost_index + j]->finished = 1;
-            }
-
+            finish_output_stream(ost);
             ret = 0;
         } else if (ret == AVERROR(EAGAIN))
             return 0;
@@ -2127,7 +2151,7 @@
 
                 if (ost->source_index == ifile->ist_index + i &&
                     (ost->stream_copy || ost->enc->type == AVMEDIA_TYPE_SUBTITLE))
-                    ost->finished= 1;
+                    finish_output_stream(ost);
             }
         }
 
diff -u -Nr gst-libav-1.2.4/gst-libs/ext/libav/avconv.h gst-libav-1.2.4-9.14/gst-libs/ext/libav/avconv.h
--- gst-libav-1.2.4/gst-libs/ext/libav/avconv.h	2014-04-18 12:30:33.000000000 +0200
+++ gst-libav-1.2.4-9.14/gst-libs/ext/libav/avconv.h	2014-06-28 17:33:25.560190269 +0200
@@ -267,6 +267,8 @@
     /* pts of the first frame encoded for this stream, used for limiting
      * recording time */
     int64_t first_pts;
+    /* dts of the last packet sent to the muxer */
+    int64_t last_mux_dts;
     AVBitStreamFilterContext *bitstream_filters;
     AVCodec *enc;
     int64_t max_frames;
diff -u -Nr gst-libav-1.2.4/gst-libs/ext/libav/avconv_opt.c gst-libav-1.2.4-9.14/gst-libs/ext/libav/avconv_opt.c
--- gst-libav-1.2.4/gst-libs/ext/libav/avconv_opt.c	2014-04-18 12:30:33.000000000 +0200
+++ gst-libav-1.2.4-9.14/gst-libs/ext/libav/avconv_opt.c	2014-06-28 17:33:25.560190269 +0200
@@ -845,6 +845,7 @@
     av_opt_get_int(o->g->sws_opts, "sws_flags", 0, &ost->sws_flags);
 
     ost->pix_fmts[0] = ost->pix_fmts[1] = AV_PIX_FMT_NONE;
+    ost->last_mux_dts = AV_NOPTS_VALUE;
 
     return ost;
 }
diff -u -Nr gst-libav-1.2.4/gst-libs/ext/libav/Changelog gst-libav-1.2.4-9.14/gst-libs/ext/libav/Changelog
--- gst-libav-1.2.4/gst-libs/ext/libav/Changelog	2014-04-18 12:30:33.000000000 +0200
+++ gst-libav-1.2.4-9.14/gst-libs/ext/libav/Changelog	2014-06-28 17:33:25.560190269 +0200
@@ -1,5 +1,43 @@
 Releases are sorted from youngest to oldest.
 
+version 9.14:
+- adpcm: Write the proper predictor in trellis mode in IMA QT
+- adpcm: Avoid reading out of bounds in the IMA QT trellis encoder
+- Check mp3 header before calling avpriv_mpegaudio_decode_header() (bug/705)
+- Check if an mp3 header is using a reserved sample rate
+- lzo: Handle integer overflow (bug/704)
+- avconv: make -shortest work with streamcopy
+
+Version 9.13:
+- swscale: Fix an undefined behaviour
+- matroska: add the Opus mapping
+- mp3enc: Properly write bitrate value in XING header (Fixes: debian/736088)
+- origin/pu/9 oggdec: add support for Opus in Ogg demuxing (Fixes: libav/603, debian/720563)
+- apedec: do not buffer decoded samples over AVPackets (Fixes: debian/744901)
+- isom: lpcm in mov default to big endian
+- movdec: handle 0x7fff langcode as macintosh per the specs
+- h264: reset next_output_pic earlier in start_frame() (Fixes: libav/672, debian/741240, ubuntu/1288206)
+- Revert "pthread: flush all threads on flush, not just the first one"
+- rtmpproto: Make sure to pass on the error code if read_connect failed
+- lavr: allocate the resampling buffer with a positive size
+- tiffdec: use bytestream2 to simplify overread/overwrite protection
+- bytestream: add bytestream2_copy_buffer() functions
+- bytestream: add functions for accessing size of buffer
+- resample: fix avresample_get_delay() return value
+- avi: Improve non-interleaved detection (Fixes: libav/666)
+- af_channelmap: fix ONE_STR mapping mode
+- movenc: allow override of "writing application" tag
+- matroskaenc: allow override of "writing application" tag
+- avfilter: Add missing emms_c when needed
+- build: Use pkg-config for openjpeg (Fixes: libav/387)
+- pthread: flush all threads on flush, not just the first one (Fixes: vlc/9665)
+- mpeg12: check scantable indices in all decode_block functions
+- sgidec: fix buffer size check in expand_rle_row()
+- adx: check that the offset is not negative
+- mpegvideo: set reference/pict_type on generated reference frames
+- h264: Fix various crashes found in samples pointed by Mateusz "j00ru" Jurczyk and Gynvael Coldwind - Thanks!
+
+
 version 9.12:
 - configure: Update freetype check to follow upstream
 - drawtext: Drop pointless header
diff -u -Nr gst-libav-1.2.4/gst-libs/ext/libav/cmdutils.c gst-libav-1.2.4-9.14/gst-libs/ext/libav/cmdutils.c
--- gst-libav-1.2.4/gst-libs/ext/libav/cmdutils.c	2014-04-18 12:30:33.000000000 +0200
+++ gst-libav-1.2.4-9.14/gst-libs/ext/libav/cmdutils.c	2014-06-28 17:33:25.560190269 +0200
@@ -56,7 +56,7 @@
 struct SwsContext *sws_opts;
 AVDictionary *format_opts, *codec_opts;
 
-static const int this_year = 2013;
+static const int this_year = 2014;
 
 void init_opts(void)
 {
diff -u -Nr gst-libav-1.2.4/gst-libs/ext/libav/configure gst-libav-1.2.4-9.14/gst-libs/ext/libav/configure
--- gst-libav-1.2.4/gst-libs/ext/libav/configure	2014-04-18 12:30:33.000000000 +0200
+++ gst-libav-1.2.4-9.14/gst-libs/ext/libav/configure	2014-06-28 17:33:25.560190269 +0200
@@ -3499,7 +3499,8 @@
 enabled libopencore_amrnb  && require libopencore_amrnb opencore-amrnb/interf_dec.h Decoder_Interface_init -lopencore-amrnb
 enabled libopencore_amrwb  && require libopencore_amrwb opencore-amrwb/dec_if.h D_IF_init -lopencore-amrwb
 enabled libopencv  && require_pkg_config opencv opencv/cv.h cvCreateImageHeader
-enabled libopenjpeg && require libopenjpeg openjpeg.h opj_version -lopenjpeg
+enabled libopenjpeg && { { check_header openjpeg.h && check_lib2 openjpeg.h opj_version -lopenjpeg; } ||
+                         { require_pkg_config libopenjpeg1 openjpeg.h opj_version; } }
 enabled libopus    && require_pkg_config opus opus_multistream.h opus_multistream_decoder_create
 enabled libpulse && require_pkg_config libpulse-simple pulse/simple.h pa_simple_new
 enabled librtmp    && require_pkg_config librtmp librtmp/rtmp.h RTMP_Socket
diff -u -Nr gst-libav-1.2.4/gst-libs/ext/libav/doc/platform.texi gst-libav-1.2.4-9.14/gst-libs/ext/libav/doc/platform.texi
--- gst-libav-1.2.4/gst-libs/ext/libav/doc/platform.texi	2014-04-18 12:30:33.000000000 +0200
+++ gst-libav-1.2.4-9.14/gst-libs/ext/libav/doc/platform.texi	2014-06-28 17:33:25.560190269 +0200
@@ -51,8 +51,8 @@
 unacelerated code.
 
 OS X on PowerPC or ARM (iPhone) requires a preprocessor from
-@url{http://github.com/yuvi/gas-preprocessor} to build the optimized
-assembler functions. Just download the Perl script and put it somewhere
+@url{git://git.libav.org/gas-preprocessor.git} to build the optimized
+assembler functions. Put the Perl script somewhere
 in your PATH, Libav's configure will pick it up automatically.
 
 OS X on AMD64 and x86 requires @command{yasm} to build most of the
diff -u -Nr gst-libav-1.2.4/gst-libs/ext/libav/libavcodec/adpcmenc.c gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavcodec/adpcmenc.c
--- gst-libav-1.2.4/gst-libs/ext/libav/libavcodec/adpcmenc.c	2014-04-18 12:30:33.000000000 +0200
+++ gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavcodec/adpcmenc.c	2014-06-28 17:33:25.560190269 +0200
@@ -557,10 +557,11 @@
             put_bits(&pb, 7,  status->step_index);
             if (avctx->trellis > 0) {
                 uint8_t buf[64];
-                adpcm_compress_trellis(avctx, &samples_p[ch][1], buf, status,
+                adpcm_compress_trellis(avctx, &samples_p[ch][0], buf, status,
                                        64, 1);
                 for (i = 0; i < 64; i++)
                     put_bits(&pb, 4, buf[i ^ 1]);
+                status->prev_sample = status->predictor;
             } else {
                 for (i = 0; i < 64; i += 2) {
                     int t1, t2;
diff -u -Nr gst-libav-1.2.4/gst-libs/ext/libav/libavcodec/adx.c gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavcodec/adx.c
--- gst-libav-1.2.4/gst-libs/ext/libav/libavcodec/adx.c	2014-04-18 12:30:33.000000000 +0200
+++ gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavcodec/adx.c	2014-06-28 17:33:25.560190269 +0200
@@ -48,7 +48,7 @@
     offset = AV_RB16(buf + 2) + 4;
 
     /* if copyright string is within the provided data, validate it */
-    if (bufsize >= offset && memcmp(buf + offset - 6, "(c)CRI", 6))
+    if (bufsize >= offset && offset >= 6 && memcmp(buf + offset - 6, "(c)CRI", 6))
         return AVERROR_INVALIDDATA;
 
     /* check for encoding=3 block_size=18, sample_size=4 */
diff -u -Nr gst-libav-1.2.4/gst-libs/ext/libav/libavcodec/apedec.c gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavcodec/apedec.c
--- gst-libav-1.2.4/gst-libs/ext/libav/libavcodec/apedec.c	2014-04-18 12:30:33.000000000 +0200
+++ gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavcodec/apedec.c	2014-06-28 17:33:25.560190269 +0200
@@ -833,7 +833,6 @@
     int32_t *sample24;
     int i, ch, ret;
     int blockstodecode;
-    int bytes_used = 0;
 
     /* this should never be negative, but bad things will happen if it is, so
        check it just to make sure. */
@@ -889,7 +888,6 @@
             return AVERROR_INVALIDDATA;
         }
 
-        bytes_used = avpkt->size;
     }
 
     if (!s->data) {
@@ -958,7 +956,7 @@
     *got_frame_ptr   = 1;
     *(AVFrame *)data = s->frame;
 
-    return bytes_used;
+    return (s->samples == 0) ? avpkt->size : 0;
 }
 
 static void ape_flush(AVCodecContext *avctx)
diff -u -Nr gst-libav-1.2.4/gst-libs/ext/libav/libavcodec/arm/h264dsp_init_arm.c gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavcodec/arm/h264dsp_init_arm.c
--- gst-libav-1.2.4/gst-libs/ext/libav/libavcodec/arm/h264dsp_init_arm.c	2014-04-18 12:30:33.000000000 +0200
+++ gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavcodec/arm/h264dsp_init_arm.c	2014-06-28 17:33:25.560190269 +0200
@@ -88,7 +88,7 @@
     c->h264_idct_dc_add     = ff_h264_idct_dc_add_neon;
     c->h264_idct_add16      = ff_h264_idct_add16_neon;
     c->h264_idct_add16intra = ff_h264_idct_add16intra_neon;
-    if (chroma_format_idc == 1)
+    if (chroma_format_idc <= 1)
         c->h264_idct_add8   = ff_h264_idct_add8_neon;
     c->h264_idct8_add       = ff_h264_idct8_add_neon;
     c->h264_idct8_dc_add    = ff_h264_idct8_dc_add_neon;
diff -u -Nr gst-libav-1.2.4/gst-libs/ext/libav/libavcodec/bytestream.h gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavcodec/bytestream.h
--- gst-libav-1.2.4/gst-libs/ext/libav/libavcodec/bytestream.h	2014-04-18 12:30:33.000000000 +0200
+++ gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavcodec/bytestream.h	2014-06-28 17:33:25.560190269 +0200
@@ -190,6 +190,16 @@
     return (int)(p->buffer - p->buffer_start);
 }
 
+static av_always_inline int bytestream2_size(GetByteContext *g)
+{
+    return (int)(g->buffer_end - g->buffer_start);
+}
+
+static av_always_inline int bytestream2_size_p(PutByteContext *p)
+{
+    return (int)(p->buffer_end - p->buffer_start);
+}
+
 static av_always_inline int bytestream2_seek(GetByteContext *g,
                                              int offset,
                                              int whence)
@@ -315,6 +325,32 @@
     return p->eof;
 }
 
+static av_always_inline unsigned int bytestream2_copy_bufferu(PutByteContext *p,
+                                                              GetByteContext *g,
+                                                              unsigned int size)
+{
+    memcpy(p->buffer, g->buffer, size);
+    p->buffer += size;
+    g->buffer += size;
+    return size;
+}
+
+static av_always_inline unsigned int bytestream2_copy_buffer(PutByteContext *p,
+                                                             GetByteContext *g,
+                                                             unsigned int size)
+{
+    int size2;
+
+    if (p->eof)
+        return 0;
+    size  = FFMIN(g->buffer_end - g->buffer, size);
+    size2 = FFMIN(p->buffer_end - p->buffer, size);
+    if (size2 != size)
+        p->eof = 1;
+
+    return bytestream2_copy_bufferu(p, g, size2);
+}
+
 static av_always_inline unsigned int bytestream_get_buffer(const uint8_t **b,
                                                            uint8_t *dst,
                                                            unsigned int size)
diff -u -Nr gst-libav-1.2.4/gst-libs/ext/libav/libavcodec/h264.c gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavcodec/h264.c
--- gst-libav-1.2.4/gst-libs/ext/libav/libavcodec/h264.c	2014-04-18 12:30:33.000000000 +0200
+++ gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavcodec/h264.c	2014-06-28 17:33:25.560190269 +0200
@@ -128,10 +128,10 @@
 int ff_h264_check_intra_pred_mode(H264Context *h, int mode, int is_chroma)
 {
     MpegEncContext *const s     = &h->s;
-    static const int8_t top[7]  = { LEFT_DC_PRED8x8, 1, -1, -1 };
-    static const int8_t left[7] = { TOP_DC_PRED8x8, -1, 2, -1, DC_128_PRED8x8 };
+    static const int8_t top[4]  = { LEFT_DC_PRED8x8, 1, -1, -1 };
+    static const int8_t left[5] = { TOP_DC_PRED8x8, -1, 2, -1, DC_128_PRED8x8 };
 
-    if (mode > 6U) {
+    if (mode > 3U) {
         av_log(h->s.avctx, AV_LOG_ERROR,
                "out of range intra chroma pred mode at %d %d\n",
                s->mb_x, s->mb_y);
@@ -1290,6 +1290,8 @@
     int i;
     const int pixel_shift = h->pixel_shift;
 
+    h->next_output_pic = NULL;
+
     if (ff_MPV_frame_start(s, s->avctx) < 0)
         return -1;
     ff_er_frame_start(s);
@@ -1341,8 +1343,6 @@
     s->current_picture_ptr->field_poc[0]     =
         s->current_picture_ptr->field_poc[1] = INT_MAX;
 
-    h->next_output_pic = NULL;
-
     assert(s->current_picture_ptr->long_ref == 0);
 
     return 0;
@@ -2427,12 +2427,6 @@
     if (s->avctx->has_b_frames < 2)
         s->avctx->has_b_frames = !s->low_delay;
 
-    if (h->sps.bit_depth_luma != h->sps.bit_depth_chroma) {
-        av_log_missing_feature(s->avctx,
-            "Different bit depth between chroma and luma", 1);
-        return AVERROR_PATCHWELCOME;
-    }
-
     if (s->avctx->bits_per_raw_sample != h->sps.bit_depth_luma ||
         h->cur_chroma_format_idc      != h->sps.chroma_format_idc) {
         if (s->avctx->codec &&
@@ -2916,8 +2910,10 @@
             Picture *prev = h->short_ref_count ? h->short_ref[0] : NULL;
             av_log(h->s.avctx, AV_LOG_DEBUG, "Frame num gap %d %d\n",
                    h->frame_num, h->prev_frame_num);
-            if (ff_h264_frame_start(h) < 0)
+            if (ff_h264_frame_start(h) < 0) {
+                s0->first_field = 0;
                 return -1;
+            }
             h->prev_frame_num++;
             h->prev_frame_num %= 1 << h->sps.log2_max_frame_num;
             s->current_picture_ptr->frame_num = h->prev_frame_num;
@@ -3833,6 +3829,12 @@
     H264Context *hx;
     int i;
 
+    if (s->mb_y >= s->mb_height) {
+        av_log(s->avctx, AV_LOG_ERROR,
+               "Input contains more MB rows than the frame height.\n");
+        return AVERROR_INVALIDDATA;
+    }
+
     if (s->avctx->hwaccel ||
         s->avctx->codec->capabilities & CODEC_CAP_HWACCEL_VDPAU)
         return 0;
@@ -3941,7 +3943,7 @@
                 s->workaround_bugs |= FF_BUG_TRUNCATED;
 
             if (!(s->workaround_bugs & FF_BUG_TRUNCATED))
-                while (ptr[dst_length - 1] == 0 && dst_length > 0)
+                while (dst_length > 0 && ptr[dst_length - 1] == 0)
                     dst_length--;
             bit_length = !dst_length ? 0
                                      : (8 * dst_length -
@@ -4057,12 +4059,24 @@
                 }
                 break;
             case NAL_DPA:
+                if (s->flags2 & CODEC_FLAG2_CHUNKS) {
+                    av_log(h->s.avctx, AV_LOG_ERROR,
+                           "Decoding in chunks is not supported for "
+                           "partitioned slices.\n");
+                    return AVERROR(ENOSYS);
+                }
+
                 init_get_bits(&hx->s.gb, ptr, bit_length);
                 hx->intra_gb_ptr =
                 hx->inter_gb_ptr = NULL;
 
-                if ((err = decode_slice_header(hx, h)) < 0)
+                if ((err = decode_slice_header(hx, h)) < 0) {
+                    /* make sure data_partitioning is cleared if it was set
+                     * before, so we don't try decoding a slice without a valid
+                     * slice header later */
+                    s->data_partitioning = 0;
                     break;
+                }
 
                 hx->s.data_partitioning = 1;
                 break;
@@ -4130,9 +4144,10 @@
                 context_count = 0;
             }
 
-            if (err < 0)
+            if (err < 0) {
                 av_log(h->s.avctx, AV_LOG_ERROR, "decode_slice_header error\n");
-            else if (err == 1) {
+                h->ref_count[0] = h->ref_count[1] = h->list_count = 0;
+            } else if (err == 1) {
                 /* Slice could not be decoded in parallel mode, copy down
                  * NAL unit stuff to context 0 and restart. Note that
                  * rbsp_buffer is not transferred, but since we no longer
@@ -4183,6 +4198,9 @@
 
     s->flags  = avctx->flags;
     s->flags2 = avctx->flags2;
+    /* reset data partitioning here, to ensure GetBitContexts from previous
+     * packets do not get used. */
+    s->data_partitioning = 0;
 
     /* end of stream, output what is still in the buffers */
 out:
diff -u -Nr gst-libav-1.2.4/gst-libs/ext/libav/libavcodec/h264dsp.c gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavcodec/h264dsp.c
--- gst-libav-1.2.4/gst-libs/ext/libav/libavcodec/h264dsp.c	2014-04-18 12:30:33.000000000 +0200
+++ gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavcodec/h264dsp.c	2014-06-28 17:33:25.560190269 +0200
@@ -54,13 +54,13 @@
     c->h264_idct8_dc_add= FUNC(ff_h264_idct8_dc_add, depth);\
     c->h264_idct_add16     = FUNC(ff_h264_idct_add16, depth);\
     c->h264_idct8_add4     = FUNC(ff_h264_idct8_add4, depth);\
-    if (chroma_format_idc == 1)\
+    if (chroma_format_idc <= 1)\
         c->h264_idct_add8  = FUNC(ff_h264_idct_add8, depth);\
     else\
         c->h264_idct_add8  = FUNC(ff_h264_idct_add8_422, depth);\
     c->h264_idct_add16intra= FUNC(ff_h264_idct_add16intra, depth);\
     c->h264_luma_dc_dequant_idct= FUNC(ff_h264_luma_dc_dequant_idct, depth);\
-    if (chroma_format_idc == 1)\
+    if (chroma_format_idc <= 1)\
         c->h264_chroma_dc_dequant_idct= FUNC(ff_h264_chroma_dc_dequant_idct, depth);\
     else\
         c->h264_chroma_dc_dequant_idct= FUNC(ff_h264_chroma422_dc_dequant_idct, depth);\
@@ -81,20 +81,20 @@
     c->h264_h_loop_filter_luma_intra= FUNC(h264_h_loop_filter_luma_intra, depth);\
     c->h264_h_loop_filter_luma_mbaff_intra= FUNC(h264_h_loop_filter_luma_mbaff_intra, depth);\
     c->h264_v_loop_filter_chroma= FUNC(h264_v_loop_filter_chroma, depth);\
-    if (chroma_format_idc == 1)\
+    if (chroma_format_idc <= 1)\
         c->h264_h_loop_filter_chroma= FUNC(h264_h_loop_filter_chroma, depth);\
     else\
         c->h264_h_loop_filter_chroma= FUNC(h264_h_loop_filter_chroma422, depth);\
-    if (chroma_format_idc == 1)\
+    if (chroma_format_idc <= 1)\
         c->h264_h_loop_filter_chroma_mbaff= FUNC(h264_h_loop_filter_chroma_mbaff, depth);\
     else\
         c->h264_h_loop_filter_chroma_mbaff= FUNC(h264_h_loop_filter_chroma422_mbaff, depth);\
     c->h264_v_loop_filter_chroma_intra= FUNC(h264_v_loop_filter_chroma_intra, depth);\
-    if (chroma_format_idc == 1)\
+    if (chroma_format_idc <= 1)\
         c->h264_h_loop_filter_chroma_intra= FUNC(h264_h_loop_filter_chroma_intra, depth);\
     else\
         c->h264_h_loop_filter_chroma_intra= FUNC(h264_h_loop_filter_chroma422_intra, depth);\
-    if (chroma_format_idc == 1)\
+    if (chroma_format_idc <= 1)\
         c->h264_h_loop_filter_chroma_mbaff_intra= FUNC(h264_h_loop_filter_chroma_mbaff_intra, depth);\
     else\
         c->h264_h_loop_filter_chroma_mbaff_intra= FUNC(h264_h_loop_filter_chroma422_mbaff_intra, depth);\
diff -u -Nr gst-libav-1.2.4/gst-libs/ext/libav/libavcodec/h264pred.c gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavcodec/h264pred.c
--- gst-libav-1.2.4/gst-libs/ext/libav/libavcodec/h264pred.c	2014-04-18 12:30:33.000000000 +0200
+++ gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavcodec/h264pred.c	2014-06-28 17:33:25.560190269 +0200
@@ -471,7 +471,7 @@
     h->pred8x8l[TOP_DC_PRED         ]= FUNCC(pred8x8l_top_dc              , depth);\
     h->pred8x8l[DC_128_PRED         ]= FUNCC(pred8x8l_128_dc              , depth);\
 \
-    if (chroma_format_idc == 1) {\
+    if (chroma_format_idc <= 1) {\
         h->pred8x8[VERT_PRED8x8   ]= FUNCC(pred8x8_vertical               , depth);\
         h->pred8x8[HOR_PRED8x8    ]= FUNCC(pred8x8_horizontal             , depth);\
     } else {\
@@ -479,7 +479,7 @@
         h->pred8x8[HOR_PRED8x8    ]= FUNCC(pred8x16_horizontal            , depth);\
     }\
     if (codec_id != AV_CODEC_ID_VP8) {\
-        if (chroma_format_idc == 1) {\
+        if (chroma_format_idc <= 1) {\
             h->pred8x8[PLANE_PRED8x8]= FUNCC(pred8x8_plane                , depth);\
         } else {\
             h->pred8x8[PLANE_PRED8x8]= FUNCC(pred8x16_plane               , depth);\
@@ -487,7 +487,7 @@
     } else\
         h->pred8x8[PLANE_PRED8x8]= FUNCD(pred8x8_tm_vp8);\
     if(codec_id != AV_CODEC_ID_RV40 && codec_id != AV_CODEC_ID_VP8){\
-        if (chroma_format_idc == 1) {\
+        if (chroma_format_idc <= 1) {\
             h->pred8x8[DC_PRED8x8     ]= FUNCC(pred8x8_dc                     , depth);\
             h->pred8x8[LEFT_DC_PRED8x8]= FUNCC(pred8x8_left_dc                , depth);\
             h->pred8x8[TOP_DC_PRED8x8 ]= FUNCC(pred8x8_top_dc                 , depth);\
@@ -513,7 +513,7 @@
             h->pred8x8[DC_129_PRED8x8]= FUNCC(pred8x8_129_dc              , depth);\
         }\
     }\
-    if (chroma_format_idc == 1) {\
+    if (chroma_format_idc <= 1) {\
         h->pred8x8[DC_128_PRED8x8 ]= FUNCC(pred8x8_128_dc                 , depth);\
     } else {\
         h->pred8x8[DC_128_PRED8x8 ]= FUNCC(pred8x16_128_dc                , depth);\
@@ -547,7 +547,7 @@
     h->pred4x4_add  [ HOR_PRED   ]= FUNCC(pred4x4_horizontal_add          , depth);\
     h->pred8x8l_add [VERT_PRED   ]= FUNCC(pred8x8l_vertical_add           , depth);\
     h->pred8x8l_add [ HOR_PRED   ]= FUNCC(pred8x8l_horizontal_add         , depth);\
-    if (chroma_format_idc == 1) {\
+    if (chroma_format_idc <= 1) {\
     h->pred8x8_add  [VERT_PRED8x8]= FUNCC(pred8x8_vertical_add            , depth);\
     h->pred8x8_add  [ HOR_PRED8x8]= FUNCC(pred8x8_horizontal_add          , depth);\
     } else {\
diff -u -Nr gst-libav-1.2.4/gst-libs/ext/libav/libavcodec/h264_ps.c gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavcodec/h264_ps.c
--- gst-libav-1.2.4/gst-libs/ext/libav/libavcodec/h264_ps.c	2014-04-18 12:30:33.000000000 +0200
+++ gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavcodec/h264_ps.c	2014-06-28 17:33:25.560190269 +0200
@@ -349,6 +349,11 @@
         }
         sps->bit_depth_luma   = get_ue_golomb(&s->gb) + 8;
         sps->bit_depth_chroma = get_ue_golomb(&s->gb) + 8;
+        if (sps->bit_depth_chroma != sps->bit_depth_luma) {
+            av_log_missing_feature(s->avctx,
+                "Different bit depth between chroma and luma", 1);
+            goto fail;
+        }
         sps->transform_bypass = get_bits1(&s->gb);
         decode_scaling_matrices(h, sps, NULL, 1, sps->scaling_matrix4, sps->scaling_matrix8);
     }else{
diff -u -Nr gst-libav-1.2.4/gst-libs/ext/libav/libavcodec/h264_refs.c gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavcodec/h264_refs.c
--- gst-libav-1.2.4/gst-libs/ext/libav/libavcodec/h264_refs.c	2014-04-18 12:30:33.000000000 +0200
+++ gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavcodec/h264_refs.c	2014-06-28 17:33:25.560190269 +0200
@@ -62,20 +62,22 @@
     return match;
 }
 
-static int build_def_list(Picture *def, Picture **in, int len, int is_long, int sel){
+static int build_def_list(Picture *def, int def_len,
+                          Picture **in, int len, int is_long, int sel)
+{
     int i[2]={0};
     int index=0;
 
-    while(i[0]<len || i[1]<len){
+    while ((i[0] < len || i[1] < len) && index < def_len) {
         while (i[0] < len && !(in[ i[0] ] && (in[ i[0] ]->f.reference & sel)))
             i[0]++;
         while (i[1] < len && !(in[ i[1] ] && (in[ i[1] ]->f.reference & (sel^3))))
             i[1]++;
-        if(i[0] < len){
+        if (i[0] < len && index < def_len) {
             in[ i[0] ]->pic_id= is_long ? i[0] : in[ i[0] ]->frame_num;
             split_field_copy(&def[index++], in[ i[0]++ ], sel  , 1);
         }
-        if(i[1] < len){
+        if (i[1] < len && index < def_len) {
             in[ i[1] ]->pic_id= is_long ? i[1] : in[ i[1] ]->frame_num;
             split_field_copy(&def[index++], in[ i[1]++ ], sel^3, 0);
         }
@@ -123,9 +125,12 @@
             len= add_sorted(sorted    , h->short_ref, h->short_ref_count, cur_poc, 1^list);
             len+=add_sorted(sorted+len, h->short_ref, h->short_ref_count, cur_poc, 0^list);
             assert(len<=32);
-            len= build_def_list(h->default_ref_list[list]    , sorted     , len, 0, s->picture_structure);
-            len+=build_def_list(h->default_ref_list[list]+len, h->long_ref, 16 , 1, s->picture_structure);
-            assert(len<=32);
+
+            len  = build_def_list(h->default_ref_list[list], FF_ARRAY_ELEMS(h->default_ref_list[0]),
+                                  sorted, len, 0, s->picture_structure);
+            len += build_def_list(h->default_ref_list[list] + len,
+                                  FF_ARRAY_ELEMS(h->default_ref_list[0]) - len,
+                                  h->long_ref, 16, 1, s->picture_structure);
 
             if(len < h->ref_count[list])
                 memset(&h->default_ref_list[list][len], 0, sizeof(Picture)*(h->ref_count[list] - len));
@@ -138,9 +143,12 @@
                 FFSWAP(Picture, h->default_ref_list[1][0], h->default_ref_list[1][1]);
         }
     }else{
-        len = build_def_list(h->default_ref_list[0]    , h->short_ref, h->short_ref_count, 0, s->picture_structure);
-        len+= build_def_list(h->default_ref_list[0]+len, h-> long_ref, 16                , 1, s->picture_structure);
-        assert(len <= 32);
+        len  = build_def_list(h->default_ref_list[0], FF_ARRAY_ELEMS(h->default_ref_list[0]),
+                              h->short_ref, h->short_ref_count, 0, s->picture_structure);
+        len += build_def_list(h->default_ref_list[0] + len,
+                              FF_ARRAY_ELEMS(h->default_ref_list[0]) - len,
+                              h-> long_ref, 16, 1, s->picture_structure);
+
         if(len < h->ref_count[0])
             memset(&h->default_ref_list[0][len], 0, sizeof(Picture)*(h->ref_count[0] - len));
     }
diff -u -Nr gst-libav-1.2.4/gst-libs/ext/libav/libavcodec/libmp3lame.c gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavcodec/libmp3lame.c
--- gst-libav-1.2.4/gst-libs/ext/libav/libavcodec/libmp3lame.c	2014-04-18 12:30:33.000000000 +0200
+++ gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavcodec/libmp3lame.c	2014-06-28 17:33:25.560190269 +0200
@@ -190,6 +190,7 @@
     MPADecodeHeader hdr;
     int len, ret, ch;
     int lame_result;
+    uint32_t h;
 
     if (frame) {
         switch (avctx->sample_fmt) {
@@ -245,7 +246,12 @@
        determine the frame size. */
     if (s->buffer_index < 4)
         return 0;
-    if (avpriv_mpegaudio_decode_header(&hdr, AV_RB32(s->buffer))) {
+    h = AV_RB32(s->buffer);
+    if (ff_mpa_check_header(h) < 0) {
+        av_log(avctx, AV_LOG_ERROR, "Invalid mp3 header at start of buffer\n");
+        return AVERROR_BUG;
+    }
+    if (avpriv_mpegaudio_decode_header(&hdr, h)) {
         av_log(avctx, AV_LOG_ERROR, "free format output not supported\n");
         return -1;
     }
diff -u -Nr gst-libav-1.2.4/gst-libs/ext/libav/libavcodec/mpeg12.c gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavcodec/mpeg12.c
--- gst-libav-1.2.4/gst-libs/ext/libav/libavcodec/mpeg12.c	2014-04-18 12:30:33.000000000 +0200
+++ gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavcodec/mpeg12.c	2014-06-28 17:33:25.560190269 +0200
@@ -80,6 +80,15 @@
     return sign_extend(val, 5 + shift);
 }
 
+#define check_scantable_index(ctx, x)                                     \
+    do {                                                                  \
+        if ((x) > 63) {                                                   \
+            av_log(ctx->avctx, AV_LOG_ERROR, "ac-tex damaged at %d %d\n", \
+                   ctx->mb_x, ctx->mb_y);                                 \
+            return AVERROR_INVALIDDATA;                                   \
+        }                                                                 \
+    } while (0)                                                           \
+
 static inline int mpeg1_decode_block_intra(MpegEncContext *s, DCTELEM *block, int n)
 {
     int level, dc, diff, i, j, run;
@@ -111,6 +120,7 @@
                 break;
             } else if (level != 0) {
                 i += run;
+                check_scantable_index(s, i);
                 j = scantable[i];
                 level = (level * qscale * quant_matrix[j]) >> 4;
                 level = (level - 1) | 1;
@@ -127,6 +137,7 @@
                     level = SHOW_UBITS(re, &s->gb, 8)      ; LAST_SKIP_BITS(re, &s->gb, 8);
                 }
                 i += run;
+                check_scantable_index(s, i);
                 j = scantable[i];
                 if (level < 0) {
                     level = -level;
@@ -138,10 +149,6 @@
                     level = (level - 1) | 1;
                 }
             }
-            if (i > 63) {
-                av_log(s->avctx, AV_LOG_ERROR, "ac-tex damaged at %d %d\n", s->mb_x, s->mb_y);
-                return -1;
-            }
 
             block[j] = level;
         }
@@ -261,6 +268,7 @@
 
             if (level != 0) {
                 i += run;
+                check_scantable_index(s, i);
                 j = scantable[i];
                 level = ((level * 2 + 1) * qscale) >> 1;
                 level = (level - 1) | 1;
@@ -277,6 +285,7 @@
                     level = SHOW_UBITS(re, &s->gb, 8)      ; SKIP_BITS(re, &s->gb, 8);
                 }
                 i += run;
+                check_scantable_index(s, i);
                 j = scantable[i];
                 if (level < 0) {
                     level = -level;
@@ -342,6 +351,7 @@
 
             if (level != 0) {
                 i += run;
+                check_scantable_index(s, i);
                 j = scantable[i];
                 level = ((level * 2 + 1) * qscale * quant_matrix[j]) >> 5;
                 level = (level ^ SHOW_SBITS(re, &s->gb, 1)) - SHOW_SBITS(re, &s->gb, 1);
@@ -353,6 +363,7 @@
                 level = SHOW_SBITS(re, &s->gb, 12); SKIP_BITS(re, &s->gb, 12);
 
                 i += run;
+                check_scantable_index(s, i);
                 j = scantable[i];
                 if (level < 0) {
                     level = ((-level * 2 + 1) * qscale * quant_matrix[j]) >> 5;
@@ -361,10 +372,6 @@
                     level = ((level * 2 + 1) * qscale * quant_matrix[j]) >> 5;
                 }
             }
-            if (i > 63) {
-                av_log(s->avctx, AV_LOG_ERROR, "ac-tex damaged at %d %d\n", s->mb_x, s->mb_y);
-                return -1;
-            }
 
             mismatch ^= level;
             block[j]  = level;
@@ -411,6 +418,7 @@
 
         if (level != 0) {
             i += run;
+            check_scantable_index(s, i);
             j  = scantable[i];
             level = ((level * 2 + 1) * qscale) >> 1;
             level = (level ^ SHOW_SBITS(re, &s->gb, 1)) - SHOW_SBITS(re, &s->gb, 1);
@@ -422,6 +430,7 @@
             level = SHOW_SBITS(re, &s->gb, 12); SKIP_BITS(re, &s->gb, 12);
 
             i += run;
+            check_scantable_index(s, i);
             j  = scantable[i];
             if (level < 0) {
                 level = ((-level * 2 + 1) * qscale) >> 1;
@@ -488,6 +497,7 @@
                 break;
             } else if (level != 0) {
                 i += run;
+                check_scantable_index(s, i);
                 j  = scantable[i];
                 level = (level * qscale * quant_matrix[j]) >> 4;
                 level = (level ^ SHOW_SBITS(re, &s->gb, 1)) - SHOW_SBITS(re, &s->gb, 1);
@@ -498,6 +508,7 @@
                 UPDATE_CACHE(re, &s->gb);
                 level = SHOW_SBITS(re, &s->gb, 12); SKIP_BITS(re, &s->gb, 12);
                 i += run;
+                check_scantable_index(s, i);
                 j  = scantable[i];
                 if (level < 0) {
                     level = (-level * qscale * quant_matrix[j]) >> 4;
@@ -506,10 +517,6 @@
                     level = (level * qscale * quant_matrix[j]) >> 4;
                 }
             }
-            if (i > 63) {
-                av_log(s->avctx, AV_LOG_ERROR, "ac-tex damaged at %d %d\n", s->mb_x, s->mb_y);
-                return -1;
-            }
 
             mismatch ^= level;
             block[j]  = level;
@@ -524,10 +531,10 @@
 
 static inline int mpeg2_fast_decode_block_intra(MpegEncContext *s, DCTELEM *block, int n)
 {
-    int level, dc, diff, j, run;
+    int level, dc, diff, i, j, run;
     int component;
     RLTable *rl;
-    uint8_t * scantable = s->intra_scantable.permutated;
+    uint8_t * const scantable = s->intra_scantable.permutated;
     const uint16_t *quant_matrix;
     const int qscale = s->qscale;
 
@@ -546,6 +553,7 @@
     dc += diff;
     s->last_dc[component] = dc;
     block[0] = dc << (3 - s->intra_dc_precision);
+    i = 0;
     if (s->intra_vlc_format)
         rl = &ff_rl_mpeg2;
     else
@@ -561,8 +569,9 @@
             if (level == 127) {
                 break;
             } else if (level != 0) {
-                scantable += run;
-                j = *scantable;
+                i += run;
+                check_scantable_index(s, i);
+                j  = scantable[i];
                 level = (level * qscale * quant_matrix[j]) >> 4;
                 level = (level ^ SHOW_SBITS(re, &s->gb, 1)) - SHOW_SBITS(re, &s->gb, 1);
                 LAST_SKIP_BITS(re, &s->gb, 1);
@@ -571,8 +580,9 @@
                 run = SHOW_UBITS(re, &s->gb, 6) + 1; LAST_SKIP_BITS(re, &s->gb, 6);
                 UPDATE_CACHE(re, &s->gb);
                 level = SHOW_SBITS(re, &s->gb, 12); SKIP_BITS(re, &s->gb, 12);
-                scantable += run;
-                j = *scantable;
+                i += run;
+                check_scantable_index(s, i);
+                j  = scantable[i];
                 if (level < 0) {
                     level = (-level * qscale * quant_matrix[j]) >> 4;
                     level = -level;
@@ -586,7 +596,7 @@
         CLOSE_READER(re, &s->gb);
     }
 
-    s->block_last_index[n] = scantable - s->intra_scantable.permutated;
+    s->block_last_index[n] = i;
     return 0;
 }
 
diff -u -Nr gst-libav-1.2.4/gst-libs/ext/libav/libavcodec/mpegaudiodecheader.c gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavcodec/mpegaudiodecheader.c
--- gst-libav-1.2.4/gst-libs/ext/libav/libavcodec/mpegaudiodecheader.c	2014-04-18 12:30:33.000000000 +0200
+++ gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavcodec/mpegaudiodecheader.c	2014-06-28 17:33:25.563523588 +0200
@@ -25,6 +25,8 @@
  */
 
 //#define DEBUG
+#include "libavutil/common.h"
+
 #include "avcodec.h"
 #include "mpegaudio.h"
 #include "mpegaudiodata.h"
@@ -46,6 +48,8 @@
     s->layer = 4 - ((header >> 17) & 3);
     /* extract frequency */
     sample_rate_index = (header >> 10) & 3;
+    if (sample_rate_index >= FF_ARRAY_ELEMS(avpriv_mpa_freq_tab))
+        sample_rate_index = 0;
     sample_rate = avpriv_mpa_freq_tab[sample_rate_index] >> (s->lsf + mpeg25);
     sample_rate_index += 3 * (s->lsf + mpeg25);
     s->sample_rate_index = sample_rate_index;
diff -u -Nr gst-libav-1.2.4/gst-libs/ext/libav/libavcodec/mpegvideo.c gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavcodec/mpegvideo.c
--- gst-libav-1.2.4/gst-libs/ext/libav/libavcodec/mpegvideo.c	2014-04-18 12:30:33.000000000 +0200
+++ gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavcodec/mpegvideo.c	2014-06-28 17:33:25.563523588 +0200
@@ -1481,6 +1481,10 @@
                 return i;
             }
             s->last_picture_ptr = &s->picture[i];
+
+            s->last_picture_ptr->f.reference   = 3;
+            s->last_picture_ptr->f.pict_type = AV_PICTURE_TYPE_I;
+
             if (ff_alloc_picture(s, s->last_picture_ptr, 0) < 0) {
                 s->last_picture_ptr = NULL;
                 return -1;
@@ -1499,6 +1503,10 @@
                 return i;
             }
             s->next_picture_ptr = &s->picture[i];
+
+            s->next_picture_ptr->f.reference   = 3;
+            s->next_picture_ptr->f.pict_type = AV_PICTURE_TYPE_I;
+
             if (ff_alloc_picture(s, s->next_picture_ptr, 0) < 0) {
                 s->next_picture_ptr = NULL;
                 return -1;
diff -u -Nr gst-libav-1.2.4/gst-libs/ext/libav/libavcodec/ppc/h264_altivec.c gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavcodec/ppc/h264_altivec.c
--- gst-libav-1.2.4/gst-libs/ext/libav/libavcodec/ppc/h264_altivec.c	2014-04-18 12:30:33.000000000 +0200
+++ gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavcodec/ppc/h264_altivec.c	2014-06-28 17:33:25.563523588 +0200
@@ -1005,7 +1005,7 @@
     if (av_get_cpu_flags() & AV_CPU_FLAG_ALTIVEC) {
     if (bit_depth == 8) {
         c->h264_idct_add = ff_h264_idct_add_altivec;
-        if (chroma_format_idc == 1)
+        if (chroma_format_idc <= 1)
             c->h264_idct_add8 = ff_h264_idct_add8_altivec;
         c->h264_idct_add16 = ff_h264_idct_add16_altivec;
         c->h264_idct_add16intra = ff_h264_idct_add16intra_altivec;
diff -u -Nr gst-libav-1.2.4/gst-libs/ext/libav/libavcodec/sgidec.c gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavcodec/sgidec.c
--- gst-libav-1.2.4/gst-libs/ext/libav/libavcodec/sgidec.c	2014-04-18 12:30:33.000000000 +0200
+++ gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavcodec/sgidec.c	2014-06-28 17:33:25.563523588 +0200
@@ -26,6 +26,7 @@
 #include "sgi.h"
 
 typedef struct SgiState {
+    AVCodecContext *avctx;
     AVFrame picture;
     unsigned int width;
     unsigned int height;
@@ -39,12 +40,12 @@
  * Expand an RLE row into a channel.
  * @param s the current image state
  * @param out_buf Points to one line after the output buffer.
- * @param out_end end of line in output buffer
+ * @param len length of out_buf in bytes
  * @param pixelstride pixel stride of input buffer
  * @return size of output in bytes, -1 if buffer overflows
  */
 static int expand_rle_row(SgiState *s, uint8_t *out_buf,
-                          uint8_t *out_end, int pixelstride)
+                          int len, int pixelstride)
 {
     unsigned char pixel, count;
     unsigned char *orig = out_buf;
@@ -58,7 +59,10 @@
         }
 
         /* Check for buffer overflow. */
-        if(out_buf + pixelstride * count >= out_end) return -1;
+        if (pixelstride * (count - 1) >= len) {
+            av_log(s->avctx, AV_LOG_ERROR, "Invalid pixel count.\n");
+            return AVERROR_INVALIDDATA;
+        }
 
         if (pixel & 0x80) {
             while (count--) {
@@ -101,7 +105,7 @@
             dest_row -= s->linesize;
             start_offset = bytestream2_get_be32(&g_table);
             bytestream2_seek(&s->g, start_offset, SEEK_SET);
-            if (expand_rle_row(s, dest_row + z, dest_row + FFABS(s->linesize),
+            if (expand_rle_row(s, dest_row + z, FFABS(s->linesize) - z,
                                s->depth) != s->width) {
                 return AVERROR_INVALIDDATA;
             }
@@ -243,6 +247,8 @@
 static av_cold int sgi_init(AVCodecContext *avctx){
     SgiState *s = avctx->priv_data;
 
+    s->avctx = avctx;
+
     avcodec_get_frame_defaults(&s->picture);
     avctx->coded_frame = &s->picture;
 
diff -u -Nr gst-libav-1.2.4/gst-libs/ext/libav/libavcodec/tiff.c gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavcodec/tiff.c
--- gst-libav-1.2.4/gst-libs/ext/libav/libavcodec/tiff.c	2014-04-18 12:30:33.000000000 +0200
+++ gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavcodec/tiff.c	2014-06-28 17:33:25.563523588 +0200
@@ -26,6 +26,7 @@
  */
 
 #include "avcodec.h"
+#include "bytestream.h"
 #include "config.h"
 #if CONFIG_ZLIB
 #include <zlib.h>
@@ -42,6 +43,7 @@
 typedef struct TiffContext {
     AVCodecContext *avctx;
     AVFrame picture;
+    GetByteContext gb;
 
     int width, height;
     unsigned int bpp, bppcount;
@@ -56,33 +58,27 @@
 
     int strips, rps, sstype;
     int sot;
-    const uint8_t *stripdata;
-    const uint8_t *stripsizes;
-    int stripsize, stripoff;
+    int stripsizesoff, stripsize, stripoff, strippos;
     LZWState *lzw;
 } TiffContext;
 
-static unsigned tget_short(const uint8_t **p, int le)
+static unsigned tget_short(GetByteContext *gb, int le)
 {
-    unsigned v = le ? AV_RL16(*p) : AV_RB16(*p);
-    *p += 2;
-    return v;
+    return le ? bytestream2_get_le16(gb) : bytestream2_get_be16(gb);
 }
 
-static unsigned tget_long(const uint8_t **p, int le)
+static unsigned tget_long(GetByteContext *gb, int le)
 {
-    unsigned v = le ? AV_RL32(*p) : AV_RB32(*p);
-    *p += 4;
-    return v;
+    return le ? bytestream2_get_le32(gb) : bytestream2_get_be32(gb);
 }
 
-static unsigned tget(const uint8_t **p, int type, int le)
+static unsigned tget(GetByteContext *gb, int type, int le)
 {
     switch (type) {
-    case TIFF_BYTE : return *(*p)++;
-    case TIFF_SHORT: return tget_short(p, le);
-    case TIFF_LONG : return tget_long(p, le);
-    default        : return UINT_MAX;
+    case TIFF_BYTE:  return bytestream2_get_byte(gb);
+    case TIFF_SHORT: return tget_short(gb, le);
+    case TIFF_LONG:  return tget_long(gb, le);
+    default:         return UINT_MAX;
     }
 }
 
@@ -112,8 +108,8 @@
 static int tiff_unpack_strip(TiffContext *s, uint8_t *dst, int stride,
                              const uint8_t *src, int size, int lines)
 {
+    PutByteContext pb;
     int c, line, pixels, code;
-    const uint8_t *ssrc = src;
     int width = ((s->width * s->bpp) + 7) >> 3;
 
     if (size <= 0)
@@ -151,6 +147,16 @@
             av_log(s->avctx, AV_LOG_ERROR, "Error initializing LZW decoder\n");
             return -1;
         }
+        for (line = 0; line < lines; line++) {
+            pixels = ff_lzw_decode(s->lzw, dst, width);
+            if (pixels < width) {
+                av_log(s->avctx, AV_LOG_ERROR, "Decoded only %i bytes of %i\n",
+                       pixels, width);
+                return AVERROR_INVALIDDATA;
+            }
+            dst += stride;
+        }
+        return 0;
     }
     if (s->compr == TIFF_CCITT_RLE || s->compr == TIFF_G3
         || s->compr == TIFF_G4) {
@@ -187,63 +193,40 @@
         av_free(src2);
         return ret;
     }
+
+    bytestream2_init(&s->gb, src, size);
+    bytestream2_init_writer(&pb, dst, stride * lines);
+
     for (line = 0; line < lines; line++) {
-        if (src - ssrc > size) {
-            av_log(s->avctx, AV_LOG_ERROR, "Source data overread\n");
-            return -1;
-        }
+        if (bytestream2_get_bytes_left(&s->gb) == 0 || bytestream2_get_eof(&pb))
+            break;
+        bytestream2_seek_p(&pb, stride * line, SEEK_SET);
         switch (s->compr) {
         case TIFF_RAW:
-            if (ssrc + size - src < width)
-                return AVERROR_INVALIDDATA;
             if (!s->fill_order) {
-                memcpy(dst, src, width);
+                bytestream2_copy_buffer(&pb, &s->gb, width);
             } else {
                 int i;
                 for (i = 0; i < width; i++)
-                    dst[i] = ff_reverse[src[i]];
+                    bytestream2_put_byte(&pb, ff_reverse[bytestream2_get_byte(&s->gb)]);
             }
-            src += width;
             break;
         case TIFF_PACKBITS:
             for (pixels = 0; pixels < width;) {
-                if (ssrc + size - src < 2)
-                    return AVERROR_INVALIDDATA;
-                code = (int8_t) * src++;
+                code = (int8_t)bytestream2_get_byte(&s->gb);
                 if (code >= 0) {
                     code++;
-                    if (pixels + code > width ||
-                        ssrc + size - src < code) {
-                        av_log(s->avctx, AV_LOG_ERROR,
-                               "Copy went out of bounds\n");
-                        return -1;
-                    }
-                    memcpy(dst + pixels, src, code);
-                    src += code;
+                    bytestream2_copy_buffer(&pb, &s->gb, code);
                     pixels += code;
                 } else if (code != -128) { // -127..-1
                     code = (-code) + 1;
-                    if (pixels + code > width) {
-                        av_log(s->avctx, AV_LOG_ERROR,
-                               "Run went out of bounds\n");
-                        return -1;
-                    }
-                    c = *src++;
-                    memset(dst + pixels, c, code);
+                    c    = bytestream2_get_byte(&s->gb);
+                    bytestream2_set_buffer(&pb, c, code);
                     pixels += code;
                 }
             }
             break;
-        case TIFF_LZW:
-            pixels = ff_lzw_decode(s->lzw, dst, width);
-            if (pixels < width) {
-                av_log(s->avctx, AV_LOG_ERROR, "Decoded only %i bytes of %i\n",
-                       pixels, width);
-                return -1;
-            }
-            break;
         }
-        dst += stride;
     }
     return 0;
 }
@@ -302,20 +285,19 @@
     return 0;
 }
 
-static int tiff_decode_tag(TiffContext *s, const uint8_t *start,
-                           const uint8_t *buf, const uint8_t *end_buf)
+static int tiff_decode_tag(TiffContext *s)
 {
     unsigned tag, type, count, off, value = 0;
-    int i, j;
+    int i, start;
     uint32_t *pal;
-    const uint8_t *rp, *gp, *bp;
 
-    if (end_buf - buf < 12)
+    if (bytestream2_get_bytes_left(&s->gb) < 12)
         return -1;
-    tag = tget_short(&buf, s->le);
-    type = tget_short(&buf, s->le);
-    count = tget_long(&buf, s->le);
-    off = tget_long(&buf, s->le);
+    tag   = tget_short(&s->gb, s->le);
+    type  = tget_short(&s->gb, s->le);
+    count = tget_long(&s->gb, s->le);
+    off   = tget_long(&s->gb, s->le);
+    start = bytestream2_tell(&s->gb);
 
     if (type == 0 || type >= FF_ARRAY_ELEMS(type_sizes)) {
         av_log(s->avctx, AV_LOG_DEBUG, "Unknown tiff type (%u) encountered\n",
@@ -327,35 +309,26 @@
         switch (type) {
         case TIFF_BYTE:
         case TIFF_SHORT:
-            buf -= 4;
-            value = tget(&buf, type, s->le);
-            buf = NULL;
+            bytestream2_seek(&s->gb, -4, SEEK_CUR);
+            value = tget(&s->gb, type, s->le);
             break;
         case TIFF_LONG:
             value = off;
-            buf = NULL;
             break;
         case TIFF_STRING:
             if (count <= 4) {
-                buf -= 4;
+                bytestream2_seek(&s->gb, -4, SEEK_CUR);
                 break;
             }
         default:
             value = UINT_MAX;
-            buf = start + off;
+            bytestream2_seek(&s->gb, off, SEEK_SET);
         }
     } else {
-        if (count <= 4 && type_sizes[type] * count <= 4) {
-            buf -= 4;
-        } else {
-            buf = start + off;
-        }
-    }
-
-    if (buf && (buf < start || buf > end_buf)) {
-        av_log(s->avctx, AV_LOG_ERROR,
-               "Tag referencing position outside the image\n");
-        return -1;
+        if (count <= 4 && type_sizes[type] * count <= 4)
+            bytestream2_seek(&s->gb, -4, SEEK_CUR);
+        else
+            bytestream2_seek(&s->gb, off, SEEK_SET);
     }
 
     switch (tag) {
@@ -384,8 +357,8 @@
             case TIFF_SHORT:
             case TIFF_LONG:
                 s->bpp = 0;
-                for (i = 0; i < count && buf < end_buf; i++)
-                    s->bpp += tget(&buf, type, s->le);
+                for (i = 0; i < count; i++)
+                    s->bpp += tget(&s->gb, type, s->le);
                 break;
             default:
                 s->bpp = -1;
@@ -446,35 +419,25 @@
         break;
     case TIFF_STRIP_OFFS:
         if (count == 1) {
-            s->stripdata = NULL;
+            s->strippos = 0;
             s->stripoff = value;
         } else
-            s->stripdata = start + off;
+            s->strippos = off;
         s->strips = count;
         if (s->strips == 1)
             s->rps = s->height;
         s->sot = type;
-        if (s->stripdata > end_buf) {
-            av_log(s->avctx, AV_LOG_ERROR,
-                   "Tag referencing position outside the image\n");
-            return -1;
-        }
         break;
     case TIFF_STRIP_SIZE:
         if (count == 1) {
-            s->stripsizes = NULL;
-            s->stripsize = value;
-            s->strips = 1;
+            s->stripsizesoff = 0;
+            s->stripsize     = value;
+            s->strips        = 1;
         } else {
-            s->stripsizes = start + off;
+            s->stripsizesoff = off;
         }
         s->strips = count;
         s->sstype = type;
-        if (s->stripsizes > end_buf) {
-            av_log(s->avctx, AV_LOG_ERROR,
-                   "Tag referencing position outside the image\n");
-            return -1;
-        }
         break;
     case TIFF_PREDICTOR:
         s->predictor = value;
@@ -504,23 +467,27 @@
         }
         s->fill_order = value - 1;
         break;
-    case TIFF_PAL:
+    case TIFF_PAL: {
+        GetByteContext pal_gb[3];
         pal = (uint32_t *) s->palette;
         off = type_sizes[type];
-        if (count / 3 > 256 || end_buf - buf < count / 3 * off * 3)
+        if (count / 3 > 256 ||
+            bytestream2_get_bytes_left(&s->gb) < count / 3 * off * 3)
             return -1;
-        rp = buf;
-        gp = buf + count / 3 * off;
-        bp = buf + count / 3 * off * 2;
+        pal_gb[0] = pal_gb[1] = pal_gb[2] = s->gb;
+        bytestream2_skip(&pal_gb[1], count / 3 * off);
+        bytestream2_skip(&pal_gb[2], count / 3 * off * 2);
         off = (type_sizes[type] - 1) << 3;
         for (i = 0; i < count / 3; i++) {
-            j  = (tget(&rp, type, s->le) >> off) << 16;
-            j |= (tget(&gp, type, s->le) >> off) << 8;
-            j |=  tget(&bp, type, s->le) >> off;
-            pal[i] = j;
+            uint32_t p = 0xFF000000;
+            p |= (tget(&pal_gb[0], type, s->le) >> off) << 16;
+            p |= (tget(&pal_gb[1], type, s->le) >> off) << 8;
+            p |=  tget(&pal_gb[2], type, s->le) >> off;
+            pal[i] = p;
         }
         s->palette_is_set = 1;
         break;
+    }
     case TIFF_PLANAR:
         if (value == 2) {
             av_log(s->avctx, AV_LOG_ERROR, "Planar format is not supported\n");
@@ -539,30 +506,31 @@
         av_log(s->avctx, AV_LOG_DEBUG, "Unknown or unsupported tag %d/0X%0X\n",
                tag, tag);
     }
+    bytestream2_seek(&s->gb, start, SEEK_SET);
     return 0;
 }
 
 static int decode_frame(AVCodecContext *avctx,
                         void *data, int *got_frame, AVPacket *avpkt)
 {
-    const uint8_t *buf = avpkt->data;
-    int buf_size = avpkt->size;
     TiffContext *const s = avctx->priv_data;
     AVFrame *picture = data;
     AVFrame *const p = &s->picture;
-    const uint8_t *orig_buf = buf, *end_buf = buf + buf_size;
     unsigned off;
     int id, le, ret;
     int i, j, entries;
     int stride;
     unsigned soff, ssize;
     uint8_t *dst;
+    GetByteContext stripsizes;
+    GetByteContext stripdata;
+
+    bytestream2_init(&s->gb, avpkt->data, avpkt->size);
 
     //parse image header
-    if (end_buf - buf < 8)
+    if (avpkt->size < 8)
         return AVERROR_INVALIDDATA;
-    id = AV_RL16(buf);
-    buf += 2;
+    id = bytestream2_get_le16(&s->gb);
     if (id == 0x4949)
         le = 1;
     else if (id == 0x4D4D)
@@ -577,27 +545,26 @@
     s->fill_order = 0;
     // As TIFF 6.0 specification puts it "An arbitrary but carefully chosen number
     // that further identifies the file as a TIFF file"
-    if (tget_short(&buf, le) != 42) {
+    if (tget_short(&s->gb, le) != 42) {
         av_log(avctx, AV_LOG_ERROR,
                "The answer to life, universe and everything is not correct!\n");
         return -1;
     }
-    // Reset these pointers so we can tell if they were set this frame
-    s->stripsizes = s->stripdata = NULL;
+    // Reset these offsets so we can tell if they were set this frame
+    s->stripsizesoff = s->strippos = 0;
     /* parse image file directory */
-    off = tget_long(&buf, le);
-    if (off >= UINT_MAX - 14 || end_buf - orig_buf < off + 14) {
+    off = tget_long(&s->gb, le);
+    if (off >= UINT_MAX - 14 || avpkt->size < off + 14) {
         av_log(avctx, AV_LOG_ERROR, "IFD offset is greater than image size\n");
         return AVERROR_INVALIDDATA;
     }
-    buf = orig_buf + off;
-    entries = tget_short(&buf, le);
+    bytestream2_seek(&s->gb, off, SEEK_SET);
+    entries = tget_short(&s->gb, le);
     for (i = 0; i < entries; i++) {
-        if (tiff_decode_tag(s, orig_buf, buf, end_buf) < 0)
+        if (tiff_decode_tag(s) < 0)
             return -1;
-        buf += 12;
     }
-    if (!s->stripdata && !s->stripoff) {
+    if (!s->strippos && !s->stripoff) {
         av_log(avctx, AV_LOG_ERROR, "Image data is missing\n");
         return -1;
     }
@@ -607,30 +574,40 @@
 
     if (s->strips == 1 && !s->stripsize) {
         av_log(avctx, AV_LOG_WARNING, "Image data size missing\n");
-        s->stripsize = buf_size - s->stripoff;
+        s->stripsize = avpkt->size - s->stripoff;
     }
     stride = p->linesize[0];
     dst = p->data[0];
+
+    if (s->stripsizesoff) {
+        if (s->stripsizesoff >= avpkt->size)
+            return AVERROR_INVALIDDATA;
+        bytestream2_init(&stripsizes, avpkt->data + s->stripsizesoff,
+                         avpkt->size - s->stripsizesoff);
+    }
+    if (s->strippos) {
+        if (s->strippos >= avpkt->size)
+            return AVERROR_INVALIDDATA;
+        bytestream2_init(&stripdata, avpkt->data + s->strippos,
+                         avpkt->size - s->strippos);
+    }
+
     for (i = 0; i < s->height; i += s->rps) {
-        if (s->stripsizes) {
-            if (s->stripsizes >= end_buf)
-                return AVERROR_INVALIDDATA;
-            ssize = tget(&s->stripsizes, s->sstype, s->le);
-        } else
+        if (s->stripsizesoff)
+            ssize = tget(&stripsizes, s->sstype, le);
+        else
             ssize = s->stripsize;
 
-        if (s->stripdata) {
-            if (s->stripdata >= end_buf)
-                return AVERROR_INVALIDDATA;
-            soff = tget(&s->stripdata, s->sot, s->le);
-        } else
+        if (s->strippos)
+            soff = tget(&stripdata, s->sot, le);
+        else
             soff = s->stripoff;
 
-        if (soff > buf_size || ssize > buf_size - soff) {
+        if (soff > avpkt->size || ssize > avpkt->size - soff) {
             av_log(avctx, AV_LOG_ERROR, "Invalid strip size/offset\n");
             return -1;
         }
-        if (tiff_unpack_strip(s, dst, stride, orig_buf + soff, ssize,
+        if (tiff_unpack_strip(s, dst, stride, avpkt->data + soff, ssize,
                               FFMIN(s->rps, s->height - i)) < 0)
             break;
         dst += s->rps * stride;
@@ -660,7 +637,7 @@
     *picture   = s->picture;
     *got_frame = 1;
 
-    return buf_size;
+    return avpkt->size;
 }
 
 static av_cold int tiff_init(AVCodecContext *avctx)
diff -u -Nr gst-libav-1.2.4/gst-libs/ext/libav/libavcodec/x86/h264dsp_init.c gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavcodec/x86/h264dsp_init.c
--- gst-libav-1.2.4/gst-libs/ext/libav/libavcodec/x86/h264dsp_init.c	2014-04-18 12:30:33.000000000 +0200
+++ gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavcodec/x86/h264dsp_init.c	2014-06-28 17:33:25.563523588 +0200
@@ -212,7 +212,7 @@
 {
     int mm_flags = av_get_cpu_flags();
 
-    if (chroma_format_idc == 1 && EXTERNAL_MMXEXT(mm_flags))
+    if (chroma_format_idc <= 1 && EXTERNAL_MMXEXT(mm_flags))
         c->h264_loop_filter_strength = ff_h264_loop_filter_strength_mmxext;
 
     if (bit_depth == 8) {
@@ -224,7 +224,7 @@
 
             c->h264_idct_add16 = ff_h264_idct_add16_8_mmx;
             c->h264_idct8_add4 = ff_h264_idct8_add4_8_mmx;
-            if (chroma_format_idc == 1)
+            if (chroma_format_idc <= 1)
                 c->h264_idct_add8 = ff_h264_idct_add8_8_mmx;
             c->h264_idct_add16intra = ff_h264_idct_add16intra_8_mmx;
             if (mm_flags & AV_CPU_FLAG_CMOV)
@@ -235,13 +235,13 @@
                 c->h264_idct8_dc_add = ff_h264_idct8_dc_add_8_mmxext;
                 c->h264_idct_add16   = ff_h264_idct_add16_8_mmxext;
                 c->h264_idct8_add4   = ff_h264_idct8_add4_8_mmxext;
-                if (chroma_format_idc == 1)
+                if (chroma_format_idc <= 1)
                     c->h264_idct_add8 = ff_h264_idct_add8_8_mmxext;
                 c->h264_idct_add16intra = ff_h264_idct_add16intra_8_mmxext;
 
                 c->h264_v_loop_filter_chroma       = ff_deblock_v_chroma_8_mmxext;
                 c->h264_v_loop_filter_chroma_intra = ff_deblock_v_chroma_intra_8_mmxext;
-                if (chroma_format_idc == 1) {
+                if (chroma_format_idc <= 1) {
                     c->h264_h_loop_filter_chroma       = ff_deblock_h_chroma_8_mmxext;
                     c->h264_h_loop_filter_chroma_intra = ff_deblock_h_chroma_intra_8_mmxext;
                 }
@@ -264,7 +264,7 @@
 
                     c->h264_idct_add16 = ff_h264_idct_add16_8_sse2;
                     c->h264_idct8_add4 = ff_h264_idct8_add4_8_sse2;
-                    if (chroma_format_idc == 1)
+                    if (chroma_format_idc <= 1)
                         c->h264_idct_add8 = ff_h264_idct_add8_8_sse2;
                     c->h264_idct_add16intra      = ff_h264_idct_add16intra_8_sse2;
                     c->h264_luma_dc_dequant_idct = ff_h264_luma_dc_dequant_idct_sse2;
@@ -309,7 +309,7 @@
                     c->h264_idct8_dc_add = ff_h264_idct8_dc_add_10_sse2;
 
                     c->h264_idct_add16 = ff_h264_idct_add16_10_sse2;
-                    if (chroma_format_idc == 1)
+                    if (chroma_format_idc <= 1)
                         c->h264_idct_add8 = ff_h264_idct_add8_10_sse2;
                     c->h264_idct_add16intra = ff_h264_idct_add16intra_10_sse2;
 #if HAVE_ALIGNED_STACK
@@ -349,7 +349,7 @@
                     c->h264_idct8_dc_add = ff_h264_idct8_dc_add_10_avx;
 
                     c->h264_idct_add16 = ff_h264_idct_add16_10_avx;
-                    if (chroma_format_idc == 1)
+                    if (chroma_format_idc <= 1)
                         c->h264_idct_add8 = ff_h264_idct_add8_10_avx;
                     c->h264_idct_add16intra = ff_h264_idct_add16intra_10_avx;
 #if HAVE_ALIGNED_STACK
diff -u -Nr gst-libav-1.2.4/gst-libs/ext/libav/libavcodec/x86/h264_intrapred_init.c gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavcodec/x86/h264_intrapred_init.c
--- gst-libav-1.2.4/gst-libs/ext/libav/libavcodec/x86/h264_intrapred_init.c	2014-04-18 12:30:33.000000000 +0200
+++ gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavcodec/x86/h264_intrapred_init.c	2014-06-28 17:33:25.563523588 +0200
@@ -187,7 +187,7 @@
         if (EXTERNAL_MMX(mm_flags)) {
             h->pred16x16[VERT_PRED8x8         ] = ff_pred16x16_vertical_8_mmx;
             h->pred16x16[HOR_PRED8x8          ] = ff_pred16x16_horizontal_8_mmx;
-            if (chroma_format_idc == 1) {
+            if (chroma_format_idc <= 1) {
                 h->pred8x8  [VERT_PRED8x8     ] = ff_pred8x8_vertical_8_mmx;
                 h->pred8x8  [HOR_PRED8x8      ] = ff_pred8x8_horizontal_8_mmx;
             }
@@ -196,7 +196,7 @@
                 h->pred8x8  [PLANE_PRED8x8    ] = ff_pred8x8_tm_vp8_8_mmx;
                 h->pred4x4  [TM_VP8_PRED      ] = ff_pred4x4_tm_vp8_8_mmx;
             } else {
-                if (chroma_format_idc == 1)
+                if (chroma_format_idc <= 1)
                     h->pred8x8  [PLANE_PRED8x8] = ff_pred8x8_plane_8_mmx;
                 if (codec_id == AV_CODEC_ID_SVQ3) {
                     if (mm_flags & AV_CPU_FLAG_CMOV)
@@ -212,7 +212,7 @@
         if (EXTERNAL_MMXEXT(mm_flags)) {
             h->pred16x16[HOR_PRED8x8            ] = ff_pred16x16_horizontal_8_mmxext;
             h->pred16x16[DC_PRED8x8             ] = ff_pred16x16_dc_8_mmxext;
-            if (chroma_format_idc == 1)
+            if (chroma_format_idc <= 1)
                 h->pred8x8[HOR_PRED8x8          ] = ff_pred8x8_horizontal_8_mmxext;
             h->pred8x8l [TOP_DC_PRED            ] = ff_pred8x8l_top_dc_8_mmxext;
             h->pred8x8l [DC_PRED                ] = ff_pred8x8l_dc_8_mmxext;
@@ -237,7 +237,7 @@
                 h->pred4x4  [HOR_UP_PRED        ] = ff_pred4x4_horizontal_up_8_mmxext;
             }
             if (codec_id == AV_CODEC_ID_SVQ3 || codec_id == AV_CODEC_ID_H264) {
-                if (chroma_format_idc == 1) {
+                if (chroma_format_idc <= 1) {
                     h->pred8x8[TOP_DC_PRED8x8   ] = ff_pred8x8_top_dc_8_mmxext;
                     h->pred8x8[DC_PRED8x8       ] = ff_pred8x8_dc_8_mmxext;
                 }
@@ -249,7 +249,7 @@
                 h->pred4x4  [TM_VP8_PRED        ] = ff_pred4x4_tm_vp8_8_mmxext;
                 h->pred4x4  [VERT_PRED          ] = ff_pred4x4_vertical_vp8_8_mmxext;
             } else {
-                if (chroma_format_idc == 1)
+                if (chroma_format_idc <= 1)
                     h->pred8x8  [PLANE_PRED8x8] = ff_pred8x8_plane_8_mmxext;
                 if (codec_id == AV_CODEC_ID_SVQ3) {
                     h->pred16x16[PLANE_PRED8x8  ] = ff_pred16x16_plane_svq3_8_mmxext;
@@ -276,7 +276,7 @@
                 h->pred16x16[PLANE_PRED8x8    ] = ff_pred16x16_tm_vp8_8_sse2;
                 h->pred8x8  [PLANE_PRED8x8    ] = ff_pred8x8_tm_vp8_8_sse2;
             } else {
-                if (chroma_format_idc == 1)
+                if (chroma_format_idc <= 1)
                     h->pred8x8  [PLANE_PRED8x8] = ff_pred8x8_plane_8_sse2;
                 if (codec_id == AV_CODEC_ID_SVQ3) {
                     h->pred16x16[PLANE_PRED8x8] = ff_pred16x16_plane_svq3_8_sse2;
@@ -291,7 +291,7 @@
         if (EXTERNAL_SSSE3(mm_flags)) {
             h->pred16x16[HOR_PRED8x8          ] = ff_pred16x16_horizontal_8_ssse3;
             h->pred16x16[DC_PRED8x8           ] = ff_pred16x16_dc_8_ssse3;
-            if (chroma_format_idc == 1)
+            if (chroma_format_idc <= 1)
                 h->pred8x8  [HOR_PRED8x8      ] = ff_pred8x8_horizontal_8_ssse3;
             h->pred8x8l [TOP_DC_PRED          ] = ff_pred8x8l_top_dc_8_ssse3;
             h->pred8x8l [DC_PRED              ] = ff_pred8x8l_dc_8_ssse3;
@@ -307,7 +307,7 @@
                 h->pred8x8  [PLANE_PRED8x8    ] = ff_pred8x8_tm_vp8_8_ssse3;
                 h->pred4x4  [TM_VP8_PRED      ] = ff_pred4x4_tm_vp8_8_ssse3;
             } else {
-                if (chroma_format_idc == 1)
+                if (chroma_format_idc <= 1)
                     h->pred8x8  [PLANE_PRED8x8] = ff_pred8x8_plane_8_ssse3;
                 if (codec_id == AV_CODEC_ID_SVQ3) {
                     h->pred16x16[PLANE_PRED8x8] = ff_pred16x16_plane_svq3_8_ssse3;
@@ -323,7 +323,7 @@
             h->pred4x4[DC_PRED             ] = ff_pred4x4_dc_10_mmxext;
             h->pred4x4[HOR_UP_PRED         ] = ff_pred4x4_horizontal_up_10_mmxext;
 
-            if (chroma_format_idc == 1)
+            if (chroma_format_idc <= 1)
                 h->pred8x8[DC_PRED8x8      ] = ff_pred8x8_dc_10_mmxext;
 
             h->pred8x8l[DC_128_PRED        ] = ff_pred8x8l_128_dc_10_mmxext;
@@ -342,7 +342,7 @@
             h->pred4x4[VERT_RIGHT_PRED     ] = ff_pred4x4_vertical_right_10_sse2;
             h->pred4x4[HOR_DOWN_PRED       ] = ff_pred4x4_horizontal_down_10_sse2;
 
-            if (chroma_format_idc == 1) {
+            if (chroma_format_idc <= 1) {
                 h->pred8x8[DC_PRED8x8      ] = ff_pred8x8_dc_10_sse2;
                 h->pred8x8[TOP_DC_PRED8x8  ] = ff_pred8x8_top_dc_10_sse2;
                 h->pred8x8[PLANE_PRED8x8   ] = ff_pred8x8_plane_10_sse2;
diff -u -Nr gst-libav-1.2.4/gst-libs/ext/libav/libavfilter/af_channelmap.c gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavfilter/af_channelmap.c
--- gst-libav-1.2.4/gst-libs/ext/libav/libavfilter/af_channelmap.c	2014-04-18 12:30:33.000000000 +0200
+++ gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavfilter/af_channelmap.c	2014-06-28 17:33:25.563523588 +0200
@@ -197,7 +197,7 @@
             s->map[i].out_channel_idx = i;
             break;
         case MAP_ONE_STR:
-            if (!get_channel(&mapping, &in_ch, ',')) {
+            if (get_channel(&mapping, &in_ch, ',') < 0) {
                 av_log(ctx, AV_LOG_ERROR, err);
                 ret = AVERROR(EINVAL);
                 goto fail;
diff -u -Nr gst-libav-1.2.4/gst-libs/ext/libav/libavfilter/af_volume.c gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavfilter/af_volume.c
--- gst-libav-1.2.4/gst-libs/ext/libav/libavfilter/af_volume.c	2014-04-18 12:30:33.000000000 +0200
+++ gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavfilter/af_volume.c	2014-06-28 17:33:25.563523588 +0200
@@ -282,6 +282,8 @@
         }
     }
 
+    emms_c();
+
     if (buf != out_buf)
         avfilter_unref_buffer(buf);
 
diff -u -Nr gst-libav-1.2.4/gst-libs/ext/libav/libavfilter/vf_gradfun.c gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavfilter/vf_gradfun.c
--- gst-libav-1.2.4/gst-libs/ext/libav/libavfilter/vf_gradfun.c	2014-04-18 12:30:33.000000000 +0200
+++ gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavfilter/vf_gradfun.c	2014-06-28 17:33:25.563523588 +0200
@@ -117,6 +117,7 @@
         ctx->filter_line(dst + y * dst_linesize, src + y * src_linesize, dc - r / 2, width, thresh, dither[y & 7]);
         if (++y >= height) break;
     }
+    emms_c();
 }
 
 static av_cold int init(AVFilterContext *ctx, const char *args)
diff -u -Nr gst-libav-1.2.4/gst-libs/ext/libav/libavfilter/vf_hqdn3d.c gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavfilter/vf_hqdn3d.c
--- gst-libav-1.2.4/gst-libs/ext/libav/libavfilter/vf_hqdn3d.c	2014-04-18 12:30:33.000000000 +0200
+++ gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavfilter/vf_hqdn3d.c	2014-06-28 17:33:25.563523588 +0200
@@ -155,6 +155,7 @@
     else
         denoise_temporal(src, dst, frame_ant,
                          w, h, sstride, dstride, temporal, depth);
+    emms_c();
 }
 
 #define denoise(...) \
diff -u -Nr gst-libav-1.2.4/gst-libs/ext/libav/libavformat/avidec.c gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavformat/avidec.c
--- gst-libav-1.2.4/gst-libs/ext/libav/libavformat/avidec.c	2014-04-18 12:30:33.000000000 +0200
+++ gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavformat/avidec.c	2014-06-28 17:33:25.563523588 +0200
@@ -732,7 +732,11 @@
     if(!avi->index_loaded && pb->seekable)
         avi_load_index(s);
     avi->index_loaded = 1;
-    avi->non_interleaved |= guess_ni_flag(s);
+
+    if ((ret = guess_ni_flag(s)) < 0)
+        return ret;
+
+    avi->non_interleaved |= ret;
     for(i=0; i<s->nb_streams; i++){
         AVStream *st = s->streams[i];
         if(st->nb_index_entries)
@@ -1204,6 +1208,64 @@
     return 0;
 }
 
+/* Scan the index and consider any file with streams more than
+ * 2 seconds or 64MB apart non-interleaved. */
+static int check_stream_max_drift(AVFormatContext *s)
+{
+    int64_t min_pos, pos;
+    int i;
+    int *idx = av_mallocz_array(s->nb_streams, sizeof(*idx));
+    if (!idx)
+        return AVERROR(ENOMEM);
+
+    for (min_pos = pos = 0; min_pos != INT64_MAX; pos = min_pos + 1LU) {
+        int64_t max_dts = INT64_MIN / 2;
+        int64_t min_dts = INT64_MAX / 2;
+        int64_t max_buffer = 0;
+
+        min_pos = INT64_MAX;
+
+        for (i = 0; i < s->nb_streams; i++) {
+            AVStream *st = s->streams[i];
+            AVIStream *ast = st->priv_data;
+            int n = st->nb_index_entries;
+            while (idx[i] < n && st->index_entries[idx[i]].pos < pos)
+                idx[i]++;
+            if (idx[i] < n) {
+                int64_t dts;
+                dts = av_rescale_q(st->index_entries[idx[i]].timestamp /
+                                   FFMAX(ast->sample_size, 1),
+                                   st->time_base, AV_TIME_BASE_Q);
+                min_dts = FFMIN(min_dts, dts);
+                min_pos = FFMIN(min_pos, st->index_entries[idx[i]].pos);
+            }
+        }
+        for (i = 0; i < s->nb_streams; i++) {
+            AVStream *st = s->streams[i];
+            AVIStream *ast = st->priv_data;
+
+            if (idx[i] && min_dts != INT64_MAX / 2) {
+                int64_t dts;
+                dts = av_rescale_q(st->index_entries[idx[i] - 1].timestamp /
+                                   FFMAX(ast->sample_size, 1),
+                                   st->time_base, AV_TIME_BASE_Q);
+                max_dts = FFMAX(max_dts, dts);
+                max_buffer = FFMAX(max_buffer,
+                                   av_rescale(dts - min_dts,
+                                              st->codec->bit_rate,
+                                              AV_TIME_BASE));
+            }
+        }
+        if (max_dts - min_dts > 2 * AV_TIME_BASE ||
+            max_buffer > 1024 * 1024 * 8 * 8) {
+            av_free(idx);
+            return 1;
+        }
+    }
+    av_free(idx);
+    return 0;
+}
+
 static int guess_ni_flag(AVFormatContext *s){
     int i;
     int64_t last_start=0;
@@ -1232,7 +1294,11 @@
             first_end= st->index_entries[n-1].pos;
     }
     avio_seek(s->pb, oldpos, SEEK_SET);
-    return last_start > first_end;
+
+    if (last_start > first_end)
+        return 1;
+
+    return check_stream_max_drift(s);
 }
 
 static int avi_load_index(AVFormatContext *s)
diff -u -Nr gst-libav-1.2.4/gst-libs/ext/libav/libavformat/isom.c gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavformat/isom.c
--- gst-libav-1.2.4/gst-libs/ext/libav/libavformat/isom.c	2014-04-18 12:30:33.000000000 +0200
+++ gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavformat/isom.c	2014-06-28 17:33:25.563523588 +0200
@@ -259,6 +259,7 @@
     { AV_CODEC_ID_PCM_MULAW,       MKTAG('u', 'l', 'a', 'w') },
     { AV_CODEC_ID_PCM_S16BE,       MKTAG('t', 'w', 'o', 's') },
     { AV_CODEC_ID_PCM_S16LE,       MKTAG('s', 'o', 'w', 't') },
+    { AV_CODEC_ID_PCM_S16BE,       MKTAG('l', 'p', 'c', 'm') },
     { AV_CODEC_ID_PCM_S16LE,       MKTAG('l', 'p', 'c', 'm') },
     { AV_CODEC_ID_PCM_S24BE,       MKTAG('i', 'n', '2', '4') },
     { AV_CODEC_ID_PCM_S24LE,       MKTAG('i', 'n', '2', '4') },
@@ -342,7 +343,7 @@
     memset(to, 0, 4);
     /* is it the mangled iso code? */
     /* see http://www.geocities.com/xhelmboyx/quicktime/formats/mp4-layout.txt */
-    if (code > 138) {
+    if (code >= 0x400 && code != 0x7fff) {
         for (i = 2; i >= 0; i--) {
             to[i] = 0x60 + (code & 0x1f);
             code >>= 5;
diff -u -Nr gst-libav-1.2.4/gst-libs/ext/libav/libavformat/Makefile gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavformat/Makefile
--- gst-libav-1.2.4/gst-libs/ext/libav/libavformat/Makefile	2014-04-18 12:30:33.000000000 +0200
+++ gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavformat/Makefile	2014-06-28 17:33:25.563523588 +0200
@@ -203,6 +203,7 @@
                                             oggparsedirac.o  \
                                             oggparseflac.o   \
                                             oggparseogm.o    \
+                                            oggparseopus.o   \
                                             oggparseskeleton.o \
                                             oggparsespeex.o  \
                                             oggparsetheora.o \
diff -u -Nr gst-libav-1.2.4/gst-libs/ext/libav/libavformat/matroska.c gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavformat/matroska.c
--- gst-libav-1.2.4/gst-libs/ext/libav/libavformat/matroska.c	2014-04-18 12:30:33.000000000 +0200
+++ gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavformat/matroska.c	2014-06-28 17:33:25.563523588 +0200
@@ -32,6 +32,7 @@
     {"A_MPEG/L2"        , AV_CODEC_ID_MP2},
     {"A_MPEG/L1"        , AV_CODEC_ID_MP2},
     {"A_MPEG/L3"        , AV_CODEC_ID_MP3},
+    {"A_OPUS"           , AV_CODEC_ID_OPUS},
     {"A_PCM/FLOAT/IEEE" , AV_CODEC_ID_PCM_F32LE},
     {"A_PCM/FLOAT/IEEE" , AV_CODEC_ID_PCM_F64LE},
     {"A_PCM/INT/BIG"    , AV_CODEC_ID_PCM_S16BE},
diff -u -Nr gst-libav-1.2.4/gst-libs/ext/libav/libavformat/matroskaenc.c gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavformat/matroskaenc.c
--- gst-libav-1.2.4/gst-libs/ext/libav/libavformat/matroskaenc.c	2014-04-18 12:30:33.000000000 +0200
+++ gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavformat/matroskaenc.c	2014-06-28 17:33:25.563523588 +0200
@@ -94,6 +94,8 @@
     AVPacket        cur_audio_pkt;
 
     int have_attachments;
+
+    int64_t ts_offset;
 } MatroskaMuxContext;
 
 
@@ -776,7 +778,8 @@
     end_ebml_master(s->pb, targets);
 
     while ((t = av_dict_get(m, "", t, AV_DICT_IGNORE_SUFFIX)))
-        if (av_strcasecmp(t->key, "title"))
+        if (av_strcasecmp(t->key, "title") &&
+            av_strcasecmp(t->key, "encoding_tool"))
             mkv_write_simpletag(s->pb, t);
 
     end_ebml_master(s->pb, tag);
@@ -936,7 +939,10 @@
             segment_uid[i] = av_lfg_get(&lfg);
 
         put_ebml_string(pb, MATROSKA_ID_MUXINGAPP , LIBAVFORMAT_IDENT);
-        put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, LIBAVFORMAT_IDENT);
+        if ((tag = av_dict_get(s->metadata, "encoding_tool", NULL, 0)))
+            put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, tag->value);
+        else
+            put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, LIBAVFORMAT_IDENT);
         put_ebml_binary(pb, MATROSKA_ID_SEGMENTUID, segment_uid, 16);
     }
 
@@ -1199,9 +1205,18 @@
     AVIOContext *pb = s->pb->seekable ? s->pb : mkv->dyn_bc;
     AVCodecContext *codec = s->streams[pkt->stream_index]->codec;
     int ret, keyframe = !!(pkt->flags & AV_PKT_FLAG_KEY);
-    int64_t ts = mkv->tracks[pkt->stream_index].write_dts ? pkt->dts : pkt->pts;
+    int64_t ts;
     int cluster_size = avio_tell(pb) - (s->pb->seekable ? mkv->cluster_pos : 0);
 
+    if (pkt->dts < 0 && !mkv->ts_offset)
+        mkv->ts_offset = -pkt->dts;
+
+    pkt->dts += mkv->ts_offset;
+    if (pkt->pts != AV_NOPTS_VALUE)
+        pkt->pts += mkv->ts_offset;
+
+    ts = mkv->tracks[pkt->stream_index].write_dts ? pkt->dts : pkt->pts;
+
     // start a new cluster every 5 MB or 5 sec, or 32k / 1 sec for streaming or
     // after 4k and on a keyframe
     if (mkv->cluster_pos &&
diff -u -Nr gst-libav-1.2.4/gst-libs/ext/libav/libavformat/mov.c gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavformat/mov.c
--- gst-libav-1.2.4/gst-libs/ext/libav/libavformat/mov.c	2014-04-18 12:30:33.000000000 +0200
+++ gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavformat/mov.c	2014-06-28 17:33:25.563523588 +0200
@@ -300,7 +300,7 @@
     if (parse)
         parse(c, pb, str_size, key);
     else {
-        if (data_type == 3 || (data_type == 0 && langcode < 0x800)) { // MAC Encoded
+        if (data_type == 3 || (data_type == 0 && (langcode < 0x400 || langcode == 0x7fff))) { // MAC Encoded
             mov_read_mac_string(c, pb, str_size, str, sizeof(str));
         } else {
             avio_read(pb, str, str_size);
diff -u -Nr gst-libav-1.2.4/gst-libs/ext/libav/libavformat/movenc.c gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavformat/movenc.c
--- gst-libav-1.2.4/gst-libs/ext/libav/libavformat/movenc.c	2014-04-18 12:30:33.000000000 +0200
+++ gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavformat/movenc.c	2014-06-28 17:33:25.563523588 +0200
@@ -1806,7 +1806,8 @@
     mov_write_string_metadata(s, pb, "\251wrt", "composer" , 1);
     mov_write_string_metadata(s, pb, "\251alb", "album"    , 1);
     mov_write_string_metadata(s, pb, "\251day", "date"     , 1);
-    mov_write_string_tag(pb, "\251too", LIBAVFORMAT_IDENT, 0, 1);
+    if (!mov_write_string_metadata(s, pb, "\251too", "encoding_tool", 1))
+        mov_write_string_tag(pb, "\251too", LIBAVFORMAT_IDENT, 0, 1);
     mov_write_string_metadata(s, pb, "\251cmt", "comment"  , 1);
     mov_write_string_metadata(s, pb, "\251gen", "genre"    , 1);
     mov_write_string_metadata(s, pb, "\251cpy", "copyright", 1);
diff -u -Nr gst-libav-1.2.4/gst-libs/ext/libav/libavformat/mp3enc.c gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavformat/mp3enc.c
--- gst-libav-1.2.4/gst-libs/ext/libav/libavformat/mp3enc.c	2014-04-18 12:30:33.000000000 +0200
+++ gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavformat/mp3enc.c	2014-06-28 17:33:25.566856908 +0200
@@ -118,8 +118,11 @@
     MPADecodeHeader  mpah;
     int srate_idx, i, channels;
     int bitrate_idx;
+    int best_bitrate_idx;
+    int best_bitrate_error = INT_MAX;
     int xing_offset;
     int ver = 0;
+    int lsf, bytes_needed;
 
     if (!s->pb->seekable)
         return;
@@ -149,21 +152,51 @@
              return;
     }
 
-    /* 64 kbps frame, should be large enough */
-    bitrate_idx = (ver == 3) ? 5 : 8;
-
     /* dummy MPEG audio header */
     header  =  0xff                                  << 24; // sync
     header |= (0x7 << 5 | ver << 3 | 0x1 << 1 | 0x1) << 16; // sync/audio-version/layer 3/no crc*/
-    header |= (bitrate_idx << 4 | srate_idx << 2)    <<  8;
+    header |= (srate_idx << 2) << 8;
     header |= channels << 6;
+
+    lsf = !((header & (1 << 20) && header & (1 << 19)));
+
+    xing_offset  = xing_offtbl[ver != 3][channels == 1];
+    bytes_needed = 4              // header
+                 + xing_offset
+                 + 4              // xing tag
+                 + 4              // frames/size/toc flags
+                 + 4              // frames
+                 + 4              // size
+                 + XING_TOC_SIZE; // toc
+
+    for (bitrate_idx = 1; bitrate_idx < 15; bitrate_idx++) {
+        int bit_rate = 1000 * avpriv_mpa_bitrate_tab[lsf][3 - 1][bitrate_idx];
+        int error    = FFABS(bit_rate - codec->bit_rate);
+
+        if (error < best_bitrate_error){
+            best_bitrate_error = error;
+            best_bitrate_idx   = bitrate_idx;
+        }
+    }
+
+    for (bitrate_idx = best_bitrate_idx; bitrate_idx < 15; bitrate_idx++) {
+        int32_t mask = bitrate_idx << (4 + 8);
+        header |= mask;
+
+        avpriv_mpegaudio_decode_header(&mpah, header);
+
+        if (bytes_needed <= mpah.frame_size)
+            break;
+
+        header &= ~mask;
+    }
+
     avio_wb32(s->pb, header);
 
     avpriv_mpegaudio_decode_header(&mpah, header);
 
     av_assert0(mpah.frame_size >= XING_MAX_SIZE);
 
-    xing_offset = xing_offtbl[ver != 3][codec->channels == 1];
     ffio_fill(s->pb, 0, xing_offset);
     mp3->xing_offset = avio_tell(s->pb);
     ffio_wfourcc(s->pb, "Xing");
@@ -179,8 +212,7 @@
     for (i = 0; i < XING_TOC_SIZE; i++)
         avio_w8(s->pb, 255 * i / XING_TOC_SIZE);
 
-    mpah.frame_size -= 4 + xing_offset + 4 + 4 + 4 + 4 + XING_TOC_SIZE;
-    ffio_fill(s->pb, 0, mpah.frame_size);
+    ffio_fill(s->pb, 0, mpah.frame_size - bytes_needed);
 }
 
 /*
@@ -219,13 +251,16 @@
 
     if (mp3->xing_offset && pkt->size >= 4) {
         MPADecodeHeader c;
+        uint32_t h;
 
-        avpriv_mpegaudio_decode_header(&c, AV_RB32(pkt->data));
-
-        if (!mp3->initial_bitrate)
-            mp3->initial_bitrate = c.bit_rate;
-        if ((c.bit_rate == 0) || (mp3->initial_bitrate != c.bit_rate))
-            mp3->has_variable_bitrate = 1;
+        h = AV_RB32(pkt->data);
+        if (ff_mpa_check_header(h) == 0) {
+            avpriv_mpegaudio_decode_header(&c, h);
+            if (!mp3->initial_bitrate)
+                mp3->initial_bitrate = c.bit_rate;
+            if ((c.bit_rate == 0) || (mp3->initial_bitrate != c.bit_rate))
+                mp3->has_variable_bitrate = 1;
+        }
 
         mp3_xing_add_frame(mp3, pkt);
     }
diff -u -Nr gst-libav-1.2.4/gst-libs/ext/libav/libavformat/oggdec.c gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavformat/oggdec.c
--- gst-libav-1.2.4/gst-libs/ext/libav/libavformat/oggdec.c	2014-04-18 12:30:33.000000000 +0200
+++ gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavformat/oggdec.c	2014-06-28 17:33:25.566856908 +0200
@@ -46,6 +46,7 @@
     &ff_theora_codec,
     &ff_flac_codec,
     &ff_celt_codec,
+    &ff_opus_codec,
     &ff_old_dirac_codec,
     &ff_old_flac_codec,
     &ff_ogm_video_codec,
diff -u -Nr gst-libav-1.2.4/gst-libs/ext/libav/libavformat/oggdec.h gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavformat/oggdec.h
--- gst-libav-1.2.4/gst-libs/ext/libav/libavformat/oggdec.h	2014-04-18 12:30:33.000000000 +0200
+++ gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavformat/oggdec.h	2014-06-28 17:33:25.566856908 +0200
@@ -116,6 +116,7 @@
 extern const struct ogg_codec ff_ogm_video_codec;
 extern const struct ogg_codec ff_old_dirac_codec;
 extern const struct ogg_codec ff_old_flac_codec;
+extern const struct ogg_codec ff_opus_codec;
 extern const struct ogg_codec ff_skeleton_codec;
 extern const struct ogg_codec ff_speex_codec;
 extern const struct ogg_codec ff_theora_codec;
diff -u -Nr gst-libav-1.2.4/gst-libs/ext/libav/libavformat/oggparseopus.c gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavformat/oggparseopus.c
--- gst-libav-1.2.4/gst-libs/ext/libav/libavformat/oggparseopus.c	1970-01-01 01:00:00.000000000 +0100
+++ gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavformat/oggparseopus.c	2014-06-28 17:33:25.566856908 +0200
@@ -0,0 +1,142 @@
+/*
+ * Opus parser for Ogg
+ * Copyright (c) 2012 Nicolas George
+ *
+ * This file is part of Libav.
+ *
+ * Libav is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * Libav is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with Libav; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <string.h>
+
+#include "libavutil/intreadwrite.h"
+#include "avformat.h"
+#include "internal.h"
+#include "oggdec.h"
+
+struct oggopus_private {
+    int need_comments;
+    unsigned pre_skip;
+    int64_t cur_dts;
+};
+
+#define OPUS_HEAD_SIZE 19
+
+static int opus_header(AVFormatContext *avf, int idx)
+{
+    struct ogg *ogg              = avf->priv_data;
+    struct ogg_stream *os        = &ogg->streams[idx];
+    AVStream *st                 = avf->streams[idx];
+    struct oggopus_private *priv = os->private;
+    uint8_t *packet              = os->buf + os->pstart;
+    uint8_t *extradata;
+
+    if (!priv) {
+        priv = os->private = av_mallocz(sizeof(*priv));
+        if (!priv)
+            return AVERROR(ENOMEM);
+    }
+    if (os->flags & OGG_FLAG_BOS) {
+        if (os->psize < OPUS_HEAD_SIZE || (AV_RL8(packet + 8) & 0xF0) != 0)
+            return AVERROR_INVALIDDATA;
+
+        st->codec->codec_type = AVMEDIA_TYPE_AUDIO;
+        st->codec->codec_id   = AV_CODEC_ID_OPUS;
+        st->codec->channels   = AV_RL8(packet + 9);
+        priv->pre_skip        = AV_RL16(packet + 10);
+
+        extradata = av_malloc(os->psize + FF_INPUT_BUFFER_PADDING_SIZE);
+        if (!extradata)
+            return AVERROR(ENOMEM);
+
+        memcpy(extradata, packet, os->psize);
+        st->codec->extradata      = extradata;
+        st->codec->extradata_size = os->psize;
+
+        st->codec->sample_rate = 48000;
+        avpriv_set_pts_info(st, 64, 1, 48000);
+        priv->need_comments = 1;
+        return 1;
+    }
+
+    if (priv->need_comments) {
+        if (os->psize < 8 || memcmp(packet, "OpusTags", 8))
+            return AVERROR_INVALIDDATA;
+        ff_vorbis_comment(avf, &st->metadata, packet + 8, os->psize - 8);
+        priv->need_comments--;
+        return 1;
+    }
+
+    return 0;
+}
+
+static int opus_packet(AVFormatContext *avf, int idx)
+{
+    struct ogg *ogg              = avf->priv_data;
+    struct ogg_stream *os        = &ogg->streams[idx];
+    AVStream *st                 = avf->streams[idx];
+    struct oggopus_private *priv = os->private;
+    uint8_t *packet              = os->buf + os->pstart;
+    unsigned toc, toc_config, toc_count, frame_size, nb_frames = 1;
+
+    if (!os->psize)
+        return AVERROR_INVALIDDATA;
+
+    toc        = *packet;
+    toc_config = toc >> 3;
+    toc_count  = toc & 3;
+    frame_size = toc_config < 12 ? FFMAX(480, 960 * (toc_config & 3)) :
+                 toc_config < 16 ? 480 << (toc_config & 1) :
+                                   120 << (toc_config & 3);
+    if (toc_count == 3) {
+        if (os->psize < 2)
+            return AVERROR_INVALIDDATA;
+        nb_frames = packet[1] & 0x3F;
+    } else if (toc_count) {
+        nb_frames = 2;
+    }
+
+    os->pduration = frame_size * nb_frames;
+    if (os->lastpts != AV_NOPTS_VALUE) {
+        if (st->start_time == AV_NOPTS_VALUE)
+            st->start_time = os->lastpts;
+        priv->cur_dts = os->lastdts = os->lastpts -= priv->pre_skip;
+    }
+
+    priv->cur_dts += os->pduration;
+    if ((os->flags & OGG_FLAG_EOS)) {
+        int64_t skip = priv->cur_dts - os->granule + priv->pre_skip;
+        skip = FFMIN(skip, os->pduration);
+        if (skip > 0) {
+            os->pduration = skip < os->pduration ? os->pduration - skip : 1;
+            av_log(avf, AV_LOG_WARNING,
+                   "Last packet is truncated to %d (because of unimplemented end trim support).\n",
+                   os->pduration);
+            return AVERROR_PATCHWELCOME;
+        }
+    }
+
+    return 0;
+}
+
+const struct ogg_codec ff_opus_codec = {
+    .name             = "Opus",
+    .magic            = "OpusHead",
+    .magicsize        = 8,
+    .header           = opus_header,
+    .packet           = opus_packet,
+    .granule_is_start = 1,
+    .nb_header        = 1,
+};
diff -u -Nr gst-libav-1.2.4/gst-libs/ext/libav/libavformat/rtmpproto.c gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavformat/rtmpproto.c
--- gst-libav-1.2.4/gst-libs/ext/libav/libavformat/rtmpproto.c	2014-04-18 12:30:33.000000000 +0200
+++ gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavformat/rtmpproto.c	2014-06-28 17:33:25.566856908 +0200
@@ -2443,7 +2443,7 @@
         if ((ret = gen_connect(s, rt)) < 0)
             goto fail;
     } else {
-        if (read_connect(s, s->priv_data) < 0)
+        if ((ret = read_connect(s, s->priv_data)) < 0)
             goto fail;
         rt->is_input = 1;
     }
diff -u -Nr gst-libav-1.2.4/gst-libs/ext/libav/libavformat/version.h gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavformat/version.h
--- gst-libav-1.2.4/gst-libs/ext/libav/libavformat/version.h	2014-04-18 12:30:33.000000000 +0200
+++ gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavformat/version.h	2014-06-28 17:33:25.566856908 +0200
@@ -31,7 +31,7 @@
 
 #define LIBAVFORMAT_VERSION_MAJOR 54
 #define LIBAVFORMAT_VERSION_MINOR 20
-#define LIBAVFORMAT_VERSION_MICRO  3
+#define LIBAVFORMAT_VERSION_MICRO  4
 
 #define LIBAVFORMAT_VERSION_INT AV_VERSION_INT(LIBAVFORMAT_VERSION_MAJOR, \
                                                LIBAVFORMAT_VERSION_MINOR, \
diff -u -Nr gst-libav-1.2.4/gst-libs/ext/libav/libavresample/resample.c gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavresample/resample.c
--- gst-libav-1.2.4/gst-libs/ext/libav/libavresample/resample.c	2014-04-18 12:30:33.000000000 +0200
+++ gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavresample/resample.c	2014-06-28 17:33:25.566856908 +0200
@@ -46,6 +46,7 @@
     void (*resample_one)(struct ResampleContext *c, int no_filter, void *dst0,
                          int dst_index, const void *src0, int src_size,
                          int index, int frac);
+    int padding_size;
 };
 
 
@@ -211,6 +212,7 @@
         goto error;
     c->ideal_dst_incr = c->dst_incr;
 
+    c->padding_size   = (c->filter_length - 1) / 2;
     c->index = -phase_count * ((c->filter_length - 1) / 2);
     c->frac  = 0;
 
@@ -461,8 +463,10 @@
 
 int avresample_get_delay(AVAudioResampleContext *avr)
 {
+    ResampleContext *c = avr->resample;
+
     if (!avr->resample_needed || !avr->resample)
         return 0;
 
-    return avr->resample->buffer->nb_samples;
+    return FFMAX(c->buffer->nb_samples - c->padding_size, 0);
 }
diff -u -Nr gst-libav-1.2.4/gst-libs/ext/libav/libavresample/utils.c gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavresample/utils.c
--- gst-libav-1.2.4/gst-libs/ext/libav/libavresample/utils.c	2014-04-18 12:30:33.000000000 +0200
+++ gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavresample/utils.c	2014-06-28 17:33:25.566856908 +0200
@@ -117,7 +117,7 @@
     }
     if (avr->resample_needed) {
         avr->resample_out_buffer = ff_audio_data_alloc(avr->out_channels,
-                                                       0, avr->internal_sample_fmt,
+                                                       1024, avr->internal_sample_fmt,
                                                        "resample_out_buffer");
         if (!avr->resample_out_buffer) {
             ret = AVERROR(EINVAL);
diff -u -Nr gst-libav-1.2.4/gst-libs/ext/libav/libavutil/lzo.c gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavutil/lzo.c
--- gst-libav-1.2.4/gst-libs/ext/libav/libavutil/lzo.c	2014-04-18 12:30:33.000000000 +0200
+++ gst-libav-1.2.4-9.14/gst-libs/ext/libav/libavutil/lzo.c	2014-06-28 17:33:25.566856908 +0200
@@ -80,6 +80,10 @@
 {
     register const uint8_t *src = c->in;
     register uint8_t *dst       = c->out;
+    if (cnt < 0) {
+        c->error |= AV_LZO_ERROR;
+        return;
+    }
     if (cnt > c->in_end - src) {
         cnt       = FFMAX(c->in_end - src, 0);
         c->error |= AV_LZO_INPUT_DEPLETED;
@@ -103,7 +107,7 @@
 /**
  * @brief Copies previously decoded bytes to current position.
  * @param back how many bytes back we start
- * @param cnt number of bytes to copy, must be >= 0
+ * @param cnt number of bytes to copy, must be > 0
  *
  * cnt > back is valid, this will copy the bytes we just copied,
  * thus creating a repeating pattern with a period length of back.
@@ -111,6 +115,10 @@
 static inline void copy_backptr(LZOContext *c, int back, int cnt)
 {
     register uint8_t *dst       = c->out;
+    if (cnt <= 0) {
+        c->error |= AV_LZO_ERROR;
+        return;
+    }
     if (dst - c->out_start < back) {
         c->error |= AV_LZO_INVALID_BACKPTR;
         return;
diff -u -Nr gst-libav-1.2.4/gst-libs/ext/libav/libswscale/utils.c gst-libav-1.2.4-9.14/gst-libs/ext/libav/libswscale/utils.c
--- gst-libav-1.2.4/gst-libs/ext/libav/libswscale/utils.c	2014-04-18 12:30:33.000000000 +0200
+++ gst-libav-1.2.4-9.14/gst-libs/ext/libav/libswscale/utils.c	2014-06-28 17:33:25.566856908 +0200
@@ -316,7 +316,7 @@
 
         xDstInSrc = xInc - 0x10000;
         for (i = 0; i < dstW; i++) {
-            int xx = (xDstInSrc - ((filterSize - 2) << 16)) / (1 << 17);
+            int xx = (xDstInSrc - ((int64_t)(filterSize - 2) << 16)) / (1 << 17);
             int j;
             (*filterPos)[i] = xx;
             for (j = 0; j < filterSize; j++) {
diff -u -Nr gst-libav-1.2.4/gst-libs/ext/libav/RELEASE gst-libav-1.2.4-9.14/gst-libs/ext/libav/RELEASE
--- gst-libav-1.2.4/gst-libs/ext/libav/RELEASE	2014-04-18 12:30:33.000000000 +0200
+++ gst-libav-1.2.4-9.14/gst-libs/ext/libav/RELEASE	2014-06-28 17:33:25.566856908 +0200
@@ -1 +1 @@
-9.12
+9.14
diff -u -Nr gst-libav-1.2.4/gst-libs/ext/libav/tests/ref/lavf/mkv gst-libav-1.2.4-9.14/gst-libs/ext/libav/tests/ref/lavf/mkv
--- gst-libav-1.2.4/gst-libs/ext/libav/tests/ref/lavf/mkv	2014-04-18 12:30:33.000000000 +0200
+++ gst-libav-1.2.4-9.14/gst-libs/ext/libav/tests/ref/lavf/mkv	2014-06-28 17:33:25.566856908 +0200
@@ -1,3 +1,3 @@
-2c6fbc2c818c849e77702141294d775d *./tests/data/lavf/lavf.mkv
+af61b3dcd6a9d2608c2368136c96b437 *./tests/data/lavf/lavf.mkv
 320262 ./tests/data/lavf/lavf.mkv
 ./tests/data/lavf/lavf.mkv CRC=0xd86284dd
diff -u -Nr gst-libav-1.2.4/gst-libs/ext/libav/tests/ref/seek/lavf-mkv gst-libav-1.2.4-9.14/gst-libs/ext/libav/tests/ref/seek/lavf-mkv
--- gst-libav-1.2.4/gst-libs/ext/libav/tests/ref/seek/lavf-mkv	2014-04-18 12:30:33.000000000 +0200
+++ gst-libav-1.2.4-9.14/gst-libs/ext/libav/tests/ref/seek/lavf-mkv	2014-06-28 17:33:25.566856908 +0200
@@ -1,53 +1,53 @@
-ret: 0         st: 1 flags:1 dts:-0.011000 pts:-0.011000 pos:    512 size:   208
-ret: 0         st:-1 flags:0  ts:-1.000000
 ret: 0         st: 1 flags:1 dts: 0.000000 pts: 0.000000 pos:    512 size:   208
+ret: 0         st:-1 flags:0  ts:-1.000000
+ret: 0         st: 0 flags:1 dts: 0.011000 pts: 0.011000 pos:    728 size: 27837
 ret: 0         st:-1 flags:1  ts: 1.894167
-ret: 0         st: 0 flags:1 dts: 0.960000 pts: 0.960000 pos: 292150 size: 27834
+ret: 0         st: 0 flags:1 dts: 0.971000 pts: 0.971000 pos: 292150 size: 27834
 ret: 0         st: 0 flags:0  ts: 0.788000
-ret: 0         st: 0 flags:1 dts: 0.960000 pts: 0.960000 pos: 292150 size: 27834
+ret: 0         st: 0 flags:1 dts: 0.971000 pts: 0.971000 pos: 292150 size: 27834
 ret: 0         st: 0 flags:1  ts:-0.317000
-ret: 0         st: 1 flags:1 dts: 0.000000 pts: 0.000000 pos:    512 size:   208
+ret: 0         st: 0 flags:1 dts: 0.011000 pts: 0.011000 pos:    728 size: 27837
 ret: 0         st: 1 flags:0  ts: 2.577000
 ret:-EOF
 ret: 0         st: 1 flags:1  ts: 1.471000
-ret: 0         st: 1 flags:1 dts: 0.982000 pts: 0.982000 pos: 319991 size:   209
+ret: 0         st: 1 flags:1 dts: 0.993000 pts: 0.993000 pos: 319991 size:   209
 ret: 0         st:-1 flags:0  ts: 0.365002
-ret: 0         st: 0 flags:1 dts: 0.480000 pts: 0.480000 pos: 146703 size: 27925
+ret: 0         st: 0 flags:1 dts: 0.491000 pts: 0.491000 pos: 146703 size: 27925
 ret: 0         st:-1 flags:1  ts:-0.740831
-ret: 0         st: 1 flags:1 dts: 0.000000 pts: 0.000000 pos:    512 size:   208
+ret: 0         st: 0 flags:1 dts: 0.011000 pts: 0.011000 pos:    728 size: 27837
 ret: 0         st: 0 flags:0  ts: 2.153000
 ret:-EOF
 ret: 0         st: 0 flags:1  ts: 1.048000
-ret: 0         st: 0 flags:1 dts: 0.960000 pts: 0.960000 pos: 292150 size: 27834
+ret: 0         st: 0 flags:1 dts: 0.971000 pts: 0.971000 pos: 292150 size: 27834
 ret: 0         st: 1 flags:0  ts:-0.058000
-ret: 0         st: 1 flags:1 dts: 0.015000 pts: 0.015000 pos:    512 size:   208
+ret: 0         st: 1 flags:1 dts: 0.000000 pts: 0.000000 pos:    512 size:   208
 ret: 0         st: 1 flags:1  ts: 2.836000
-ret: 0         st: 1 flags:1 dts: 0.982000 pts: 0.982000 pos: 319991 size:   209
+ret: 0         st: 1 flags:1 dts: 0.993000 pts: 0.993000 pos: 319991 size:   209
 ret: 0         st:-1 flags:0  ts: 1.730004
 ret:-EOF
 ret: 0         st:-1 flags:1  ts: 0.624171
-ret: 0         st: 0 flags:1 dts: 0.480000 pts: 0.480000 pos: 146703 size: 27925
+ret: 0         st: 0 flags:1 dts: 0.491000 pts: 0.491000 pos: 146703 size: 27925
 ret: 0         st: 0 flags:0  ts:-0.482000
-ret: 0         st: 1 flags:1 dts: 0.000000 pts: 0.000000 pos:    512 size:   208
+ret: 0         st: 0 flags:1 dts: 0.011000 pts: 0.011000 pos:    728 size: 27837
 ret: 0         st: 0 flags:1  ts: 2.413000
-ret: 0         st: 0 flags:1 dts: 0.960000 pts: 0.960000 pos: 292150 size: 27834
+ret: 0         st: 0 flags:1 dts: 0.971000 pts: 0.971000 pos: 292150 size: 27834
 ret: 0         st: 1 flags:0  ts: 1.307000
 ret:-EOF
 ret: 0         st: 1 flags:1  ts: 0.201000
-ret: 0         st: 1 flags:1 dts: 0.015000 pts: 0.015000 pos:    512 size:   208
-ret: 0         st:-1 flags:0  ts:-0.904994
 ret: 0         st: 1 flags:1 dts: 0.000000 pts: 0.000000 pos:    512 size:   208
+ret: 0         st:-1 flags:0  ts:-0.904994
+ret: 0         st: 0 flags:1 dts: 0.011000 pts: 0.011000 pos:    728 size: 27837
 ret: 0         st:-1 flags:1  ts: 1.989173
-ret: 0         st: 0 flags:1 dts: 0.960000 pts: 0.960000 pos: 292150 size: 27834
+ret: 0         st: 0 flags:1 dts: 0.971000 pts: 0.971000 pos: 292150 size: 27834
 ret: 0         st: 0 flags:0  ts: 0.883000
-ret: 0         st: 0 flags:1 dts: 0.960000 pts: 0.960000 pos: 292150 size: 27834
+ret: 0         st: 0 flags:1 dts: 0.971000 pts: 0.971000 pos: 292150 size: 27834
 ret: 0         st: 0 flags:1  ts:-0.222000
-ret: 0         st: 1 flags:1 dts: 0.000000 pts: 0.000000 pos:    512 size:   208
+ret: 0         st: 0 flags:1 dts: 0.011000 pts: 0.011000 pos:    728 size: 27837
 ret: 0         st: 1 flags:0  ts: 2.672000
 ret:-EOF
 ret: 0         st: 1 flags:1  ts: 1.566000
-ret: 0         st: 1 flags:1 dts: 0.982000 pts: 0.982000 pos: 319991 size:   209
+ret: 0         st: 1 flags:1 dts: 0.993000 pts: 0.993000 pos: 319991 size:   209
 ret: 0         st:-1 flags:0  ts: 0.460008
-ret: 0         st: 0 flags:1 dts: 0.480000 pts: 0.480000 pos: 146703 size: 27925
+ret: 0         st: 0 flags:1 dts: 0.491000 pts: 0.491000 pos: 146703 size: 27925
 ret: 0         st:-1 flags:1  ts:-0.645825
-ret: 0         st: 1 flags:1 dts: 0.000000 pts: 0.000000 pos:    512 size:   208
+ret: 0         st: 0 flags:1 dts: 0.011000 pts: 0.011000 pos:    728 size: 27837
