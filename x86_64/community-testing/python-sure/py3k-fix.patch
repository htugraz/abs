From dfa565626a53c8902a7f108417281c95f8e1f241 Mon Sep 17 00:00:00 2001
From: Timo Furrer <tuxtimo@gmail.com>
Date: Thu, 11 Dec 2014 10:45:50 +0100
Subject: [PATCH] make python 3 compatible again The function objects in python
 3 have no `func_code` member anymore. Use `__code__` instead. The byte
 objects in python 3 have no `format` method. Use `encode` instead. The
 representation of the strings and encoded strings are different in python 2
 and python 3 thus use PY3 from six. Remove unlucky example from README since
 python 3 returns a float and python 2 an int in this situation Python 2 and 3
 build is working again

---
 README.md                       |  1 -
 sure/old.py                     |  8 ++++----
 tests/test_assertion_builder.py | 10 ++++++++--
 3 files changed, 12 insertions(+), 7 deletions(-)

diff --git a/README.md b/README.md
index 03d7e2f..5e09d57 100644
--- a/README.md
+++ b/README.md
@@ -32,7 +32,6 @@ import sure
 
 (4).should.be.equal(2 + 2)
 (7.5).should.eql(3.5 + 4)
-(2).should.equal(8 / 4)
 
 (3).shouldnt.be.equal(5)
 ```
diff --git a/sure/old.py b/sure/old.py
index 70822e1..13a3f74 100644
--- a/sure/old.py
+++ b/sure/old.py
@@ -42,10 +42,10 @@
 
 
 def identify_callable_location(callable_object):
-    filename = os.path.relpath(callable_object.func_code.co_filename)
-    lineno = callable_object.func_code.co_firstlineno
-    callable_name = callable_object.func_code.co_name
-    return b'{0} [{1} line {2}]'.format(callable_name, filename, lineno)
+    filename = os.path.relpath(callable_object.__code__.co_filename)
+    lineno = callable_object.__code__.co_firstlineno
+    callable_name = callable_object.__code__.co_name
+    return '{0} [{1} line {2}]'.format(callable_name, filename, lineno).encode()
 
 
 def is_iterable(obj):
diff --git a/tests/test_assertion_builder.py b/tests/test_assertion_builder.py
index 6a58c1a..5b3d2de 100644
--- a/tests/test_assertion_builder.py
+++ b/tests/test_assertion_builder.py
@@ -648,13 +648,19 @@ def blah(num):
         raise RuntimeError('should not have reached here')
 
     except AssertionError as e:
-        expect(str(e)).to.equal("When calling 'blah [tests/test_assertion_builder.py line 633]' the exception message does not match. Expected to match regex: u'invalid regex'\n against:\n u'this message'")
+        if PY3:
+            expect(str(e)).to.equal("When calling b'blah [tests/test_assertion_builder.py line 633]' the exception message does not match. Expected to match regex: 'invalid regex'\n against:\n 'this message'")
+        else:
+            expect(str(e)).to.equal("When calling 'blah [tests/test_assertion_builder.py line 633]' the exception message does not match. Expected to match regex: u'invalid regex'\n against:\n u'this message'")
 
     try:
         expect(blah).when.called_with(1).should.throw(ValueError, re.compile(r'invalid regex'))
         raise RuntimeError('should not have reached here')
     except AssertionError as e:
-        expect(str(e)).to.equal("When calling 'blah [tests/test_assertion_builder.py line 633]' the exception message does not match. Expected to match regex: u'invalid regex'\n against:\n u'this message'")
+        if PY3:
+            expect(str(e)).to.equal("When calling b'blah [tests/test_assertion_builder.py line 633]' the exception message does not match. Expected to match regex: 'invalid regex'\n against:\n 'this message'")
+        else:
+            expect(str(e)).to.equal("When calling 'blah [tests/test_assertion_builder.py line 633]' the exception message does not match. Expected to match regex: u'invalid regex'\n against:\n u'this message'")
 
 def test_should_not_be_different():
     ("'something'.should_not.be.different('SOMETHING'.lower())")
