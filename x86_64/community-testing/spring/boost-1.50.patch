diff -ru spring_89.0/rts/Game/Camera/CameraController.cpp /home/svenstaro/src/spring/rts/Game/Camera/CameraController.cpp
--- spring_89.0/rts/Game/Camera/CameraController.cpp	2012-07-10 00:10:07.000000000 +0200
+++ /home/svenstaro/src/spring/rts/Game/Camera/CameraController.cpp	2012-07-13 06:34:43.066060493 +0200
@@ -59,7 +59,7 @@
 bool CCameraController::GetUseDistToGroundForIcons() {
 
 	const float3& dir     = GetDir().UnsafeNormalize();
-	const float dot       = std::min(1.0f, std::max(0.0f, fabs(dir.dot(UpVector))));
+	const float dot       = std::min(1.0f, std::max(0.0f, math::fabs(dir.dot(UpVector))));
 
 	if (dot < switchVal) {
 		// flat angle (typical for first person camera)
diff -ru spring_89.0/rts/Game/Camera/FPSController.cpp /home/svenstaro/src/spring/rts/Game/Camera/FPSController.cpp
--- spring_89.0/rts/Game/Camera/FPSController.cpp	2012-07-10 00:10:07.000000000 +0200
+++ /home/svenstaro/src/spring/rts/Game/Camera/FPSController.cpp	2012-07-13 06:34:43.066060493 +0200
@@ -80,9 +80,9 @@
 		oldHeight = pos.y - gndHeight;
 	}
 
-	dir.x = (float)(cos(camera->rot.x) * sin(camera->rot.y));
-	dir.z = (float)(cos(camera->rot.x) * cos(camera->rot.y));
-	dir.y = (float)(sin(camera->rot.x));
+	dir.x = (float)(math::cos(camera->rot.x) * math::sin(camera->rot.y));
+	dir.z = (float)(math::cos(camera->rot.x) * math::cos(camera->rot.y));
+	dir.y = (float)(math::sin(camera->rot.x));
 	dir.ANormalize();
 }
 
diff -ru spring_89.0/rts/Game/Camera/FreeController.cpp /home/svenstaro/src/spring/rts/Game/Camera/FreeController.cpp
--- spring_89.0/rts/Game/Camera/FreeController.cpp	2012-07-10 00:10:07.000000000 +0200
+++ /home/svenstaro/src/spring/rts/Game/Camera/FreeController.cpp	2012-07-13 06:34:43.066060493 +0200
@@ -51,9 +51,9 @@
 	dir = float3(0.0f, -2.0f, -1.0f);
 	dir.ANormalize();
 	if (camera) {
-		const float hDist = sqrt((dir.x * dir.x) + (dir.z * dir.z));
-		camera->rot.y = atan2(dir.x, dir.z);
-		camera->rot.x = atan2(dir.y, hDist);
+		const float hDist = math::sqrt((dir.x * dir.x) + (dir.z * dir.z));
+		camera->rot.y = math::atan2(dir.x, dir.z);
+		camera->rot.x = math::atan2(dir.y, hDist);
 	}
 	pos -= (dir * 1000.0f);
 
@@ -84,14 +84,14 @@
 
 	// lock the view direction to the target
 	const float3 diff(trackPos - pos);
-	const float rads = atan2(diff.x, diff.z);
+	const float rads = math::atan2(diff.x, diff.z);
 	camera->rot.y = rads;
 
 	const float len2D = diff.Length2D();
-	if (fabs(len2D) <= 0.001f) {
+	if (math::fabs(len2D) <= 0.001f) {
 		camera->rot.x = 0.0f;
 	} else {
-		camera->rot.x = atan2((trackPos.y - pos.y), len2D);
+		camera->rot.x = math::atan2((trackPos.y - pos.y), len2D);
 	}
 
 	camera->UpdateForward();
@@ -130,11 +130,11 @@
 		if (pos.y < (gndHeight + gndOffset + 1.0f)) {
 			float3 hDir;
 			hDir.y = 0.0f;
-			hDir.x = (float)sin(camera->rot.y);
-			hDir.z = (float)cos(camera->rot.y);
+			hDir.x = (float)math::sin(camera->rot.y);
+			hDir.z = (float)math::cos(camera->rot.y);
 			const float3 gndNormal = ground->GetSmoothNormal(pos.x, pos.z, false);
 			const float dot = gndNormal.dot(hDir);
-			const float gndRotX = (float)acos(dot) - (PI * 0.5f);
+			const float gndRotX = (float)math::acos(dot) - (PI * 0.5f);
 			const float rotXdiff = (gndRotX - camera->rot.x);
 			autoTiltVel = (autoTilt * rotXdiff);
 		}
@@ -214,8 +214,8 @@
 		// convert the angular velocity into its positional change
 		const float3 diff2 = (pos - trackPos);
 		const float deltaRad = (avel.y * ft);
-		const float cos_val = cos(deltaRad);
-		const float sin_val = sin(deltaRad);
+		const float cos_val = math::cos(deltaRad);
+		const float sin_val = math::sin(deltaRad);
 		pos.x = trackPos.x + ((cos_val * diff2.x) + (sin_val * diff2.z));
 		pos.z = trackPos.z + ((cos_val * diff2.z) - (sin_val * diff2.x));
 	}
@@ -246,7 +246,7 @@
 		if (pos.y < minHeight) {
 			pos.y = minHeight;
 			if (gndLock) {
-				vel.y = min(fabs(scrollSpeed), ((minHeight - prevPos.y) / ft));
+				vel.y = min(math::fabs(scrollSpeed), ((minHeight - prevPos.y) / ft));
 			} else {
 				vel.y = 0.0f;
 			}
@@ -263,7 +263,7 @@
 		camera->rot.x = -xRotLimit;
 		avel.x = 0.0f;
 	}
-	camera->rot.y = fmod(camera->rot.y, PI * 2.0f);
+	camera->rot.y = math::fmod(camera->rot.y, PI * 2.0f);
 
 	// setup for the next loop
 	prevVel  = vel;
@@ -277,9 +277,9 @@
 float3 CFreeController::GetDir() const
 {
 	float3 dir;
-	dir.x = (float)(sin(camera->rot.y) * cos(camera->rot.x));
-	dir.z = (float)(cos(camera->rot.y) * cos(camera->rot.x));
-	dir.y = (float)(sin(camera->rot.x));
+	dir.x = (float)(math::sin(camera->rot.y) * math::cos(camera->rot.x));
+	dir.z = (float)(math::cos(camera->rot.y) * math::cos(camera->rot.x));
+	dir.y = (float)(math::sin(camera->rot.x));
 	dir.ANormalize();
 	return dir;
 }
@@ -373,7 +373,7 @@
 	if ((yDiff * dir.y) >= 0.0f) {
 		pos = float3(newPos.x, h, newPos.z);
 	} else {
-		pos = target - (dir * fabs(yDiff / dir.y));
+		pos = target - (dir * math::fabs(yDiff / dir.y));
 	} // FIXME
 /*
 	const float oldPosY = pos.y;
diff -ru spring_89.0/rts/Game/Camera/OrbitController.cpp /home/svenstaro/src/spring/rts/Game/Camera/OrbitController.cpp
--- spring_89.0/rts/Game/Camera/OrbitController.cpp	2012-07-10 00:10:07.000000000 +0200
+++ /home/svenstaro/src/spring/rts/Game/Camera/OrbitController.cpp	2012-07-13 06:34:43.066060493 +0200
@@ -51,8 +51,8 @@
 	const float3 w = (v / v.Length()); // do not normalize v in-place
 
 	const float d = v.Length();
-	const float e = RAD2DEG(acos(v.Length2D() / d));
-	const float r = RAD2DEG(acos(w.x));
+	const float e = RAD2DEG(math::acos(v.Length2D() / d));
+	const float r = RAD2DEG(math::acos(w.x));
 
 	distance  = cDistance = d;
 	elevation = cElevation = e;
@@ -251,12 +251,12 @@
 	float tx = cx;
 
 	tx = cx;
-	cx = cx * cos(beta) + cy * sin(beta);
-	cy = tx * sin(beta) + cy * cos(beta);
+	cx = cx * math::cos(beta) + cy * math::sin(beta);
+	cy = tx * math::sin(beta) + cy * math::cos(beta);
 
 	tx = cx;
-	cx = cx * cos(gamma) - cz * sin(gamma);
-	cz = tx * sin(gamma) + cz * cos(gamma);
+	cx = cx * math::cos(gamma) - cz * math::sin(gamma);
+	cz = tx * math::sin(gamma) + cz * math::cos(gamma);
 
 	return float3(cx, cy, cz);
 }
diff -ru spring_89.0/rts/Game/Camera/OverheadController.cpp /home/svenstaro/src/spring/rts/Game/Camera/OverheadController.cpp
--- spring_89.0/rts/Game/Camera/OverheadController.cpp	2012-07-10 00:10:07.000000000 +0200
+++ /home/svenstaro/src/spring/rts/Game/Camera/OverheadController.cpp	2012-07-13 06:34:43.066060493 +0200
@@ -52,7 +52,7 @@
 		move.x = -move.x;
 		move.y = -move.y;
 	}
-	move *= sqrt(move.z) * 200;
+	move *= math::sqrt(move.z) * 200;
 
 	pos.x += move.x * pixelSize * 2.0f * scrollSpeed;
 	pos.z -= move.y * pixelSize * 2.0f * scrollSpeed;
diff -ru spring_89.0/rts/Game/Camera/RotOverheadController.cpp /home/svenstaro/src/spring/rts/Game/Camera/RotOverheadController.cpp
--- spring_89.0/rts/Game/Camera/RotOverheadController.cpp	2012-07-10 00:10:07.000000000 +0200
+++ /home/svenstaro/src/spring/rts/Game/Camera/RotOverheadController.cpp	2012-07-13 06:34:43.066060493 +0200
@@ -29,7 +29,7 @@
 
 void CRotOverheadController::KeyMove(float3 move)
 {
-	move *= sqrt(move.z) * 400;
+	move *= math::sqrt(move.z) * 400;
 
 	float3 flatForward = camera->forward;
 	if(camera->forward.y < -0.9f)
@@ -68,9 +68,9 @@
 
 void CRotOverheadController::UpdateVectors()
 {
-	dir.x=(float)(sin(camera->rot.y) * cos(camera->rot.x));
-	dir.y=(float)(sin(camera->rot.x));
-	dir.z=(float)(cos(camera->rot.y) * cos(camera->rot.x));
+	dir.x=(float)(math::sin(camera->rot.y) * math::cos(camera->rot.x));
+	dir.y=(float)(math::sin(camera->rot.x));
+	dir.z=(float)(math::cos(camera->rot.y) * math::cos(camera->rot.x));
 	dir.ANormalize();
 
 	pos.x = Clamp(pos.x, 0.01f, gs->mapx * SQUARE_SIZE - 0.01f);
diff -ru spring_89.0/rts/Game/Camera/SmoothController.cpp /home/svenstaro/src/spring/rts/Game/Camera/SmoothController.cpp
--- spring_89.0/rts/Game/Camera/SmoothController.cpp	2012-07-10 00:10:07.000000000 +0200
+++ /home/svenstaro/src/spring/rts/Game/Camera/SmoothController.cpp	2012-07-13 06:34:43.066060493 +0200
@@ -55,7 +55,7 @@
 		move.y = -move.y;
 	}
 
-	move *= sqrt(move.z) * 200.0f;
+	move *= math::sqrt(move.z) * 200.0f;
 
 	const float3 thisMove(move.x * pixelSize * 2.0f * scrollSpeed, 0.0f, -move.y * pixelSize * 2.0f * scrollSpeed);
 
@@ -103,7 +103,7 @@
 		move.x = -move.x;
 		move.y = -move.y;
 	}
-	move *= sqrt(move.z) * 200.0f;
+	move *= math::sqrt(move.z) * 200.0f;
 
 	const float3 thisMove(move.x * pixelSize * 2.0f * scrollSpeed, 0.0f, -move.y * pixelSize * 2.0f * scrollSpeed);
 
diff -ru spring_89.0/rts/Game/Camera/TWController.cpp /home/svenstaro/src/spring/rts/Game/Camera/TWController.cpp
--- spring_89.0/rts/Game/Camera/TWController.cpp	2012-07-10 00:10:07.000000000 +0200
+++ /home/svenstaro/src/spring/rts/Game/Camera/TWController.cpp	2012-07-13 06:34:43.066060493 +0200
@@ -35,7 +35,7 @@
 	flatForward.y=0;
 	flatForward.ANormalize();
 
-	move *= sqrt(move.z) * 200;
+	move *= math::sqrt(move.z) * 200;
 	pos  += (camera->right * move.x + flatForward * move.y) * scrollSpeed;
 	UpdateVectors();
 }
@@ -79,9 +79,9 @@
 
 	camera->rot.x = Clamp(camera->rot.x, -PI * 0.4f, -0.1f);
 
-	dir.x = sin(camera->rot.y) * cos(camera->rot.x);
-	dir.y = sin(camera->rot.x);
-	dir.z = cos(camera->rot.y) * cos(camera->rot.x);
+	dir.x = math::sin(camera->rot.y) * math::cos(camera->rot.x);
+	dir.y = math::sin(camera->rot.x);
+	dir.z = math::cos(camera->rot.y) * math::cos(camera->rot.x);
 	dir.ANormalize();
 }
 
diff -ru spring_89.0/rts/Game/Camera.cpp /home/svenstaro/src/spring/rts/Game/Camera.cpp
--- spring_89.0/rts/Game/Camera.cpp	2012-07-10 00:10:07.000000000 +0200
+++ /home/svenstaro/src/spring/rts/Game/Camera.cpp	2012-07-13 06:34:43.066060493 +0200
@@ -89,7 +89,7 @@
 	up.UnsafeANormalize();
 
 	const float aspect = globalRendering->aspectRatio;
-	const float viewx = tan(aspect * halfFov);
+	const float viewx = math::tan(aspect * halfFov);
 	const float viewy = tanHalfFov;
 
 	if (globalRendering->viewSizeY <= 0) {
@@ -218,9 +218,9 @@
 
 void CCamera::UpdateForward()
 {
-	forward.z = cos(rot.y) * cos(rot.x);
-	forward.x = sin(rot.y) * cos(rot.x);
-	forward.y = sin(rot.x);
+	forward.z = math::cos(rot.y) * math::cos(rot.x);
+	forward.x = math::sin(rot.y) * math::cos(rot.x);
+	forward.y = math::sin(rot.x);
 	forward.Normalize();
 }
 
@@ -229,7 +229,7 @@
 {
 	fov = myfov;
 	halfFov = (fov * 0.5f) * (PI / 180.f);
-	tanHalfFov = tan(halfFov);
+	tanHalfFov = math::tan(halfFov);
 }
 
 
@@ -330,7 +330,7 @@
 	float3 pInt;
 
 	// prevent DIV0 when calculating line.dir
-	if (fabs(xdir.z) < 0.001f)
+	if (math::fabs(xdir.z) < 0.001f)
 		xdir.z = 0.001f;
 
 	if (ydir.y != 0.0f) {
diff -ru spring_89.0/rts/Game/CameraHandler.cpp /home/svenstaro/src/spring/rts/Game/CameraHandler.cpp
--- spring_89.0/rts/Game/CameraHandler.cpp	2012-07-10 00:10:07.000000000 +0200
+++ /home/svenstaro/src/spring/rts/Game/CameraHandler.cpp	2012-07-13 06:34:43.066060493 +0200
@@ -139,7 +139,7 @@
 		cameraTimeLeft = std::max(0.0f, (cameraTimeLeft - globalRendering->lastFrameTime));
 		const float nextTime = cameraTimeLeft;
 		const float exp = cameraTimeExponent;
-		const float ratio = 1.0f - (float)pow((nextTime / currTime), exp);
+		const float ratio = 1.0f - (float)math::pow((nextTime / currTime), exp);
 
 		const float  deltaFOV = wantedCamFOV - camera->GetFov();
 		const float3 deltaPos = wantedCamPos - camera->pos;
diff -ru spring_89.0/rts/Game/GameServer.cpp /home/svenstaro/src/spring/rts/Game/GameServer.cpp
--- spring_89.0/rts/Game/GameServer.cpp	2012-07-10 00:10:07.000000000 +0200
+++ /home/svenstaro/src/spring/rts/Game/GameServer.cpp	2012-07-13 06:34:42.936060485 +0200
@@ -253,7 +253,7 @@
 	// Something in CGameServer::CGameServer borks the FPU control word
 	// maybe the threading, or something in CNet::InitServer() ??
 	// Set single precision floating point math.
-	streflop_init<streflop::Simple>();
+	streflop::streflop_init<streflop::Simple>();
 #endif
 }
 
diff -ru spring_89.0/rts/Game/SelectedUnitsAI.cpp /home/svenstaro/src/spring/rts/Game/SelectedUnitsAI.cpp
--- spring_89.0/rts/Game/SelectedUnitsAI.cpp	2012-07-10 00:10:07.000000000 +0200
+++ /home/svenstaro/src/spring/rts/Game/SelectedUnitsAI.cpp	2012-07-13 06:34:43.086060494 +0200
@@ -179,7 +179,7 @@
 		const float3 sideDir = frontdir.cross(UpVector);
 
 		// calculate so that the units form in an aproximate square
-		float length = 100.0f + (sqrt((float)nbrOfSelectedUnits) * 32.0f);
+		float length = 100.0f + (math::sqrt((float)nbrOfSelectedUnits) * 32.0f);
 
 		// push back some extra params so it confer with a front move
 		c.params.push_back(pos.x + (sideDir.x * length));
diff -ru spring_89.0/rts/Game/TraceRay.cpp /home/svenstaro/src/spring/rts/Game/TraceRay.cpp
--- spring_89.0/rts/Game/TraceRay.cpp	2012-07-10 00:10:07.000000000 +0200
+++ /home/svenstaro/src/spring/rts/Game/TraceRay.cpp	2012-07-13 06:34:43.066060493 +0200
@@ -75,7 +75,7 @@
 	if (closeFlatLength > length)
 		closeFlatLength = length;
 
-	if (fabs(linear - quadratic * closeFlatLength) < 0.15f) {
+	if (math::fabs(linear - quadratic * closeFlatLength) < 0.15f) {
 		// relatively flat region -> use approximation
 		dif.y -= (linear + quadratic * closeFlatLength) * closeFlatLength;
 
diff -ru spring_89.0/rts/Game/UI/EndGameBox.cpp /home/svenstaro/src/spring/rts/Game/UI/EndGameBox.cpp
--- spring_89.0/rts/Game/UI/EndGameBox.cpp	2012-07-10 00:10:07.000000000 +0200
+++ /home/svenstaro/src/spring/rts/Game/UI/EndGameBox.cpp	2012-07-13 06:34:43.066060493 +0200
@@ -29,11 +29,11 @@
 
 	if (num == 0) {
 		sprintf(c, "0");
-	} else if (fabs(num) < 10 * mul) {
+	} else if (math::fabs(num) < 10 * mul) {
 		sprintf(c, "%.1f",  num);
-	} else if (fabs(num) < 10000 * mul) {
+	} else if (math::fabs(num) < 10000 * mul) {
 		sprintf(c, "%.0f",  num);
-	} else if (fabs(num) < 10000000 * mul) {
+	} else if (math::fabs(num) < 10000000 * mul) {
 		sprintf(c, "%.0fk", num / 1000);
 	} else {
 		sprintf(c, "%.0fM", num / 1000000);
@@ -165,7 +165,7 @@
 	if (dispMode > 0 ) {
 		if ((mx > (box.x1 + 0.01f)) && (mx < (box.x1 + 0.12f)) &&
 		    (my < (box.y1 + 0.57f)) && (my > (box.y1 + 0.571f - stats.size()*0.02f))) {
-			int sel = (int) floor(-(my - box.y1 - 0.57f) * 50);
+			int sel = (int) math::floor(-(my - box.y1 - 0.57f) * 50);
 
 			if (button == 1) {
 				stat1 = sel;
@@ -341,7 +341,7 @@
 
 		if ((mx > box.x1 + 0.01f) && (mx < box.x1 + 0.12f) &&
 		    (my < box.y1 + 0.57f) && (my > box.y1 + 0.571f - (stats.size() * 0.02f))) {
-			const int sel = (int) floor(50 * -(my - box.y1 - 0.57f));
+			const int sel = (int) math::floor(50 * -(my - box.y1 - 0.57f));
 
 			glColor4f(0.7f, 0.2f, 0.2f, guiAlpha);
 			glDisable(GL_TEXTURE_2D);
diff -ru spring_89.0/rts/Game/UI/EndGameBox.h /home/svenstaro/src/spring/rts/Game/UI/EndGameBox.h
--- spring_89.0/rts/Game/UI/EndGameBox.h	2012-07-10 00:10:07.000000000 +0200
+++ /home/svenstaro/src/spring/rts/Game/UI/EndGameBox.h	2012-07-13 06:34:43.066060493 +0200
@@ -60,8 +60,8 @@
 			if (team >= 0 && static_cast<size_t>(team) >= values.size()) {
 				values.resize(team + 1);
 			}
-			if (values[team].size() > 0 && fabs(value-values[team].back()) > maxdif) {
-				maxdif = fabs(value-values[team].back());
+			if (values[team].size() > 0 && math::fabs(value-values[team].back()) > maxdif) {
+				maxdif = math::fabs(value-values[team].back());
 			}
 
 			values[team].push_back(value);
diff -ru spring_89.0/rts/Game/UI/MouseCursor.cpp /home/svenstaro/src/spring/rts/Game/UI/MouseCursor.cpp
--- spring_89.0/rts/Game/UI/MouseCursor.cpp	2012-07-10 00:10:07.000000000 +0200
+++ /home/svenstaro/src/spring/rts/Game/UI/MouseCursor.cpp	2012-07-13 06:34:43.066060493 +0200
@@ -355,7 +355,7 @@
 		return;
 	}
 
-	animTime = fmod(animTime + globalRendering->lastFrameTime, animPeriod);
+	animTime = math::fmod(animTime + globalRendering->lastFrameTime, animPeriod);
 
 	if (animTime < frames[currentFrame].startTime) {
 		currentFrame = 0;
diff -ru spring_89.0/rts/Game/UI/ResourceBar.cpp /home/svenstaro/src/spring/rts/Game/UI/ResourceBar.cpp
--- spring_89.0/rts/Game/UI/ResourceBar.cpp	2012-07-10 00:10:07.000000000 +0200
+++ /home/svenstaro/src/spring/rts/Game/UI/ResourceBar.cpp	2012-07-13 06:34:43.066060493 +0200
@@ -48,11 +48,11 @@
 
 	if (num == 0)
 		sprintf(c, "0");
-	if (       fabs(num) < (10       * mul)) {
+	if (       math::fabs(num) < (10       * mul)) {
 		sprintf(c, "%.1f",  num);
-	} else if (fabs(num) < (10000    * mul)) {
+	} else if (math::fabs(num) < (10000    * mul)) {
 		sprintf(c, "%.0f",  num);
-	} else if (fabs(num) < (10000000 * mul)) {
+	} else if (math::fabs(num) < (10000000 * mul)) {
 		sprintf(c, "%.0fk", num / 1000);
 	} else {
 		sprintf(c, "%.0fM", num / 1000000);
@@ -180,11 +180,11 @@
 
 	smallFont->SetTextColor(1.0f, 0.3f, 0.3f, 1.0f); // Expenses
 	smallFont->glFormat(metalx  + 0.044f, box.y1, labelsFontSize, FONT_DESCENDER | fontOptions, "-%s(-%s)",
-			FloatToSmallString(fabs(myTeam->prevMetalPull)).c_str(),
-			FloatToSmallString(fabs(myTeam->metalSent)).c_str());
+			FloatToSmallString(math::fabs(myTeam->prevMetalPull)).c_str(),
+			FloatToSmallString(math::fabs(myTeam->metalSent)).c_str());
 	smallFont->glFormat(energyx + 0.044f, box.y1, labelsFontSize, FONT_DESCENDER | fontOptions, "-%s(-%s)",
-			FloatToSmallString(fabs(myTeam->prevEnergyPull)).c_str(),
-			FloatToSmallString(fabs(myTeam->energySent)).c_str());
+			FloatToSmallString(math::fabs(myTeam->prevEnergyPull)).c_str(),
+			FloatToSmallString(math::fabs(myTeam->energySent)).c_str());
 
 	smallFont->SetTextColor(0.4f, 1.0f, 0.4f, 0.95f); // Income
 	smallFont->glFormat(metalx  + 0.044f, box.y2 - 2*globalRendering->pixelY, labelsFontSize, FONT_ASCENDER | fontOptions, "+%s",
diff -ru spring_89.0/rts/Game/UI/SelectionKeyHandler.cpp /home/svenstaro/src/spring/rts/Game/UI/SelectionKeyHandler.cpp
--- spring_89.0/rts/Game/UI/SelectionKeyHandler.cpp	2012-07-10 00:10:07.000000000 +0200
+++ /home/svenstaro/src/spring/rts/Game/UI/SelectionKeyHandler.cpp	2012-07-13 06:34:43.066060493 +0200
@@ -367,9 +367,9 @@
 				camera->rot.x=-1;
 
 			float3 wantedCamDir;
-			wantedCamDir.x=(float)(sin(camera->rot.y)*cos(camera->rot.x));
-			wantedCamDir.y=(float)(sin(camera->rot.x));
-			wantedCamDir.z=(float)(cos(camera->rot.y)*cos(camera->rot.x));
+			wantedCamDir.x=(float)(math::sin(camera->rot.y)*math::cos(camera->rot.x));
+			wantedCamDir.y=(float)(math::sin(camera->rot.x));
+			wantedCamDir.z=(float)(math::cos(camera->rot.y)*math::cos(camera->rot.x));
 			wantedCamDir.ANormalize();
 
 			camHandler->GetCurrentController().SetPos(sel->pos - wantedCamDir*800);
diff -ru spring_89.0/rts/Game/UI/UnitTracker.cpp /home/svenstaro/src/spring/rts/Game/UI/UnitTracker.cpp
--- spring_89.0/rts/Game/UI/UnitTracker.cpp	2012-07-10 00:10:07.000000000 +0200
+++ /home/svenstaro/src/spring/rts/Game/UI/UnitTracker.cpp	2012-07-13 06:34:43.066060493 +0200
@@ -297,8 +297,8 @@
   			modPlanePos.y = minHeight;
 		}
 
-		trackPos += (modPlanePos - trackPos) * (1 - pow(0.95f, deltaTime));
-		trackDir += (u->frontdir - trackDir) * (1 - pow(0.90f, deltaTime));
+		trackPos += (modPlanePos - trackPos) * (1 - math::pow(0.95f, deltaTime));
+		trackDir += (u->frontdir - trackDir) * (1 - math::pow(0.90f, deltaTime));
 		trackDir.ANormalize();
 
 		camera->pos = trackPos;
diff -ru spring_89.0/rts/lib/gml/gmlsrv.h /home/svenstaro/src/spring/rts/lib/gml/gmlsrv.h
--- spring_89.0/rts/lib/gml/gmlsrv.h	2012-07-10 00:10:09.000000000 +0200
+++ /home/svenstaro/src/spring/rts/lib/gml/gmlsrv.h	2012-07-13 06:34:43.209393834 +0200
@@ -361,7 +361,7 @@
 		if (gmlShareLists) {
 			ogc[thr]->WorkerThreadPost();
 		}
-		streflop_init<streflop::Simple>();
+		streflop::streflop_init<streflop::Simple>();
 		while(dorun) {
 			gmlClientSub();
 		}
@@ -452,7 +452,7 @@
 		Threading::SetThreadName("sim");
 		Watchdog::RegisterThread(WDT_SIM, true);
 		set_threadnum(GML_SIM_THREAD_NUM);
-		streflop_init<streflop::Simple>();
+		streflop::streflop_init<streflop::Simple>();
 		while(dorun) {
 			gmlClientAuxSub();
 		}
diff -ru spring_89.0/rts/lib/headlessStubs/sdlstub_cppbit.cpp /home/svenstaro/src/spring/rts/lib/headlessStubs/sdlstub_cppbit.cpp
--- spring_89.0/rts/lib/headlessStubs/sdlstub_cppbit.cpp	2012-07-10 00:10:09.000000000 +0200
+++ /home/svenstaro/src/spring/rts/lib/headlessStubs/sdlstub_cppbit.cpp	2012-07-13 06:35:00.626061514 +0200
@@ -12,10 +12,16 @@
 extern "C" {
 #endif
 
+#if (BOOST_VERSION >= 105000) //boost 1.50 renamed TIME_UTC to TIME_UTC_
+	#define SPRING_UTCTIME boost::TIME_UTC_
+#else
+	#define SPRING_UTCTIME boost::TIME_UTC
+#endif
+
 int stub_sdl_getSystemMilliSeconds() {
 
 	boost::xtime t;
-	boost::xtime_get(&t, boost::TIME_UTC);
+	boost::xtime_get(&t, SPRING_UTCTIME);
 	const int milliSeconds = t.sec * 1000 + (t.nsec / 1000000);   
 	return milliSeconds;
 }
@@ -23,7 +29,7 @@
 void stub_sdl_sleepMilliSeconds(int milliSeconds) {
 
 	boost::xtime t;
-	boost::xtime_get(&t, boost::TIME_UTC);
+	boost::xtime_get(&t, SPRING_UTCTIME);
 	t.nsec += 1000000 * milliSeconds;
 	boost::thread::sleep(t);
 }
diff -ru spring_89.0/rts/lib/streflop/streflopC.cpp /home/svenstaro/src/spring/rts/lib/streflop/streflopC.cpp
--- spring_89.0/rts/lib/streflop/streflopC.cpp	2012-07-10 00:10:10.000000000 +0200
+++ /home/svenstaro/src/spring/rts/lib/streflop/streflopC.cpp	2012-07-13 06:34:42.939393819 +0200
@@ -9,16 +9,16 @@
 #endif
 
 void streflop_init_Simple() {
-	streflop_init<Simple>();
+	streflop::streflop_init<streflop::Simple>();
 }
 
 void streflop_init_Double() {
-	streflop_init<Double>();
+	streflop::streflop_init<streflop::Double>();
 }
 
 #if defined(Extended)
 void streflop_init_Extended() {
-	streflop_init<Extended>();
+	streflop::streflop_init<streflop::Extended>();
 }
 #endif // defined(Extended)
 
diff -ru spring_89.0/rts/lib/streflop/streflop_cond.h /home/svenstaro/src/spring/rts/lib/streflop/streflop_cond.h
--- spring_89.0/rts/lib/streflop/streflop_cond.h	2012-07-10 00:10:10.000000000 +0200
+++ /home/svenstaro/src/spring/rts/lib/streflop/streflop_cond.h	2012-07-13 06:34:42.906060483 +0200
@@ -11,8 +11,6 @@
 
 #if defined(STREFLOP_X87) || defined(STREFLOP_SSE) || defined(STREFLOP_SOFT)
 #include "streflop.h"
-using namespace streflop;
-
 namespace math {
 	using namespace streflop;
 }
@@ -20,6 +18,7 @@
 #include <cmath>
 namespace math {
 	using std::fabs;
+	// We are using fastmath::sqrt_sse instead!
 	// using std::sqrt;
 	using std::sin;
 	using std::cos;
diff -ru spring_89.0/rts/Map/BasicMapDamage.cpp /home/svenstaro/src/spring/rts/Map/BasicMapDamage.cpp
--- spring_89.0/rts/Map/BasicMapDamage.cpp	2012-07-10 00:10:07.000000000 +0200
+++ /home/svenstaro/src/spring/rts/Map/BasicMapDamage.cpp	2012-07-13 06:34:43.066060493 +0200
@@ -33,7 +33,7 @@
 
 	for (int a = 0; a <= CRATER_TABLE_SIZE; ++a) {
 		const float r = a / float(CRATER_TABLE_SIZE);
-		const float d = cos((r - 0.1f) * (PI + 0.3f)) * (1 - r) * (0.5f + 0.5f * cos(std::max(0.0f, r * 3 - 2) * PI));
+		const float d = math::cos((r - 0.1f) * (PI + 0.3f)) * (1 - r) * (0.5f + 0.5f * math::cos(std::max(0.0f, r * 3 - 2) * PI));
 		craterTable[a] = d;
 	}
 
@@ -83,7 +83,7 @@
 	const float* curHeightMap = readmap->GetCornerHeightMapSynced();
 	const float* orgHeightMap = readmap->GetOriginalHeightMapSynced();
 	const unsigned char* typeMap = readmap->GetTypeMapSynced();
-	const float baseStrength = -pow(strength, 0.6f) * 3 / mapHardness;
+	const float baseStrength = -math::pow(strength, 0.6f) * 3 / mapHardness;
 	const float invRadius = 1.0f / radius;
 
 	for (int y = e->y1; y <= e->y2; ++y) {
@@ -111,7 +111,7 @@
 				orgHeightMap[y * gs->mapxp1 + x];
 
 			if (prevDif * dif > 0.0f) {
-				dif /= fabs(prevDif) * 0.1f + 1;
+				dif /= math::fabs(prevDif) * 0.1f + 1;
 			}
 
 			e->squares.push_back(dif);
@@ -148,7 +148,7 @@
 						orgHeightMap[z * gs->mapxp1 + x];
 
 				if (prevDif * dif > 0.0f) {
-					dif /= fabs(prevDif) * 0.1f + 1;
+					dif /= math::fabs(prevDif) * 0.1f + 1;
 				}
 
 				totalDif += dif;
diff -ru spring_89.0/rts/Map/Ground.cpp /home/svenstaro/src/spring/rts/Map/Ground.cpp
--- spring_89.0/rts/Map/Ground.cpp	2012-07-10 00:10:07.000000000 +0200
+++ /home/svenstaro/src/spring/rts/Map/Ground.cpp	2012-07-13 06:34:43.086060494 +0200
@@ -433,8 +433,8 @@
 
 float3 CGround::GetSmoothNormal(float x, float y, bool synced) const
 {
-	int sx = (int) floor(x / SQUARE_SIZE);
-	int sy = (int) floor(y / SQUARE_SIZE);
+	int sx = (int) math::floor(x / SQUARE_SIZE);
+	int sy = (int) math::floor(y / SQUARE_SIZE);
 
 	if (sy < 1)
 		sy = 1;
diff -ru spring_89.0/rts/Map/SM3/Plane.cpp /home/svenstaro/src/spring/rts/Map/SM3/Plane.cpp
--- spring_89.0/rts/Map/SM3/Plane.cpp	2012-07-10 00:10:07.000000000 +0200
+++ /home/svenstaro/src/spring/rts/Map/SM3/Plane.cpp	2012-07-13 06:34:43.066060493 +0200
@@ -15,7 +15,7 @@
 	a = ry1*rz2 - ry2*rz1;
 	b = rz1*rx2 - rz2*rx1;
 	c = rx1*ry2 - rx2*ry1;
-	float len = (float)sqrt(a*a + b*b + c*c);
+	float len = (float)math::sqrt(a*a + b*b + c*c);
 	a /= len;
 	b /= len;
 	c /= len;
@@ -37,10 +37,10 @@
 bool Plane::EpsilonCompare(const Plane& pln, float epsilon)
 {
 	Plane t;
-	t.a = fabs(a - pln.a);
-	t.b = fabs(b - pln.b);
-	t.c = fabs(c - pln.c);
-	t.d = fabs(d - pln.d);
+	t.a = math::fabs(a - pln.a);
+	t.b = math::fabs(b - pln.b);
+	t.c = math::fabs(c - pln.c);
+	t.d = math::fabs(d - pln.d);
 	if (t.a > epsilon || t.b > epsilon || t.c > epsilon || t.d > epsilon) {
 		return false;
 	}
diff -ru spring_89.0/rts/Map/SM3/terrain/Lightcalc.cpp /home/svenstaro/src/spring/rts/Map/SM3/terrain/Lightcalc.cpp
--- spring_89.0/rts/Map/SM3/terrain/Lightcalc.cpp	2012-07-10 00:10:07.000000000 +0200
+++ /home/svenstaro/src/spring/rts/Map/SM3/terrain/Lightcalc.cpp	2012-07-13 06:34:43.069393827 +0200
@@ -197,7 +197,7 @@
 					continue;
 			}
 
-			float len = sqrt(dx*dx + dy*dy);
+			float len = math::sqrt(dx*dx + dy*dy);
 			const float step = 5.0f;
 			float invLength2d = step / len;
 			dx *= invLength2d;
diff -ru spring_89.0/rts/Map/SM3/terrain/Textures.cpp /home/svenstaro/src/spring/rts/Map/SM3/terrain/Textures.cpp
--- spring_89.0/rts/Map/SM3/terrain/Textures.cpp	2012-07-10 00:10:07.000000000 +0200
+++ /home/svenstaro/src/spring/rts/Map/SM3/terrain/Textures.cpp	2012-07-13 06:34:43.069393827 +0200
@@ -248,7 +248,7 @@
 				}
 
 				// flatness=dotproduct of surface normal with up vector
-				float slope = 1.0f - fabs(norm_y);
+				float slope = 1.0f - math::fabs(norm_y);
 
 				if (slope < gi->minSlope - gi->minSlopeFuzzy) {
 					bm->at(x,y) = 0.0f;
@@ -307,7 +307,7 @@
 				Vector3 n;
 
 				if (sx*sx + sy*sy < 32*32) {
-					const int sz = (int)sqrt(static_cast<float>(32 * 32 - sx*sx - sy*sy));
+					const int sz = (int)math::sqrt(static_cast<float>(32 * 32 - sx*sx - sy*sy));
 					n = Vector3(sx, sy, sz);
 					n.ANormalize();
 				}
diff -ru spring_89.0/rts/Map/SMF/Legacy/LegacyMeshDrawer.cpp /home/svenstaro/src/spring/rts/Map/SMF/Legacy/LegacyMeshDrawer.cpp
--- spring_89.0/rts/Map/SMF/Legacy/LegacyMeshDrawer.cpp	2012-07-10 00:10:07.000000000 +0200
+++ /home/svenstaro/src/spring/rts/Map/SMF/Legacy/LegacyMeshDrawer.cpp	2012-07-13 06:34:43.069393827 +0200
@@ -99,7 +99,7 @@
 	const int minz =  bty * smfReadMap->bigTexSize;
 	const int maxz = minz + smfReadMap->bigTexSize;
 	const float miny = readmap->currMinHeight;
-	const float maxy = fabs(cam->pos.y);
+	const float maxy = math::fabs(cam->pos.y);
 
 	const float3 mins(                   0, miny, minz);
 	const float3 maxs(smfReadMap->mapSizeX, maxy, maxz);
diff -ru spring_89.0/rts/Map/SMF/ROAM/Patch.cpp /home/svenstaro/src/spring/rts/Map/SMF/ROAM/Patch.cpp
--- spring_89.0/rts/Map/SMF/ROAM/Patch.cpp	2012-07-10 00:10:07.000000000 +0200
+++ /home/svenstaro/src/spring/rts/Map/SMF/ROAM/Patch.cpp	2012-07-13 06:34:43.069393827 +0200
@@ -405,7 +405,7 @@
 
 	// Variance of this triangle is the actual height at it's hypotenuse midpoint minus the interpolated height.
 	// Use values passed on the stack instead of re-accessing the Height Field.
-	float myVariance = fabs(centerZ - ((leftZ + rightZ) / 2));
+	float myVariance = math::fabs(centerZ - ((leftZ + rightZ) / 2));
 	
 	if (leftZ*rightZ<0 || leftZ*centerZ<0 || rightZ*centerZ<0)
 		myVariance = std::max(myVariance * 1.5f, 20.0f); //shore lines get more variance for higher accuracy
diff -ru spring_89.0/rts/Map/SMF/SMFRenderState.cpp /home/svenstaro/src/spring/rts/Map/SMF/SMFRenderState.cpp
--- spring_89.0/rts/Map/SMF/SMFRenderState.cpp	2012-07-10 00:10:07.000000000 +0200
+++ /home/svenstaro/src/spring/rts/Map/SMF/SMFRenderState.cpp	2012-07-13 06:34:43.069393827 +0200
@@ -385,7 +385,7 @@
 	smfShaderCurrARB->SetUniformTarget(GL_VERTEX_PROGRAM_ARB);
 	smfShaderCurrARB->SetUniform4f(10, 1.0f / (gs->pwr2mapx * SQUARE_SIZE), 1.0f / (gs->pwr2mapy * SQUARE_SIZE), 0, 1);
 	smfShaderCurrARB->SetUniform4f(12, 1.0f / smfMap->bigTexSize, 1.0f / smfMap->bigTexSize, 0, 1);
-	smfShaderCurrARB->SetUniform4f(13, -floor(camera->pos.x * 0.02f), -floor(camera->pos.z * 0.02f), 0, 0);
+	smfShaderCurrARB->SetUniform4f(13, -math::floor(camera->pos.x * 0.02f), -math::floor(camera->pos.z * 0.02f), 0, 0);
 	smfShaderCurrARB->SetUniform4f(14, 0.02f, 0.02f, 0, 1);
 	smfShaderCurrARB->SetUniformTarget(GL_FRAGMENT_PROGRAM_ARB);
 	smfShaderCurrARB->SetUniform4f(10, ambientColor.x, ambientColor.y, ambientColor.z, 1);
diff -ru spring_89.0/rts/Rendering/Env/AdvSky.cpp /home/svenstaro/src/spring/rts/Rendering/Env/AdvSky.cpp
--- spring_89.0/rts/Rendering/Env/AdvSky.cpp	2012-07-10 00:10:07.000000000 +0200
+++ /home/svenstaro/src/spring/rts/Rendering/Env/AdvSky.cpp	2012-07-13 06:34:43.069393827 +0200
@@ -65,8 +65,8 @@
 	memset(thicknessTransform, 0, 1024);
 	memset(covers, 0, 4 * 32 * sizeof(float));
 
-	domeheight = cos(PI / 16) * 1.01f;
-	domeWidth = sin(2 * PI / 32) * 400 * 1.7f;
+	domeheight = math::cos(PI / 16) * 1.01f;
+	domeWidth = math::sin(2 * PI / 32) * 400 * 1.7f;
 
 	UpdateSkyDir();
 	InitSun();
@@ -383,7 +383,7 @@
 	case 0: {
 		for(int a=0; a<CLOUD_DETAIL; a++) {
 			float fade = gs->frameNum / (70.0f * (2<<(CLOUD_DETAIL-1-a)));
-			fade -= floor(fade/2)*2;
+			fade -= math::floor(fade/2)*2;
 			if(fade>1) {
 				fade = 2 - fade;
 				if(!cloudDown[a]) {
@@ -417,11 +417,11 @@
 		int qcda=(4<<CLOUD_DETAIL)>>a;
 		int *pkernel=kernel;
 		for(int y=0; y<cs4a; ++y, pkernel+=CLOUD_SIZE/4) {
-			float ydist=fabs(1.0f+y-cs8a)/cs8a;
+			float ydist=math::fabs(1.0f+y-cs8a)/cs8a;
 			ydist=ydist*ydist*(3-2*ydist);
 			int *pkrn=pkernel;
 			for(int x=0; x<cs4a; ++x) {
-				float xdist=fabs(1.0f+x-cs8a)/cs8a;
+				float xdist=math::fabs(1.0f+x-cs8a)/cs8a;
 				xdist=xdist*xdist*(3-2*xdist);
 
 				float contrib=(1-xdist)*(1-ydist);
@@ -533,7 +533,7 @@
 	unsigned char *tt=thicknessTransform;
 	for(int a=0;a<1024;++a){
 		float f=(1023.0f-(a+cloudDensity*1024-512))/1023.0f;
-		float alpha=pow(f*2,3);
+		float alpha=math::pow(f*2,3);
 		if(alpha>1)
 			alpha=1;
 		*at=(int) (alpha*255);
@@ -560,11 +560,11 @@
 
 	float ymod=(sunTexCoordY-0.5f)*domeWidth*0.025f*256;
 	float fy=ymod+modCamera.z*CLOUD_SIZE*0.000025f;
-	int baseY=int(floor(fy))&CLOUD_MASK;
-	fy-=floor(fy);
+	int baseY=int(math::floor(fy))&CLOUD_MASK;
+	fy-=math::floor(fy);
 	float fx=gs->frameNum*0.00005f*CLOUD_SIZE+modCamera.x*CLOUD_SIZE*0.000025f;
-	int baseX=int(floor(fx))&CLOUD_MASK;
-	fx-=floor(fx);
+	int baseX=int(math::floor(fx))&CLOUD_MASK;
+	fx-=math::floor(fx);
 
 	float *cvs=(float *)covers[0], *cvs1=(float *)covers[1], *cvs2=(float *)covers[2], *cvs3=(float *)covers[3];
 	if(baseX!=oldCoverBaseX || baseY!=oldCoverBaseY){
@@ -622,8 +622,8 @@
 	glBlendFunc(GL_ONE_MINUS_DST_COLOR,GL_ONE);
 	glBegin(GL_TRIANGLE_STRIP);
 	for(int x=0;x<257;++x){
-		float dx = sin(x*2*PI/256.0f);
-		float dy = cos(x*2*PI/256.0f);
+		float dx = math::sin(x*2*PI/256.0f);
+		float dy = math::cos(x*2*PI/256.0f);
 
 		glTexCoord2f(x/256.0f,0.125f);
 		glVertexf3(modSunDir*5+ldir*dx*0.0014f+udir*dy*0.0014f);
@@ -646,7 +646,7 @@
 			mem[(y*128+x)*4+0]=255;
 			mem[(y*128+x)*4+1]=255;
 			mem[(y*128+x)*4+2]=255;
-			float dist=sqrt((float)(y-64)*(y-64)+(x-64)*(x-64));
+			float dist=math::sqrt((float)(y-64)*(y-64)+(x-64)*(x-64));
 			if(dist>60)
 				mem[(y*128+x)*4+3]=0;
 			else
@@ -749,7 +749,7 @@
 
 	for(int a=0;a<5;++a){
 		float fade = gs->frameNum / float(30<<a);
-		fade -= floor(fade/2)*2;
+		fade -= math::floor(fade/2)*2;
 		int size = std::min(32,256>>a);
 
 		if(fade>1){
@@ -770,7 +770,7 @@
 
 		}
 		float tSize = std::max(1,8>>a);
-		float c = pow(2.0f,a)*6/255.0f;
+		float c = math::pow(2.0f,a)*6/255.0f;
 		CVertexArray* va = GetVertexArray();
 		va->Initialize();
 		va->CheckInitSize(4*VA_SIZE_T);
@@ -867,10 +867,10 @@
 
 	const float hdist = math::sqrt(dir.x * dir.x + dir.z * dir.z);
 	const float ang = GetRadFromXY(dir.x, dir.z) + skyAngle;
-	const float fy = asin(hdist / 400);
+	const float fy = math::asin(hdist / 400);
 
-	dir.x = hdist * cos(ang);
-	dir.z = hdist * sin(ang);
+	dir.x = hdist * math::cos(ang);
+	dir.z = hdist * math::sin(ang);
 	dir.y = (fastmath::cos(fy) - domeheight) * 400;
 
 	dir.ANormalize();
@@ -903,7 +903,7 @@
 	const float3& dir = GetDirFromTexCoord(x / 256.0f, (255.0f - y) / 256.0f);
 
 	const float sunInt = skyLight->GetLightIntensity();
-	const float sunDist = acos(dir.dot(skyLight->GetLightDir())) * 50;
+	const float sunDist = math::acos(dir.dot(skyLight->GetLightDir())) * 50;
 	const float sunMod = sunInt * (0.3f / math::sqrt(sunDist) + 3.0f / (1 + sunDist));
 
 	const float green = std::min(1.0f, (0.55f + sunMod));
@@ -918,7 +918,7 @@
 void CAdvSky::UpdateTexPart(int x, int y, unsigned char (*texp)[4]) {
 	const float3& dir = GetDirFromTexCoord(x / 512.0f, (511.0f - y) / 512.0f);
 
-	const float sunDist = acos(dir.dot(skyLight->GetLightDir())) * 70;
+	const float sunDist = math::acos(dir.dot(skyLight->GetLightDir())) * 70;
 	const float sunMod = skyLight->GetLightIntensity() * 12.0f / (12 + sunDist);
 
 	const float red   = std::min(skyColor.x + sunMod * sunColor.x, 1.0f);
diff -ru spring_89.0/rts/Rendering/Env/AdvTreeDrawer.cpp /home/svenstaro/src/spring/rts/Rendering/Env/AdvTreeDrawer.cpp
--- spring_89.0/rts/Rendering/Env/AdvTreeDrawer.cpp	2012-07-10 00:10:07.000000000 +0200
+++ /home/svenstaro/src/spring/rts/Rendering/Env/AdvTreeDrawer.cpp	2012-07-13 06:34:43.069393827 +0200
@@ -229,7 +229,7 @@
 			std::list<FallingTree>::iterator prev = fti++;
 			fallingTrees.erase(prev);
 		} else {
-			fti->speed += (sin(fti->fallPos) * 0.04f);
+			fti->speed += (math::sin(fti->fallPos) * 0.04f);
 			++fti;
 		}
 	}
@@ -616,7 +616,7 @@
 			if (camera->InView(pos + float3(0.0f, MAX_TREE_HEIGHT / 2, 0.0f), MAX_TREE_HEIGHT / 2.0f)) {
 				const float ang = fti->fallPos * PI;
 
-				const float3 yvec(fti->dir.x * sin(ang), cos(ang), fti->dir.z * sin(ang));
+				const float3 yvec(fti->dir.x * math::sin(ang), math::cos(ang), fti->dir.z * math::sin(ang));
 				const float3 zvec((yvec.cross(float3(-1.0f, 0.0f, 0.0f))).ANormalize());
 				const float3 xvec(yvec.cross(zvec));
 
@@ -957,7 +957,7 @@
 			if (camera->InView(pos + float3(0, MAX_TREE_HEIGHT / 2, 0), MAX_TREE_HEIGHT / 2)) {
 				const float ang = fti->fallPos * PI;
 
-				const float3 yvec(fti->dir.x * sin(ang), cos(ang), fti->dir.z * sin(ang));
+				const float3 yvec(fti->dir.x * math::sin(ang), math::cos(ang), fti->dir.z * math::sin(ang));
 				const float3 zvec((yvec.cross(float3(1.0f, 0.0f, 0.0f))).ANormalize());
 				const float3 xvec(zvec.cross(yvec));
 
diff -ru spring_89.0/rts/Rendering/Env/AdvTreeGenerator.cpp /home/svenstaro/src/spring/rts/Rendering/Env/AdvTreeGenerator.cpp
--- spring_89.0/rts/Rendering/Env/AdvTreeGenerator.cpp	2012-07-10 00:10:07.000000000 +0200
+++ /home/svenstaro/src/spring/rts/Rendering/Env/AdvTreeGenerator.cpp	2012-07-13 06:34:43.069393827 +0200
@@ -159,9 +159,9 @@
 	int numIter=(int)max(3.0f,size*10);
 	for(int a=0;a<=numIter;a++){
 		float angle=a/(float)numIter*2*PI;
-		float col=0.4f+(((orto1*sin(angle)+orto2*cos(angle)).dot(flatSun)))*0.3f;
-		barkva->AddVertexTN(start+orto1*sin(angle)*size+orto2*cos(angle)*size,angle/PI*0.125f*0.5f,0,float3(0,0,col));
-		barkva->AddVertexTN(end+orto1*sin(angle)*size*0.2f+orto2*cos(angle)*size*0.2f,angle/PI*0.125f*0.5f,3,float3(0,0,col));
+		float col=0.4f+(((orto1*math::sin(angle)+orto2*math::cos(angle)).dot(flatSun)))*0.3f;
+		barkva->AddVertexTN(start+orto1*math::sin(angle)*size+orto2*math::cos(angle)*size,angle/PI*0.125f*0.5f,0,float3(0,0,col));
+		barkva->AddVertexTN(end+orto1*math::sin(angle)*size*0.2f+orto2*math::cos(angle)*size*0.2f,angle/PI*0.125f*0.5f,3,float3(0,0,col));
 	}
 	barkva->EndStrip();
 }
@@ -176,18 +176,18 @@
 
 	for (int a = 0; a < numBranch; ++a) {
 		const float angle = baseAngle + (a * 3.88f) + fRand(0.5f);
-		float3 dir = orto1 * sin(angle) + orto2 * cos(angle);
+		float3 dir = orto1 * math::sin(angle) + orto2 * math::cos(angle);
 			dir.y = 0.3f + fRand(0.4f);
 			dir.ANormalize();
 		const float3 start(0, (a + 5) * height / (numBranch + 5), 0);
-		const float length = (height * (0.4f + fRand(0.1f))) * sqrt(float(numBranch - a) / numBranch);
+		const float length = (height * (0.4f + fRand(0.1f))) * math::sqrt(float(numBranch - a) / numBranch);
 
 		TrunkIterator(start, dir, length, length * 0.05f, 1);
 	}
 
 	for (int a = 0; a < 3; ++a) {
 		const float angle = (a * 3.88f) + fRand(0.5f);
-		float3 dir = orto1*sin(angle)+orto2*cos(angle);
+		float3 dir = orto1*math::sin(angle)+orto2*math::cos(angle);
 			dir.y = 0.8f;
 			dir.ANormalize();
 		const float3 start(0, height - 0.3f, 0);
@@ -225,7 +225,7 @@
 		const float newLength = length * (float(numTrunks - a) / (numTrunks + 1));
 
 		float3 newbase = start + dir * length * (float(a + 1) / (numTrunks + 1));
-		float3 newDir = dir + orto1 * cos(angle) * dirDif + orto2 * sin(angle) * dirDif;
+		float3 newDir = dir + orto1 * math::cos(angle) * dirDif + orto2 * math::sin(angle) * dirDif;
 		newDir.ANormalize();
 
 		TrunkIterator(newbase, newDir, newLength, newLength * 0.05f, depth - 1);
@@ -245,8 +245,8 @@
 
 		float3 pos = start + dir * length * (0.7f + fRand(0.3f));
 		pos +=
-			(orto1 * sin(angle) + orto2 * cos(angle)) *
-			(sqrt((float) a + 1) * 0.6f + fRand(0.4f)) *
+			(orto1 * math::sin(angle) + orto2 * math::cos(angle)) *
+			(math::sqrt((float) a + 1) * 0.6f + fRand(0.4f)) *
 			0.1f * MAX_TREE_HEIGHT;
 
 		if (pos.y < 0.2f * MAX_TREE_HEIGHT)
@@ -538,12 +538,12 @@
 	float baseAngle=fRand(2*PI);
 	for(int a=0;a<numBranch;++a){
 		float sh = 0.2f + fRand(0.2f);
-		float h  = height * pow(sh + float(a)/numBranch * (1-sh), (float)0.7f);
+		float h  = height * math::pow(sh + float(a)/numBranch * (1-sh), (float)0.7f);
 		float angle = baseAngle + (a * 0.618f + fRand(0.1f)) * 2 * PI;
-		float3 dir(orto1 * sin(angle) + orto2 * cos(angle));
+		float3 dir(orto1 * math::sin(angle) + orto2 * math::cos(angle));
 		dir.y = (a - numBranch) * 0.01f - (0.2f + fRand(0.2f));
 		dir.ANormalize();
-		float size = sqrt((float)numBranch - a + 5) * 0.08f * MAX_TREE_HEIGHT;
+		float size = math::sqrt((float)numBranch - a + 5) * 0.08f * MAX_TREE_HEIGHT;
 		DrawPineBranch(float3(0,h,0),dir,size);
 	}
 	//create the top
@@ -569,16 +569,16 @@
 	for(int a=0;a<numIter;a++){
 		float angle=a/(float)numIter*2*PI;
 		float angle2=(a+1)/(float)numIter*2*PI;
-		float col=0.45f+(((orto1*sin(angle)+orto2*cos(angle)).dot(flatSun)))*0.3f;
-		float col2=0.45f+(((orto1*sin(angle2)+orto2*cos(angle2)).dot(flatSun)))*0.3f;
+		float col=0.45f+(((orto1*math::sin(angle)+orto2*math::cos(angle)).dot(flatSun)))*0.3f;
+		float col2=0.45f+(((orto1*math::sin(angle2)+orto2*math::cos(angle2)).dot(flatSun)))*0.3f;
 
-		va->AddVertexTN(start+orto1*sin(angle)*size+orto2*cos(angle)*size,           angle/PI*0.125f*0.5f+0.5f,  0, float3(0,0,col));
-		va->AddVertexTN(end+orto1*sin(angle)*size*0.1f+orto2*cos(angle)*size*0.1f,   angle/PI*0.125f*0.5f+0.5f,  3, float3(0,0,col));
-		va->AddVertexTN(start+orto1*sin(angle2)*size+orto2*cos(angle2)*size,         angle2/PI*0.125f*0.5f+0.5f, 0, float3(0,0,col2));
-
-		va->AddVertexTN(start+orto1*sin(angle2)*size+orto2*cos(angle2)*size,         angle2/PI*0.125f*0.5f+0.5f, 0, float3(0,0,col2));
-		va->AddVertexTN(end+orto1*sin(angle)*size*0.1f+orto2*cos(angle)*size*0.1f,   angle/PI*0.125f*0.5f+0.5f,  3, float3(0,0,col));
-		va->AddVertexTN(end+orto1*sin(angle2)*size*0.1f+orto2*cos(angle2)*size*0.1f, angle2/PI*0.125f*0.5f+0.5f, 3, float3(0,0,col2));
+		va->AddVertexTN(start+orto1*math::sin(angle)*size+orto2*math::cos(angle)*size,           angle/PI*0.125f*0.5f+0.5f,  0, float3(0,0,col));
+		va->AddVertexTN(end+orto1*math::sin(angle)*size*0.1f+orto2*math::cos(angle)*size*0.1f,   angle/PI*0.125f*0.5f+0.5f,  3, float3(0,0,col));
+		va->AddVertexTN(start+orto1*math::sin(angle2)*size+orto2*math::cos(angle2)*size,         angle2/PI*0.125f*0.5f+0.5f, 0, float3(0,0,col2));
+
+		va->AddVertexTN(start+orto1*math::sin(angle2)*size+orto2*math::cos(angle2)*size,         angle2/PI*0.125f*0.5f+0.5f, 0, float3(0,0,col2));
+		va->AddVertexTN(end+orto1*math::sin(angle)*size*0.1f+orto2*math::cos(angle)*size*0.1f,   angle/PI*0.125f*0.5f+0.5f,  3, float3(0,0,col));
+		va->AddVertexTN(end+orto1*math::sin(angle2)*size*0.1f+orto2*math::cos(angle2)*size*0.1f, angle2/PI*0.125f*0.5f+0.5f, 3, float3(0,0,col2));
 	}
 }
 
diff -ru spring_89.0/rts/Rendering/Env/AdvWater.cpp /home/svenstaro/src/spring/rts/Rendering/Env/AdvWater.cpp
--- spring_89.0/rts/Rendering/Env/AdvWater.cpp	2012-07-10 00:10:07.000000000 +0200
+++ /home/svenstaro/src/spring/rts/Rendering/Env/AdvWater.cpp	2012-07-13 06:34:43.069393827 +0200
@@ -48,7 +48,7 @@
 	for (int y = 0; y < 64; ++y) {
 		for (int x = 0; x < 64; ++x) {
 			scrap[(y*64 + x)*4 + 0] = 128;
-			scrap[(y*64 + x)*4 + 1] = (unsigned char)(sin(y*PI*2.0f/64.0f)*128 + 128);
+			scrap[(y*64 + x)*4 + 1] = (unsigned char)(math::sin(y*PI*2.0f/64.0f)*128 + 128);
 			scrap[(y*64 + x)*4 + 2] = 0;
 			scrap[(y*64 + x)*4 + 3] = 255;
 		}
@@ -62,8 +62,8 @@
 		for (int x = 0; x < 64; ++x) {
 			const float ang = 26.5f*PI/180.0f;
 			const float pos = y*2+x;
-			scrap[(y*64 + x)*4 + 0] = (unsigned char)((sin(pos*PI*2.0f/64.0f))*128*sin(ang)) + 128;
-			scrap[(y*64 + x)*4 + 1] = (unsigned char)((sin(pos*PI*2.0f/64.0f))*128*cos(ang)) + 128;
+			scrap[(y*64 + x)*4 + 0] = (unsigned char)((math::sin(pos*PI*2.0f/64.0f))*128*math::sin(ang)) + 128;
+			scrap[(y*64 + x)*4 + 1] = (unsigned char)((math::sin(pos*PI*2.0f/64.0f))*128*math::cos(ang)) + 128;
 		}
 	}
 	glBindTexture(GL_TEXTURE_2D, rawBumpTexture[1]);
@@ -75,8 +75,8 @@
 		for (int x = 0; x < 64; ++x) {
 			const float ang = -19*PI/180.0f;
 			const float pos = 3*y - x;
-			scrap[(y*64 + x)*4 + 0] = (unsigned char)((sin(pos*PI*2.0f/64.0f))*128*sin(ang)) + 128;
-			scrap[(y*64 + x)*4 + 1] = (unsigned char)((sin(pos*PI*2.0f/64.0f))*128*cos(ang)) + 128;
+			scrap[(y*64 + x)*4 + 0] = (unsigned char)((math::sin(pos*PI*2.0f/64.0f))*128*math::sin(ang)) + 128;
+			scrap[(y*64 + x)*4 + 1] = (unsigned char)((math::sin(pos*PI*2.0f/64.0f))*128*math::cos(ang)) + 128;
 		}
 	}
 	glBindTexture(GL_TEXTURE_2D, rawBumpTexture[2]);
@@ -192,14 +192,14 @@
 				dir = xbase + dv;
 				dir.ANormalize();
 				zpos = camera->pos + dir*(camera->pos.y / -dir.y);
-				zpos.y = sin(zpos.z*0.1f + gs->frameNum*0.06f)*0.06f + 0.05f;
+				zpos.y = math::sin(zpos.z*0.1f + gs->frameNum*0.06f)*0.06f + 0.05f;
 				col[3] = (unsigned char)((0.8f + 0.7f*dir.y)*255);
 				va->AddVertexQTC(zpos, x*(1.0f/numDivs), screenY - yInc, col);
 
 				dir = xbase;
 				dir.ANormalize();
 				zpos = camera->pos + dir*(camera->pos.y / -dir.y);
-				zpos.y = sin(zpos.z*0.1f + gs->frameNum*0.06f)*0.06f + 0.05f;
+				zpos.y = math::sin(zpos.z*0.1f + gs->frameNum*0.06f)*0.06f + 0.05f;
 				col[3] = (unsigned char)((0.8f + 0.7f*dir.y)*255);
 				va->AddVertexQTC(zpos, x*(1.0f/numDivs), screenY, col);
 
diff -ru spring_89.0/rts/Rendering/Env/BasicSky.cpp /home/svenstaro/src/spring/rts/Rendering/Env/BasicSky.cpp
--- spring_89.0/rts/Rendering/Env/BasicSky.cpp	2012-07-10 00:10:07.000000000 +0200
+++ /home/svenstaro/src/spring/rts/Rendering/Env/BasicSky.cpp	2012-07-13 06:34:43.069393827 +0200
@@ -67,8 +67,8 @@
 	rawClouds=newmat2<int>(CLOUD_SIZE,CLOUD_SIZE);
 	blendMatrix=newmat3<int>(CLOUD_DETAIL,32,32);
 
-	domeheight=cos(PI/16)*1.01f;
-	domeWidth=sin(PI/16)*400*1.7f;
+	domeheight=math::cos(PI/16)*1.01f;
+	domeWidth=math::sin(PI/16)*400*1.7f;
 
 	UpdateSkyDir();
 	InitSun();
@@ -369,7 +369,7 @@
 	case 0: {
 		for(int a=0; a<CLOUD_DETAIL; a++) {
 			float fade = gs->frameNum / (70.0f * (2<<(CLOUD_DETAIL-1-a)));
-			fade -= floor(fade/2)*2;
+			fade -= math::floor(fade/2)*2;
 			if(fade>1) {
 				fade = 2 - fade;
 				if(!cloudDown[a]) {
@@ -403,11 +403,11 @@
 		int qcda=(4<<CLOUD_DETAIL)>>a;
 		int *pkernel=kernel;
 		for(int y=0; y<cs4a; ++y, pkernel+=CLOUD_SIZE/4) {
-			float ydist=fabs(1.0f+y-cs8a)/cs8a;
+			float ydist=math::fabs(1.0f+y-cs8a)/cs8a;
 			ydist=ydist*ydist*(3-2*ydist);
 			int *pkrn=pkernel;
 			for(int x=0; x<cs4a; ++x) {
-				float xdist=fabs(1.0f+x-cs8a)/cs8a;
+				float xdist=math::fabs(1.0f+x-cs8a)/cs8a;
 				xdist=xdist*xdist*(3-2*xdist);
 
 				float contrib=(1-xdist)*(1-ydist);
@@ -506,7 +506,7 @@
 	unsigned char *tt=thicknessTransform;
 	for(int a=0;a<1024;++a){
 		float f=(1023.0f-(a+cloudDensity*1024-512))/1023.0f;
-		float alpha=pow(f*2,3);
+		float alpha=math::pow(f*2,3);
 		if(alpha>1)
 			alpha=1;
 		*at=(unsigned char)(alpha*255);
@@ -533,11 +533,11 @@
 
 	float ymod=(sunTexCoordY-0.5f)*domeWidth*0.025f*256;
 	float fy=ymod+modCamera.z*CLOUD_SIZE*0.000025f;
-	int baseY=int(floor(fy))&CLOUD_MASK;
-	fy-=floor(fy);
+	int baseY=int(math::floor(fy))&CLOUD_MASK;
+	fy-=math::floor(fy);
 	float fx=gs->frameNum*0.00005f*CLOUD_SIZE+modCamera.x*CLOUD_SIZE*0.000025f;
-	int baseX=int(floor(fx))&CLOUD_MASK;
-	fx-=floor(fx);
+	int baseX=int(math::floor(fx))&CLOUD_MASK;
+	fx-=math::floor(fx);
 
 	float *cvs=(float *)covers[0], *cvs1=(float *)covers[1], *cvs2=(float *)covers[2], *cvs3=(float *)covers[3];
 	if(baseX!=oldCoverBaseX || baseY!=oldCoverBaseY){
@@ -589,8 +589,8 @@
 		glBlendFunc(GL_ONE_MINUS_DST_COLOR,GL_ONE);
 		glBegin(GL_TRIANGLE_STRIP);
 		for(int x=0;x<257;++x){
-			float dx=sin(x*2*PI/256.0f);
-			float dy=cos(x*2*PI/256.0f);
+			float dx=math::sin(x*2*PI/256.0f);
+			float dy=math::cos(x*2*PI/256.0f);
 
 			glTexCoord2f(x/256.0f,0.25f);
 			glVertexf3(modSunDir*5+ldir*dx*0.0014f+udir*dy*0.0014f);
@@ -613,7 +613,7 @@
 			mem[(y*128+x)*4+0]=255;
 			mem[(y*128+x)*4+1]=255;
 			mem[(y*128+x)*4+2]=255;
-			float dist=sqrt((float)(y-64)*(y-64)+(x-64)*(x-64));
+			float dist=math::sqrt((float)(y-64)*(y-64)+(x-64)*(x-64));
 			if(dist>60)
 				mem[(y*128+x)*4+3]=0;
 			else
@@ -764,10 +764,10 @@
 
 	const float hdist = math::sqrt(dir.x * dir.x + dir.z * dir.z);
 	const float ang = GetRadFromXY(dir.x, dir.z) + skyAngle;
-	const float fy = asin(hdist / 400);
+	const float fy = math::asin(hdist / 400);
 
-	dir.x = hdist * cos(ang);
-	dir.z = hdist * sin(ang);
+	dir.x = hdist * math::cos(ang);
+	dir.z = hdist * math::sin(ang);
 	dir.y = (fastmath::cos(fy) - domeheight) * 400;
 
 	dir.ANormalize();
@@ -800,7 +800,7 @@
 	const float3& dir = GetDirFromTexCoord(x / 256.0f, (255.0f - y) / 256.0f);
 
 	const float sunInt = skyLight->GetLightIntensity();
-	const float sunDist = acos(dir.dot(skyLight->GetLightDir())) * 50;
+	const float sunDist = math::acos(dir.dot(skyLight->GetLightDir())) * 50;
 	const float sunMod = sunInt * (0.3f / math::sqrt(sunDist) + 2.0f / sunDist);
 
 	const float green = std::min(1.0f, (0.55f + sunMod));
@@ -814,7 +814,7 @@
 void CBasicSky::UpdateTexPart(int x, int y, unsigned char (*texp)[4]) {
 	const float3& dir = GetDirFromTexCoord(x / 512.0f, (511.0f - y) / 512.0f);
 
-	const float sunDist = acos(dir.dot(skyLight->GetLightDir())) * 70;
+	const float sunDist = math::acos(dir.dot(skyLight->GetLightDir())) * 70;
 	const float sunMod = skyLight->GetLightIntensity() * 12.0f / (12 + sunDist);
 
 	const float red   = std::min(skyColor.x + sunMod * sunColor.x, 1.0f);
diff -ru spring_89.0/rts/Rendering/Env/CubeMapHandler.cpp /home/svenstaro/src/spring/rts/Rendering/Env/CubeMapHandler.cpp
--- spring_89.0/rts/Rendering/Env/CubeMapHandler.cpp	2012-07-10 00:10:07.000000000 +0200
+++ /home/svenstaro/src/spring/rts/Rendering/Env/CubeMapHandler.cpp	2012-07-13 06:34:43.069393827 +0200
@@ -269,7 +269,7 @@
 	for (int x = 0; x < size; ++x) {
 		const float3 dir = (cdir + (xdif * (x + 0.5f)) / size + (ydif * (y + 0.5f)) / size).Normalize();
 		const float dot  = std::max(0.0f, dir.dot(sky->GetLight()->GetLightDir()));
-		const float spec = std::min(1.0f, pow(dot, mapInfo->light.specularExponent) + pow(dot, 3.0f) * 0.25f);
+		const float spec = std::min(1.0f, math::pow(dot, mapInfo->light.specularExponent) + math::pow(dot, 3.0f) * 0.25f);
 
 		buf[x * 4 + 0] = (mapInfo->light.unitSpecularColor.x * spec * 255);
 		buf[x * 4 + 1] = (mapInfo->light.unitSpecularColor.y * spec * 255);
diff -ru spring_89.0/rts/Rendering/Env/DynWater.cpp /home/svenstaro/src/spring/rts/Rendering/Env/DynWater.cpp
--- spring_89.0/rts/Rendering/Env/DynWater.cpp	2012-07-10 00:10:07.000000000 +0200
+++ /home/svenstaro/src/spring/rts/Rendering/Env/DynWater.cpp	2012-07-13 06:34:43.069393827 +0200
@@ -88,9 +88,9 @@
 
 	for (int y = 0; y < 64; ++y) {
 		for (int x = 0; x < 64; ++x) {
-			temp[(y*64 + x)*4 + 0] = sin(x*PI*2.0f/64.0f) + ((x < 32) ? -1 : 1)*0.3f;
+			temp[(y*64 + x)*4 + 0] = math::sin(x*PI*2.0f/64.0f) + ((x < 32) ? -1 : 1)*0.3f;
 			temp[(y*64 + x)*4 + 1] = temp[(y*64 + x)*4 + 0];
-			temp[(y*64 + x)*4 + 2] = cos(x*PI*2.0f/64.0f) + ((x < 32) ? (16 - x) : (x - 48))/16.0f*0.3f;
+			temp[(y*64 + x)*4 + 2] = math::cos(x*PI*2.0f/64.0f) + ((x < 32) ? (16 - x) : (x - 48))/16.0f*0.3f;
 			temp[(y*64 + x)*4 + 3] = 0;
 		}
 	}
@@ -197,7 +197,7 @@
 		const float dy = y - 31.5f;
 		for (int x = 0; x < 64; ++x) {
 			const float dx = x-31.5f;
-			const float dist = sqrt(dx*dx + dy*dy);
+			const float dist = math::sqrt(dx*dx + dy*dy);
 			temp[(y*64 + x)*4 + 0] = std::max(0.0f, 1 - dist/30.f) * std::max(0.0f, 1 - dist/30.f);
 			temp[(y*64 + x)*4 + 1] = std::max(0.0f, 1 - dist/30.f);
 			temp[(y*64 + x)*4 + 2] = std::max(0.0f, 1 - dist/30.f) * std::max(0.0f, 1 - dist/30.f);
@@ -425,8 +425,8 @@
 
 	oldCamPosBig = camPosBig;
 
-	camPosBig.x = floor(std::max((float)WH_SIZE, std::min((float)gs->mapx*SQUARE_SIZE-WH_SIZE, (float)camera->pos.x))/(W_SIZE*16))*(W_SIZE*16);
-	camPosBig.z = floor(std::max((float)WH_SIZE, std::min((float)gs->mapy*SQUARE_SIZE-WH_SIZE, (float)camera->pos.z))/(W_SIZE*16))*(W_SIZE*16);
+	camPosBig.x = math::floor(std::max((float)WH_SIZE, std::min((float)gs->mapx*SQUARE_SIZE-WH_SIZE, (float)camera->pos.x))/(W_SIZE*16))*(W_SIZE*16);
+	camPosBig.z = math::floor(std::max((float)WH_SIZE, std::min((float)gs->mapy*SQUARE_SIZE-WH_SIZE, (float)camera->pos.z))/(W_SIZE*16))*(W_SIZE*16);
 
 	glDisable(GL_DEPTH_TEST);
 	glDepthMask(0);
@@ -835,8 +835,8 @@
 	va = GetVertexArray();
 	va->Initialize();
 
-	camPosBig2.x = floor(std::max((float)WH_SIZE, std::min((float)gs->mapx*SQUARE_SIZE - WH_SIZE, (float)camera->pos.x))/(W_SIZE*16))*(W_SIZE*16);
-	camPosBig2.z = floor(std::max((float)WH_SIZE, std::min((float)gs->mapy*SQUARE_SIZE - WH_SIZE, (float)camera->pos.z))/(W_SIZE*16))*(W_SIZE*16);
+	camPosBig2.x = math::floor(std::max((float)WH_SIZE, std::min((float)gs->mapx*SQUARE_SIZE - WH_SIZE, (float)camera->pos.x))/(W_SIZE*16))*(W_SIZE*16);
+	camPosBig2.z = math::floor(std::max((float)WH_SIZE, std::min((float)gs->mapy*SQUARE_SIZE - WH_SIZE, (float)camera->pos.z))/(W_SIZE*16))*(W_SIZE*16);
 
 	// FIXME:
 	//     1. DynWater::UpdateCamRestraints was never called ==> <this->left> and <this->right> were always empty
@@ -1132,8 +1132,8 @@
 				// hovercraft
 				const float3& pos = unit->pos;
 
-				if ((fabs(pos.x - camPosBig.x) > (WH_SIZE - 50)) ||
-					(fabs(pos.z - camPosBig.z) > (WH_SIZE - 50)))
+				if ((math::fabs(pos.x - camPosBig.x) > (WH_SIZE - 50)) ||
+					(math::fabs(pos.z - camPosBig.z) > (WH_SIZE - 50)))
 				{
 					continue;
 				}
@@ -1144,7 +1144,7 @@
 				if ((pos.y > -4.0f) && (pos.y < 4.0f)) {
 					const float3 frontAdd = unit->frontdir * unit->radius * 0.75f;
 					const float3 sideAdd = unit->rightdir * unit->radius * 0.75f;
-					const float depth = sqrt(sqrt(unit->mass)) * 0.4f;
+					const float depth = math::sqrt(math::sqrt(unit->mass)) * 0.4f;
 					const float3 n(depth, 0.05f * depth, depth);
 
 					va2->AddVertexQTN(pos + frontAdd + sideAdd, 0, 0, n);
@@ -1156,8 +1156,8 @@
 				// surface ship
 				const float3& pos = unit->pos;
 
-				if ((fabs(pos.x - camPosBig.x) > (WH_SIZE - 50)) ||
-					(fabs(pos.z - camPosBig.z) > (WH_SIZE - 50)))
+				if ((math::fabs(pos.x - camPosBig.x) > (WH_SIZE - 50)) ||
+					(math::fabs(pos.z - camPosBig.z) > (WH_SIZE - 50)))
 				{
 					continue;
 				}
@@ -1171,7 +1171,7 @@
 
 				const float3 frontAdd = unit->frontdir * unit->radius * 0.75f;
 				const float3 sideAdd = unit->rightdir * unit->radius * 0.18f;
-				const float depth = sqrt(sqrt(unit->mass));
+				const float depth = math::sqrt(math::sqrt(unit->mass));
 				const float3 n(depth, 0.04f * unit->speed.Length2D() * depth, depth);
 
 				va->AddVertexQTN(pos + frontAdd + sideAdd, 0, 0, n);
@@ -1249,8 +1249,8 @@
 	for (std::vector<Explosion>::iterator ei = explosions.begin(); ei != explosions.end(); ++ei) {
 		Explosion& explo = *ei;
 		float3 pos = explo.pos;
-		if ((fabs(pos.x - camPosBig.x) > (WH_SIZE - 50))
-				|| (fabs(pos.z - camPosBig.z) > (WH_SIZE - 50)))
+		if ((math::fabs(pos.x - camPosBig.x) > (WH_SIZE - 50))
+				|| (math::fabs(pos.z - camPosBig.z) > (WH_SIZE - 50)))
 		{
 			continue;
 		}
diff -ru spring_89.0/rts/Rendering/Env/GrassDrawer.cpp /home/svenstaro/src/spring/rts/Rendering/Env/GrassDrawer.cpp
--- spring_89.0/rts/Rendering/Env/GrassDrawer.cpp	2012-07-10 00:10:07.000000000 +0200
+++ /home/svenstaro/src/spring/rts/Rendering/Env/GrassDrawer.cpp	2012-07-13 06:34:43.069393827 +0200
@@ -75,11 +75,11 @@
 	}
 
 	// TODO: get rid of the magic constants
-	maxGrassDist = 800 + sqrt((float) detail) * 240;
+	maxGrassDist = 800 + math::sqrt((float) detail) * 240;
 	maxDetailedDist = 146 + detail * 24;
 	detailedBlocks = int((maxDetailedDist - 24) / bMSsq) + 1;
 	numTurfs = 3 + int(detail * 0.5f);
-	strawPerTurf = 50 + int(sqrt((float) detail) * 10);
+	strawPerTurf = 50 + int(math::sqrt((float) detail) * 10);
 
 	blocksX = gs->mapx / grassSquareSize  /grassBlockSize;
 	blocksY = gs->mapy / grassSquareSize / grassBlockSize;
@@ -641,7 +641,7 @@
 		const float3 billboardDirX = (billboardDirZ.cross(UpVector)).ANormalize();
 		const float3 billboardDirY = billboardDirX.cross(billboardDirZ);
 
-		const float ang = acos(billboardDirZ.y);
+		const float ang = math::acos(billboardDirZ.y);
 		const int texPart = std::min(15, int(std::max(0, int((ang + PI / 16 - PI / 2) / PI * 30))));
 
 		if (globalRendering->haveGLSL) {
@@ -673,7 +673,7 @@
 			const float3 billboardDirX = (billboardDirZ.cross(UpVector)).ANormalize();
 			const float3 billboardDirY = billboardDirX.cross(billboardDirZ);
 
-			const float ang = acos(billboardDirZ.y);
+			const float ang = math::acos(billboardDirZ.y);
 			const int texPart = std::min(15, int(std::max(0, int((ang + PI / 16 - PI / 2) / PI * 30))));
 
 			if (globalRendering->haveGLSL) {
@@ -820,7 +820,7 @@
 		float3 forwardVect = sideVect.cross(UpVector);
 		sideVect *= mapInfo->grass.bladeWidth;
 
-		const float3 cornerPos = (UpVector * cos(maxAng) + forwardVect * sin(maxAng)) * length;
+		const float3 cornerPos = (UpVector * math::cos(maxAng) + forwardVect * math::sin(maxAng)) * length;
 		float3 basePos(30.0f, 0.0f, 30.0f);
 
 		while (basePos.SqLength2D() > (turfSize * turfSize / 4)) {
@@ -837,10 +837,10 @@
 
 			const float3 edgePosL =
 				-sideVect * (1 - h) +
-				(UpVector * cos(ang) + forwardVect * sin(ang)) * length * h;
+				(UpVector * math::cos(ang) + forwardVect * math::sin(ang)) * length * h;
 			const float3 edgePosR =
 				sideVect * (1.0f - h) +
-				(UpVector * cos(ang) + forwardVect * sin(ang)) * length * h;
+				(UpVector * math::cos(ang) + forwardVect * math::sin(ang)) * length * h;
 
 			if (b == 0) {
 				va->AddVertexT(basePos + (edgePosR - float3(0.0f, 0.1f, 0.0f)), xtexBase + xtexOffset, h);
diff -ru spring_89.0/rts/Rendering/Env/SkyLight.cpp /home/svenstaro/src/spring/rts/Rendering/Env/SkyLight.cpp
--- spring_89.0/rts/Rendering/Env/SkyLight.cpp	2012-07-10 00:10:07.000000000 +0200
+++ /home/svenstaro/src/spring/rts/Rendering/Env/SkyLight.cpp	2012-07-13 06:34:43.069393827 +0200
@@ -72,7 +72,7 @@
 bool DynamicSkyLight::SetLightDir(const float4& newLightDir) {
 	if (newLightDir != lightDir) {
 		static float4 lastUpdate = ZeroVector;
-		static const float minCosAngle = cos(1.5f * (PI/180.f));
+		static const float minCosAngle = math::cos(1.5f * (PI/180.f));
 
 		if (lastUpdate.dot(newLightDir) < minCosAngle) {
 			lastUpdate   = newLightDir;
@@ -92,7 +92,7 @@
 	const float angularVelocity = 2.0f * PI / sunOrbitTime;
 
 	const float sunAng  = startAngle - initialSunAngle - angularVelocity * gameSeconds;
-	const float4 sunPos = sunRotation.Mul(float3(sunOrbitRad * cos(sunAng), sunOrbitHeight, sunOrbitRad * sin(sunAng)));
+	const float4 sunPos = sunRotation.Mul(float3(sunOrbitRad * math::cos(sunAng), sunOrbitHeight, sunOrbitRad * math::sin(sunAng)));
 
 	return sunPos;
 }
@@ -108,18 +108,18 @@
 	if (newLightDir.w == FLT_MAX) {
 		// old: newLightDir is position where sun reaches highest altitude
 		const float sunLen = newLightDir.Length2D();
-		const float sunAzimuth = (sunLen <= 0.001f) ? PI / 2.0f : atan(newLightDir.y / sunLen);
-		const float sunHeight = tan(sunAzimuth - 0.001f);
+		const float sunAzimuth = (sunLen <= 0.001f) ? PI / 2.0f : math::atan(newLightDir.y / sunLen);
+		const float sunHeight = math::tan(sunAzimuth - 0.001f);
 
-		float3 v1(cos(initialSunAngle), sunHeight, sin(initialSunAngle));
+		float3 v1(math::cos(initialSunAngle), sunHeight, math::sin(initialSunAngle));
 		v1.ANormalize();
 
 		if (v1.y <= orbitMinSunHeight) {
 			newLightDir = UpVector;
 			sunOrbitHeight = v1.y;
-			sunOrbitRad = sqrt(1.0f - sunOrbitHeight * sunOrbitHeight);
+			sunOrbitRad = math::sqrt(1.0f - sunOrbitHeight * sunOrbitHeight);
 		} else {
-			float3 v2(cos(initialSunAngle + PI), orbitMinSunHeight, sin(initialSunAngle + PI));
+			float3 v2(math::cos(initialSunAngle + PI), orbitMinSunHeight, math::sin(initialSunAngle + PI));
 			v2.ANormalize();
 			float3 v3 = v2 - v1;
 			sunOrbitRad = v3.Length() / 2.0f;
@@ -137,7 +137,7 @@
 	} else {
 		// new: newLightDir is center position of orbit, and newLightDir.w is orbit height
 		sunOrbitHeight = std::max(-1.0f, std::min(newLightDir.w, 1.0f));
-		sunOrbitRad = sqrt(1.0f - sunOrbitHeight * sunOrbitHeight);
+		sunOrbitRad = math::sqrt(1.0f - sunOrbitHeight * sunOrbitHeight);
 	}
 
 	sunRotation.LoadIdentity();
diff -ru spring_89.0/rts/Rendering/GL/glExtra.cpp /home/svenstaro/src/spring/rts/Rendering/GL/glExtra.cpp
--- spring_89.0/rts/Rendering/GL/glExtra.cpp	2012-07-10 00:10:07.000000000 +0200
+++ /home/svenstaro/src/spring/rts/Rendering/GL/glExtra.cpp	2012-07-13 06:34:43.069393827 +0200
@@ -83,7 +83,7 @@
 		float adjustment = rad/2;
 		float ydiff = 0;
 		int j;
-		for(j = 0; j < 50 && fabs(adjRadius - rad) + ydiff > .01*rad; j++){
+		for(j = 0; j < 50 && math::fabs(adjRadius - rad) + ydiff > .01*rad; j++){
 			if(adjRadius > rad) {
 				rad += adjustment;
 			} else {
@@ -93,7 +93,7 @@
 			pos.x = center.x + (sinR * rad);
 			pos.z = center.z + (cosR * rad);
 			float newY = ground->GetHeightAboveWater(pos.x, pos.z, false);
-			ydiff = fabs(pos.y - newY);
+			ydiff = math::fabs(pos.y - newY);
 			pos.y = newY;
 			heightDiff = (pos.y - center.y);
 			adjRadius = weapon ? weapon->GetRange2D(heightDiff*weapon->heightMod) : rad;
diff -ru spring_89.0/rts/Rendering/GroundDecalHandler.cpp /home/svenstaro/src/spring/rts/Rendering/GroundDecalHandler.cpp
--- spring_89.0/rts/Rendering/GroundDecalHandler.cpp	2012-07-10 00:10:07.000000000 +0200
+++ /home/svenstaro/src/spring/rts/Rendering/GroundDecalHandler.cpp	2012-07-13 06:34:43.082727161 +0200
@@ -963,7 +963,7 @@
 		radius = damage * 0.25f;
 
 	if (damage > 400)
-		damage = 400 + sqrt(damage - 399);
+		damage = 400 + math::sqrt(damage - 399);
 
 	pos.ClampInBounds();
 
diff -ru spring_89.0/rts/Rendering/InMapDrawView.cpp /home/svenstaro/src/spring/rts/Rendering/InMapDrawView.cpp
--- spring_89.0/rts/Rendering/InMapDrawView.cpp	2012-07-10 00:10:07.000000000 +0200
+++ /home/svenstaro/src/spring/rts/Rendering/InMapDrawView.cpp	2012-07-13 06:34:43.069393827 +0200
@@ -38,7 +38,7 @@
 	for (int y = 0; y < 64; y++) {
 		// circular thingy
 		for (int x = 0; x < 64; x++) {
-			float dist = sqrt((float)(x - 32) * (x - 32) + (y - 32) * (y - 32));
+			float dist = math::sqrt((float)(x - 32) * (x - 32) + (y - 32) * (y - 32));
 			if (dist > 31.0f) {
 				// do nothing - leave transparent
 			} else if (dist > 30.0f) {
diff -ru spring_89.0/rts/Rendering/LineDrawer.cpp /home/svenstaro/src/spring/rts/Rendering/LineDrawer.cpp
--- spring_89.0/rts/Rendering/LineDrawer.cpp	2012-07-10 00:10:07.000000000 +0200
+++ /home/svenstaro/src/spring/rts/Rendering/LineDrawer.cpp	2012-07-13 06:34:43.069393827 +0200
@@ -29,7 +29,7 @@
 void CLineDrawer::UpdateLineStipple()
 {
 	stippleTimer += (globalRendering->lastFrameTime * cmdColors.StippleSpeed());
-	stippleTimer = fmod(stippleTimer, (16.0f / 20.0f));
+	stippleTimer = math::fmod(stippleTimer, (16.0f / 20.0f));
 }
 
 
diff -ru spring_89.0/rts/Rendering/Models/S3OParser.cpp /home/svenstaro/src/spring/rts/Rendering/Models/S3OParser.cpp
--- spring_89.0/rts/Rendering/Models/S3OParser.cpp	2012-07-10 00:10:07.000000000 +0200
+++ /home/svenstaro/src/spring/rts/Rendering/Models/S3OParser.cpp	2012-07-13 06:34:43.069393827 +0200
@@ -319,7 +319,7 @@
 		float3& t = tTangents[vrtIdx];
 		int h = 1;
 
-		if (isnan(n.x) || isnan(n.y) || isnan(n.z)) {
+		if (math::isnan(n.x) || math::isnan(n.y) || math::isnan(n.z)) {
 			n = float3(0.0f, 0.0f, 1.0f);
 		}
 		if (s == ZeroVector) { s = float3(1.0f, 0.0f, 0.0f); }
diff -ru spring_89.0/rts/Sim/Misc/LosMap.cpp /home/svenstaro/src/spring/rts/Sim/Misc/LosMap.cpp
--- spring_89.0/rts/Sim/Misc/LosMap.cpp	2012-07-10 00:10:07.000000000 +0200
+++ /home/svenstaro/src/spring/rts/Sim/Misc/LosMap.cpp	2012-07-13 06:34:43.069393827 +0200
@@ -182,7 +182,7 @@
 
 		y = (int)i;
 		x = 1;
-		y = (int) (sqrt((float)r2 - 1) + 0.5f);
+		y = (int) (math::sqrt((float)r2 - 1) + 0.5f);
 		while (x < y) {
 			if(!PaintTable[x+y*Radius]) {
 				DrawLine(PaintTable, x, y, Radius);
@@ -198,7 +198,7 @@
 			}
 
 			x += 1;
-			y = (int) (sqrt((float)r2 - x*x) + 0.5f);
+			y = (int) (math::sqrt((float)r2 - x*x) + 0.5f);
 		}
 		if (x == y) {
 			if(!PaintTable[x+y*Radius]) {
diff -ru spring_89.0/rts/Sim/Misc/QuadField.cpp /home/svenstaro/src/spring/rts/Sim/Misc/QuadField.cpp
--- spring_89.0/rts/Sim/Misc/QuadField.cpp	2012-07-10 00:10:07.000000000 +0200
+++ /home/svenstaro/src/spring/rts/Sim/Misc/QuadField.cpp	2012-07-13 06:34:43.069393827 +0200
@@ -329,12 +329,12 @@
 	float zp = start.z;
 	const float invQuadSize = 1.0f / QUAD_SIZE;
 
-	if ((floor(start.x * invQuadSize) == floor(to.x * invQuadSize)) &&
-		(floor(start.z * invQuadSize) == floor(to.z * invQuadSize)))
+	if ((math::floor(start.x * invQuadSize) == math::floor(to.x * invQuadSize)) &&
+		(math::floor(start.z * invQuadSize) == math::floor(to.z * invQuadSize)))
 	{
 		*endQuad = ((int(start.x * invQuadSize)) + (int(start.z * invQuadSize)) * numQuadsX);
 		++endQuad;
-	} else if (floor(start.x * invQuadSize) == floor(to.x * invQuadSize)) {
+	} else if (math::floor(start.x * invQuadSize) == math::floor(to.x * invQuadSize)) {
 		const int first = (int)(start.x * invQuadSize) + ((int)(start.z * invQuadSize) * numQuadsX);
 		const int last  = (int)(to.x    * invQuadSize) + ((int)(to.z    * invQuadSize) * numQuadsX);
 
@@ -347,7 +347,7 @@
 				*endQuad = a; ++endQuad;
 			}
 		}
-	} else if (floor(start.z * invQuadSize) == floor(to.z * invQuadSize)) {
+	} else if (math::floor(start.z * invQuadSize) == math::floor(to.z * invQuadSize)) {
 		const int first = (int)(start.x * invQuadSize) + ((int)(start.z * invQuadSize) * numQuadsX);
 		const int last  = (int)(to.x    * invQuadSize) + ((int)(to.z    * invQuadSize) * numQuadsX);
 
@@ -369,14 +369,14 @@
 			++endQuad;
 
 			if (dx > 0) {
-				xn = (floor(xp * invQuadSize) * QUAD_SIZE + QUAD_SIZE - xp) / dx;
+				xn = (math::floor(xp * invQuadSize) * QUAD_SIZE + QUAD_SIZE - xp) / dx;
 			} else {
-				xn = (floor(xp * invQuadSize) * QUAD_SIZE - xp) / dx;
+				xn = (math::floor(xp * invQuadSize) * QUAD_SIZE - xp) / dx;
 			}
 			if (dz > 0) {
-				zn = (floor(zp * invQuadSize) * QUAD_SIZE + QUAD_SIZE - zp) / dz;
+				zn = (math::floor(zp * invQuadSize) * QUAD_SIZE + QUAD_SIZE - zp) / dz;
 			} else {
-				zn = (floor(zp * invQuadSize) * QUAD_SIZE - zp) / dz;
+				zn = (math::floor(zp * invQuadSize) * QUAD_SIZE - zp) / dz;
 			}
 
 			if (xn < zn) {
@@ -388,8 +388,8 @@
 			}
 
 			keepgoing =
-				(fabs(xp - start.x) < fabs(to.x - start.x)) &&
-				(fabs(zp - start.z) < fabs(to.z - start.z));
+				(math::fabs(xp - start.x) < math::fabs(to.x - start.x)) &&
+				(math::fabs(zp - start.z) < math::fabs(to.z - start.z));
 		}
 	}
 
diff -ru spring_89.0/rts/Sim/MoveTypes/ClassicGroundMoveType.cpp /home/svenstaro/src/spring/rts/Sim/MoveTypes/ClassicGroundMoveType.cpp
--- spring_89.0/rts/Sim/MoveTypes/ClassicGroundMoveType.cpp	2012-07-10 00:10:07.000000000 +0200
+++ /home/svenstaro/src/spring/rts/Sim/MoveTypes/ClassicGroundMoveType.cpp	2012-07-13 06:34:43.256060504 +0200
@@ -386,7 +386,7 @@
 
 	const float dif = wSpeed - currentSpeed;
 
-	if (fabs(dif) < 0.05f) {
+	if (math::fabs(dif) < 0.05f) {
 		deltaSpeed = dif * 0.125f;
 		nextDeltaSpeedUpdate = gs->frameNum + 8;
 	} else if (dif > 0.0f) {
@@ -529,7 +529,7 @@
 			skidRotSpeed = 0.0f;
 			owner->physicalState = oldPhysState;
 			owner->moveType->useHeading = true;
-			float rp = floor(skidRotPos2 + skidRotSpeed2 + 0.5f);
+			float rp = math::floor(skidRotPos2 + skidRotSpeed2 + 0.5f);
 			skidRotSpeed2 = (rp - skidRotPos2) * 0.5f;
 			ChangeHeading(owner->heading);
 		} else {
@@ -545,10 +545,10 @@
 			}
 
 			float remTime=speedf/speedReduction-1;
-			float rp=floor(skidRotPos2+skidRotSpeed2*remTime+0.5f);
+			float rp=math::floor(skidRotPos2+skidRotSpeed2*remTime+0.5f);
 			skidRotSpeed2=(remTime+1 == 0 ) ? 0 : (rp-skidRotPos2)/(remTime+1);
 
-			if(floor(skidRotPos2)!=floor(skidRotPos2+skidRotSpeed2)){
+			if(math::floor(skidRotPos2)!=math::floor(skidRotPos2+skidRotSpeed2)){
 				skidRotPos2=0;
 				skidRotSpeed2=0;
 			}
@@ -571,7 +571,7 @@
 				speed*=0.95f;
 			}
 			else {
-				speed += (normal*(fabs(speed.dot(normal)) + .1))*1.9f;
+				speed += (normal*(math::fabs(speed.dot(normal)) + .1))*1.9f;
 				speed*=.8;
 			}
 		}
@@ -625,7 +625,7 @@
 		float totRad = owner->radius + u->radius;
 
 		if (sqDist < totRad * totRad && sqDist != 0) {
-			float dist = sqrt(sqDist);
+			float dist = math::sqrt(sqDist);
 			float3 dif = midPos - u->midPos;
 			dif /= std::max(dist, 1.f);
 
@@ -682,7 +682,7 @@
 		float sqDist=(midPos-u->midPos).SqLength();
 		float totRad=owner->radius+u->radius;
 		if(sqDist<totRad*totRad && sqDist!=0){
-			float dist=sqrt(sqDist);
+			float dist=math::sqrt(sqDist);
 			float3 dif=midPos-u->midPos;
 			dif/=std::max(dist, 1.f);
 			float impactSpeed = -owner->speed.dot(dif);
@@ -721,8 +721,8 @@
 
 	skidRotPos2 += skidRotSpeed2;
 
-	float cosp = cos(skidRotPos2 * PI * 2.0f);
-	float sinp = sin(skidRotPos2 * PI * 2.0f);
+	float cosp = math::cos(skidRotPos2 * PI * 2.0f);
+	float sinp = math::sin(skidRotPos2 * PI * 2.0f);
 
 	float3 f1 = skidRotVector * skidRotVector.dot(owner->frontdir);
 	float3 f2 = owner->frontdir - f1;
@@ -812,7 +812,7 @@
 						float objectDistToAvoidDirCenter = objectToUnit.dot(rightOfAvoid);
 
 						if (objectToUnit.dot(avoidanceDir) < radiusSum &&
-							fabs(objectDistToAvoidDirCenter) < radiusSum &&
+							math::fabs(objectDistToAvoidDirCenter) < radiusSum &&
 							(o->moveDef || Distance2D(owner, o) >= 0)) {
 
 							if (objectDistToAvoidDirCenter > 0.0f) {
@@ -824,7 +824,7 @@
 								rightOfAvoid = avoidanceDir.cross(float3(0.0f, 1.0f, 0.0f));
 							} else {
 								avoidLeft +=
-									(radiusSum - fabs(objectDistToAvoidDirCenter)) *
+									(radiusSum - math::fabs(objectDistToAvoidDirCenter)) *
 									AVOIDANCE_STRENGTH * fastmath::isqrt2(distanceToObjectSq);
 								avoidanceDir -= (rightOfAvoid * avoidLeft);
 								avoidanceDir.Normalize();
@@ -952,7 +952,7 @@
 	if (!decRate) {
 		return 0.0f;
 	}
-	return fabs(speed*speed / decRate);
+	return math::fabs(speed*speed / decRate);
 }
 
 float3 CClassicGroundMoveType::Here()
@@ -1043,7 +1043,7 @@
 			const float zmove = (owner->mapPos.y + owner->zsize / 2) * SQUARE_SIZE;
 			const float xmove = (owner->mapPos.x + owner->xsize / 2) * SQUARE_SIZE;
 
-			if (fabs(owner->frontdir.x) > fabs(owner->frontdir.z)) {
+			if (math::fabs(owner->frontdir.x) > math::fabs(owner->frontdir.z)) {
 				if (newmp.y < owner->mapPos.y) {
 					haveCollided |= CheckColV(newmp.y, newmp.x, newmp.x + owner->xsize - 1,  zmove - 3.99f, owner->mapPos.y);
 					newmp = owner->GetMapPos();
@@ -1261,20 +1261,20 @@
 			float xp = start.x;
 			float zp = start.z;
 
-			if (floor(start.x) == floor(to.x)) {
+			if (math::floor(start.x) == math::floor(to.x)) {
 				if (dz > 0.0f) {
-					for (int a = 1; a < floor(to.z); ++a)
+					for (int a = 1; a < math::floor(to.z); ++a)
 						lineTable[yt][xt].push_back(int2(0, a));
 				} else {
-					for (int a = -1; a > floor(to.z); --a)
+					for (int a = -1; a > math::floor(to.z); --a)
 						lineTable[yt][xt].push_back(int2(0, a));
 				}
-			} else if (floor(start.z) == floor(to.z)) {
+			} else if (math::floor(start.z) == math::floor(to.z)) {
 				if (dx > 0.0f) {
-					for (int a = 1; a < floor(to.x); ++a)
+					for (int a = 1; a < math::floor(to.x); ++a)
 						lineTable[yt][xt].push_back(int2(a, 0));
 				} else {
-					for (int a = -1; a > floor(to.x); --a)
+					for (int a = -1; a > math::floor(to.x); --a)
 						lineTable[yt][xt].push_back(int2(a, 0));
 				}
 			} else {
@@ -1283,14 +1283,14 @@
 
 				while (keepgoing) {
 					if (dx > 0.0f) {
-						xn = (floor(xp) + 1.0f - xp) / dx;
+						xn = (math::floor(xp) + 1.0f - xp) / dx;
 					} else {
-						xn = (floor(xp)        - xp) / dx;
+						xn = (math::floor(xp)        - xp) / dx;
 					}
 					if (dz > 0.0f) {
-						zn = (floor(zp) + 1.0f - zp) / dz;
+						zn = (math::floor(zp) + 1.0f - zp) / dz;
 					} else {
-						zn = (floor(zp)        - zp) / dz;
+						zn = (math::floor(zp)        - zp) / dz;
 					}
 
 					if (xn < zn) {
@@ -1302,10 +1302,10 @@
 					}
 
 					keepgoing =
-						fabs(xp - start.x) < fabs(to.x - start.x) &&
-						fabs(zp - start.z) < fabs(to.z - start.z);
+						math::fabs(xp - start.x) < math::fabs(to.x - start.x) &&
+						math::fabs(zp - start.z) < math::fabs(to.z - start.z);
 
-					lineTable[yt][xt].push_back( int2(int(floor(xp)), int(floor(zp))) );
+					lineTable[yt][xt].push_back( int2(int(math::floor(xp)), int(math::floor(zp))) );
 				}
 
 				lineTable[yt][xt].pop_back();
@@ -1335,7 +1335,7 @@
 		const MoveDef& md = *(owner->unitDef->moveDef);
 		const float cmod = movemath->GetPosSpeedMod(md, moveSquareX * 2, moveSquareY * 2);
 
-		if (fabs(owner->frontdir.x) < fabs(owner->frontdir.z)) {
+		if (math::fabs(owner->frontdir.x) < math::fabs(owner->frontdir.z)) {
 			if (newMoveSquareX > moveSquareX) {
 				const float nmod = movemath->GetPosSpeedMod(md, newMoveSquareX * 2, newMoveSquareY * 2);
 				if (cmod > 0.01f && nmod <= 0.01f) {
diff -ru spring_89.0/rts/Sim/MoveTypes/GroundMoveType.cpp /home/svenstaro/src/spring/rts/Sim/MoveTypes/GroundMoveType.cpp
--- spring_89.0/rts/Sim/MoveTypes/GroundMoveType.cpp	2012-07-10 00:10:07.000000000 +0200
+++ /home/svenstaro/src/spring/rts/Sim/MoveTypes/GroundMoveType.cpp	2012-07-13 06:34:43.249393836 +0200
@@ -1808,20 +1808,20 @@
 			float xp = start.x;
 			float zp = start.z;
 
-			if (floor(start.x) == floor(to.x)) {
+			if (math::floor(start.x) == math::floor(to.x)) {
 				if (dz > 0.0f) {
-					for (int a = 1; a <= floor(to.z); ++a)
+					for (int a = 1; a <= math::floor(to.z); ++a)
 						lineTable[yt][xt].push_back(int2(0, a));
 				} else {
-					for (int a = -1; a >= floor(to.z); --a)
+					for (int a = -1; a >= math::floor(to.z); --a)
 						lineTable[yt][xt].push_back(int2(0, a));
 				}
-			} else if (floor(start.z) == floor(to.z)) {
+			} else if (math::floor(start.z) == math::floor(to.z)) {
 				if (dx > 0.0f) {
-					for (int a = 1; a <= floor(to.x); ++a)
+					for (int a = 1; a <= math::floor(to.x); ++a)
 						lineTable[yt][xt].push_back(int2(a, 0));
 				} else {
-					for (int a = -1; a >= floor(to.x); --a)
+					for (int a = -1; a >= math::floor(to.x); --a)
 						lineTable[yt][xt].push_back(int2(a, 0));
 				}
 			} else {
@@ -1830,14 +1830,14 @@
 
 				while (keepgoing) {
 					if (dx > 0.0f) {
-						xn = (floor(xp) + 1.0f - xp) / dx;
+						xn = (math::floor(xp) + 1.0f - xp) / dx;
 					} else {
-						xn = (floor(xp)        - xp) / dx;
+						xn = (math::floor(xp)        - xp) / dx;
 					}
 					if (dz > 0.0f) {
-						zn = (floor(zp) + 1.0f - zp) / dz;
+						zn = (math::floor(zp) + 1.0f - zp) / dz;
 					} else {
-						zn = (floor(zp)        - zp) / dz;
+						zn = (math::floor(zp)        - zp) / dz;
 					}
 
 					if (xn < zn) {
@@ -1851,7 +1851,7 @@
 					keepgoing =
 						math::fabs(xp - start.x) <= math::fabs(to.x - start.x) &&
 						math::fabs(zp - start.z) <= math::fabs(to.z - start.z);
-					int2 pt(int(floor(xp)), int(floor(zp)));
+					int2 pt(int(math::floor(xp)), int(math::floor(zp)));
 
 					static const int MIN_IDX = -int(LINETABLE_SIZE / 2);
 					static const int MAX_IDX = -MIN_IDX;
diff -ru spring_89.0/rts/Sim/MoveTypes/HoverAirMoveType.cpp /home/svenstaro/src/spring/rts/Sim/MoveTypes/HoverAirMoveType.cpp
--- spring_89.0/rts/Sim/MoveTypes/HoverAirMoveType.cpp	2012-07-10 00:10:07.000000000 +0200
+++ /home/svenstaro/src/spring/rts/Sim/MoveTypes/HoverAirMoveType.cpp	2012-07-13 06:34:43.069393827 +0200
@@ -325,7 +325,7 @@
 {
 	#define NOZERO(x) std::max(x, 0.0001f)
 
-	const float driftSpeed = fabs(owner->unitDef->dlHoverFactor);
+	const float driftSpeed = math::fabs(owner->unitDef->dlHoverFactor);
 	float3 deltaVec = goalPos - owner->pos;
 	float3 deltaDir = float3(deltaVec.x, 0.0f, deltaVec.z);
 	float l = NOZERO(deltaDir.Length2D());
@@ -342,7 +342,7 @@
 	deltaDir -= owner->speed;
 	l = deltaDir.SqLength2D();
 	if (l > (maxSpeed * maxSpeed)) {
-		deltaDir *= maxSpeed / NOZERO(sqrt(l));
+		deltaDir *= maxSpeed / NOZERO(math::sqrt(l));
 	}
 	wantedSpeed = owner->speed + deltaDir;
 
diff -ru spring_89.0/rts/Sim/MoveTypes/StrafeAirMoveType.cpp /home/svenstaro/src/spring/rts/Sim/MoveTypes/StrafeAirMoveType.cpp
--- spring_89.0/rts/Sim/MoveTypes/StrafeAirMoveType.cpp	2012-07-10 00:10:07.000000000 +0200
+++ /home/svenstaro/src/spring/rts/Sim/MoveTypes/StrafeAirMoveType.cpp	2012-07-13 06:34:43.069393827 +0200
@@ -412,7 +412,7 @@
 				}
 			}
 
-			if (fabs(owner->rightdir.y) < maxAileron * 3.0f * speedf || owner->updir.y < 0.0f) {
+			if (math::fabs(owner->rightdir.y) < maxAileron * 3.0f * speedf || owner->updir.y < 0.0f) {
 				elevator = 1;
 			}
 			UpdateAirPhysics(0, aileron, elevator, 1, owner->frontdir);
@@ -528,13 +528,13 @@
 	if (goalDir.dot(frontdir) < -0.2f + inefficientAttackTime * 0.002f && frontdir.y > -0.2f && speedf > 2.0f && gs->randFloat() > 0.996f)
 		maneuver = 1;
 
-	if (goalDir.dot(frontdir) < -0.2f + inefficientAttackTime * 0.002f && fabs(frontdir.y) < 0.2f && gs->randFloat() > 0.996f && gHeightAW + 400 < pos.y) {
+	if (goalDir.dot(frontdir) < -0.2f + inefficientAttackTime * 0.002f && math::fabs(frontdir.y) < 0.2f && gs->randFloat() > 0.996f && gHeightAW + 400 < pos.y) {
 		maneuver = 2;
 		maneuverSubState = 0;
 	}
 
 	// roll
-	if (speedf > 0.45f && pos.y + owner->speed.y * 60 * fabs(frontdir.y) + std::min(0.0f, float(updir.y)) * 150 > gHeightAW + 60 + fabs(rightdir.y) * 150) {
+	if (speedf > 0.45f && pos.y + owner->speed.y * 60 * math::fabs(frontdir.y) + std::min(0.0f, float(updir.y)) * 150 > gHeightAW + 60 + math::fabs(rightdir.y) * 150) {
 		const float goalBankDif = goalDotRight + rightdir.y * 0.2f;
 		if (goalBankDif > maxAileron * speedf * 4.0f) {
 			aileron = 1;
@@ -706,7 +706,7 @@
 		} else if (goalBankDif < -maxAileron * speedf * 4 && rightdir.y < maxBank) {
 			aileron = -1;
 		} else {
-			if (fabs(rightdir.y) < maxBank) {
+			if (math::fabs(rightdir.y) < maxBank) {
 				aileron = goalBankDif / (maxAileron * speedf * 4);
 			} else {
 				if (rightdir.y < 0.0f && goalBankDif < 0.0f) {
@@ -762,7 +762,7 @@
 			} else if (hdif > (maxElevator * speedf * speedf * 20) && frontdir.y < maxPitch) {
 				elevator = 1;
 			} else {
-				if (fabs(frontdir.y) < maxPitch)
+				if (math::fabs(frontdir.y) < maxPitch)
 					elevator = hdif / (maxElevator * speedf * speedf * 20);
 			}
 		}
diff -ru spring_89.0/rts/Sim/Path/Default/PathEstimator.cpp /home/svenstaro/src/spring/rts/Sim/Path/Default/PathEstimator.cpp
--- spring_89.0/rts/Sim/Path/Default/PathEstimator.cpp	2012-07-10 00:10:07.000000000 +0200
+++ /home/svenstaro/src/spring/rts/Sim/Path/Default/PathEstimator.cpp	2012-07-13 06:34:42.939393819 +0200
@@ -201,7 +201,7 @@
 
 void CPathEstimator::CalcOffsetsAndPathCosts(int thread) {
 	//! reset FPU state for synced computations
-	streflop_init<streflop::Simple>();
+	streflop::streflop_init<streflop::Simple>();
 
 	// NOTE: EstimatePathCosts() [B] is temporally dependent on CalculateBlockOffsets() [A],
 	// A must be completely finished before B_i can be safely called. This means we cannot
diff -ru spring_89.0/rts/Sim/Path/QTPFS/PathManager.cpp /home/svenstaro/src/spring/rts/Sim/Path/QTPFS/PathManager.cpp
--- spring_89.0/rts/Sim/Path/QTPFS/PathManager.cpp	2012-07-10 00:10:07.000000000 +0200
+++ /home/svenstaro/src/spring/rts/Sim/Path/QTPFS/PathManager.cpp	2012-07-13 06:34:43.016060490 +0200
@@ -251,7 +251,7 @@
 
 
 void QTPFS::PathManager::InitNodeLayersThreaded(const SRectangle& rect) {
-	streflop_init<streflop::Simple>();
+	streflop::streflop_init<streflop::Simple>();
 
 	char loadMsg[512] = {'\0'};
 	const char* fmtString = "[PathManager::%s] using %u threads for %u node-layers (cached? %s)";
@@ -310,7 +310,7 @@
 	}
 	#endif
 
-	streflop_init<streflop::Simple>();
+	streflop::streflop_init<streflop::Simple>();
 }
 
 void QTPFS::PathManager::InitNodeLayersThread(
@@ -360,7 +360,7 @@
 
 
 void QTPFS::PathManager::UpdateNodeLayersThreaded(const SRectangle& rect) {
-	streflop_init<streflop::Simple>();
+	streflop::streflop_init<streflop::Simple>();
 
 	#ifdef QTPFS_OPENMP_ENABLED
 	{
@@ -375,7 +375,7 @@
 	}
 	#endif
 
-	streflop_init<streflop::Simple>();
+	streflop::streflop_init<streflop::Simple>();
 }
 
 void QTPFS::PathManager::UpdateNodeLayersThread(
@@ -569,7 +569,7 @@
 	SCOPED_TIMER("PathManager::Update");
 
 	#ifdef QTPFS_ENABLE_THREADED_UPDATE
-	streflop_init<streflop::Simple>();
+	streflop::streflop_init<streflop::Simple>();
 
 	// allow ThreadUpdate to run one iteration
 	condThreadUpdate->notify_one();
@@ -579,7 +579,7 @@
 	// wait for the ThreadUpdate iteration to finish
 	condThreadUpdated->wait(lock);
 
-	streflop_init<streflop::Simple>();
+	streflop::streflop_init<streflop::Simple>();
 	#else
 	ThreadUpdate();
 	#endif
diff -ru spring_89.0/rts/Sim/Projectiles/ExplosionGenerator.cpp /home/svenstaro/src/spring/rts/Sim/Projectiles/ExplosionGenerator.cpp
--- spring_89.0/rts/Sim/Projectiles/ExplosionGenerator.cpp	2012-07-10 00:10:07.000000000 +0200
+++ /home/svenstaro/src/spring/rts/Sim/Projectiles/ExplosionGenerator.cpp	2012-07-13 06:34:43.082727161 +0200
@@ -262,7 +262,7 @@
 	damage *= gfxMod;
 	damage = std::max(damage, 0.0f);
 
-	const float sqrtDmg = sqrt(damage);
+	const float sqrtDmg = math::sqrt(damage);
 	const float camLength = camVect.Length();
 	float moveLength = radius * 0.03f;
 
@@ -283,7 +283,7 @@
 		if (airExplosion || waterExplosion) { smokeDamage *= 0.6f; }
 
 		if (smokeDamage > 0.01f) {
-			smokeDamageSQRT = sqrt(smokeDamage);
+			smokeDamageSQRT = math::sqrt(smokeDamage);
 			smokeDamageISQRT = 1.0f / (smokeDamageSQRT * 0.35f);
 		}
 
@@ -507,17 +507,17 @@
 			}
 			case OP_SAWTOOTH: {
 				// this translates to modulo except it works with floats
-				val -= (*(float*) code) * floor(val / (*(float*) code));
+				val -= (*(float*) code) * math::floor(val / (*(float*) code));
 				code += 4;
 				break;
 			}
 			case OP_DISCRETE: {
-				val = (*(float*) code) * floor(val / (*(float*) code));
+				val = (*(float*) code) * math::floor(val / (*(float*) code));
 				code += 4;
 				break;
 			}
 			case OP_SINE: {
-				val = (*(float*) code) * sin(val);
+				val = (*(float*) code) * math::sin(val);
 				code += 4;
 				break;
 			}
@@ -538,12 +538,12 @@
 				break;
 			}
 			case OP_POW: {
-				val = pow(val, (*(float*) code));
+				val = math::pow(val, (*(float*) code));
 				code += 4;
 				break;
 			}
 			case OP_POWBUFF: {
-				val = pow(val, buffer[(*(int*) code)]);
+				val = math::pow(val, buffer[(*(int*) code)]);
 				code += 4;
 				break;
 			}
diff -ru spring_89.0/rts/Sim/Projectiles/PieceProjectile.cpp /home/svenstaro/src/spring/rts/Sim/Projectiles/PieceProjectile.cpp
--- spring_89.0/rts/Sim/Projectiles/PieceProjectile.cpp	2012-07-10 00:10:07.000000000 +0200
+++ /home/svenstaro/src/spring/rts/Sim/Projectiles/PieceProjectile.cpp	2012-07-13 06:34:43.069393827 +0200
@@ -111,7 +111,7 @@
 	oldSmokeDir.Normalize();
 	const float3 camDir = (pos - camera->pos).Normalize();
 
-	if (camera->pos.distance(pos) + (1 - fabs(camDir.dot(oldSmokeDir))) * 3000 < 200) {
+	if (camera->pos.distance(pos) + (1 - math::fabs(camDir.dot(oldSmokeDir))) * 3000 < 200) {
 		drawTrail = false;
 	}
 
@@ -334,7 +334,7 @@
 
 			if (!drawTrail) {
 				float3 camDir = (pos - camera->pos).Normalize();
-				if (camera->pos.distance(pos) + (1 - fabs(camDir.dot(dir))) * 3000 > 300) {
+				if (camera->pos.distance(pos) + (1 - math::fabs(camDir.dot(dir))) * 3000 > 300) {
 					drawTrail = true;
 				}
 			}
@@ -373,7 +373,7 @@
 				const float3 dif2 = (oldSmokePos - camera->pos).Normalize();
 				const float3 dir2 = (dif2.cross(oldSmokeDir)).Normalize();
 
-				float a1 = ((1 - 0.0f / (Smoke_Time)) * 255) * (0.7f + fabs(dif.dot(dir)));
+				float a1 = ((1 - 0.0f / (Smoke_Time)) * 255) * (0.7f + math::fabs(dif.dot(dir)));
 				float alpha = std::min(255.0f, std::max(0.f, a1));
 				col[0] = (unsigned char) (color * alpha);
 				col[1] = (unsigned char) (color * alpha);
@@ -381,7 +381,7 @@
 				col[3] = (unsigned char) (alpha);
 
 				unsigned char col2[4];
-				float a2 = ((1 - float(age2) / (Smoke_Time)) * 255) * (0.7f + fabs(dif2.dot(oldSmokeDir)));
+				float a2 = ((1 - float(age2) / (Smoke_Time)) * 255) * (0.7f + math::fabs(dif2.dot(oldSmokeDir)));
 
 				if (age < 8)
 					a2 = 0;
diff -ru spring_89.0/rts/Sim/Projectiles/Unsynced/SimpleParticleSystem.cpp /home/svenstaro/src/spring/rts/Sim/Projectiles/Unsynced/SimpleParticleSystem.cpp
--- spring_89.0/rts/Sim/Projectiles/Unsynced/SimpleParticleSystem.cpp	2012-07-10 00:10:07.000000000 +0200
+++ /home/svenstaro/src/spring/rts/Sim/Projectiles/Unsynced/SimpleParticleSystem.cpp	2012-07-13 06:34:43.072727160 +0200
@@ -188,7 +188,7 @@
 		particles[i].size = particleSize + gu->usRandFloat()*particleSizeSpread;
 		particles[i].pos = pos;
 
-		particles[i].speed = ((up * emitMul.y) * cos(ay) - ((right * emitMul.x) * cos(az) - (forward * emitMul.z) * sin(az)) * sin(ay)) * (particleSpeed + (gu->usRandFloat() * particleSpeedSpread));
+		particles[i].speed = ((up * emitMul.y) * math::cos(ay) - ((right * emitMul.x) * math::cos(az) - (forward * emitMul.z) * math::sin(az)) * math::sin(ay)) * (particleSpeed + (gu->usRandFloat() * particleSpeedSpread));
 	}
 
 	drawRadius = (particleSpeed + particleSpeedSpread) * (particleLife * particleLifeSpread);
@@ -232,7 +232,7 @@
 		const float az = gu->usRandFloat() * 2 * PI;
 		const float ay = (emitRot + emitRotSpread*gu->usRandFloat()) * (PI / 180.0);
 
-		float3 pspeed = ((up * emitMul.y) * cos(ay) - ((right * emitMul.x) * cos(az) - (forward * emitMul.z) * sin(az)) * sin(ay)) * (particleSpeed + (gu->usRandFloat() * particleSpeedSpread));
+		float3 pspeed = ((up * emitMul.y) * math::cos(ay) - ((right * emitMul.x) * math::cos(az) - (forward * emitMul.z) * math::sin(az)) * math::sin(ay)) * (particleSpeed + (gu->usRandFloat() * particleSpeedSpread));
 
 		CGenericParticleProjectile* particle = new CGenericParticleProjectile(pos + explosionPos, pspeed, owner);
 
diff -ru spring_89.0/rts/Sim/Projectiles/Unsynced/SmokeTrailProjectile.cpp /home/svenstaro/src/spring/rts/Sim/Projectiles/Unsynced/SmokeTrailProjectile.cpp
--- spring_89.0/rts/Sim/Projectiles/Unsynced/SmokeTrailProjectile.cpp	2012-07-10 00:10:07.000000000 +0200
+++ /home/svenstaro/src/spring/rts/Sim/Projectiles/Unsynced/SmokeTrailProjectile.cpp	2012-07-13 06:34:43.072727160 +0200
@@ -124,7 +124,7 @@
 		if (lastSegment) {
 			a1 = 0;
 		}
-		a1 *= 0.7f + fabs(dif1.dot(dir1));
+		a1 *= 0.7f + math::fabs(dif1.dot(dir1));
 		float alpha = std::min(255.f, std::max(0.f, a1));
 		col[0] = (unsigned char) (color * alpha);
 		col[1] = (unsigned char) (color * alpha);
@@ -136,7 +136,7 @@
 		if (firstSegment) {
 			a2 = 0;
 		}
-		a2 *= 0.7f + fabs(dif2.dot(dir2));
+		a2 *= 0.7f + math::fabs(dif2.dot(dir2));
 		alpha = std::min(255.f, std::max(0.0f, a2));
 		col2[0] = (unsigned char) (color * alpha);
 		col2[1] = (unsigned char) (color * alpha);
@@ -153,7 +153,7 @@
 
 			unsigned char col3[4];
 			float a2 = (1 - (float)(age + 4) / lifeTime) * 255;
-			a2 *= 0.7f + fabs(dif3.dot(middir));
+			a2 *= 0.7f + math::fabs(dif3.dot(middir));
 			alpha = std::min(255.0f, std::max(0.0f, a2));
 			col3[0] = (unsigned char) (color * alpha);
 			col3[1] = (unsigned char) (color * alpha);
diff -ru spring_89.0/rts/Sim/Projectiles/Unsynced/SpherePartProjectile.cpp /home/svenstaro/src/spring/rts/Sim/Projectiles/Unsynced/SpherePartProjectile.cpp
--- spring_89.0/rts/Sim/Projectiles/Unsynced/SpherePartProjectile.cpp	2012-07-10 00:10:07.000000000 +0200
+++ /home/svenstaro/src/spring/rts/Sim/Projectiles/Unsynced/SpherePartProjectile.cpp	2012-07-13 06:34:43.072727160 +0200
@@ -49,7 +49,7 @@
 		const float yp = (y + ypart) / 16.0f*PI - PI/2;
 		for (int x = 0; x < 5; ++x) {
 			float xp = (x + xpart) / 32.0f*2*PI;
-			vectors[y*5 + x] = float3(sin(xp)*cos(yp), sin(yp), cos(xp)*cos(yp));
+			vectors[y*5 + x] = float3(math::sin(xp)*math::cos(yp), math::sin(yp), math::cos(xp)*math::cos(yp));
 		}
 	}
 	pos = centerPos+vectors[12] * sphereSize;
@@ -86,7 +86,7 @@
 			float alpha =
 				baseAlpha *
 				(1.0f - min(1.0f, float(age + globalRendering->timeOffset) / (float) ttl)) *
-				(1.0f - fabs(y + ybase - 8.0f) / 8.0f * 1.0f);
+				(1.0f - math::fabs(y + ybase - 8.0f) / 8.0f * 1.0f);
 
 			col[0] = (unsigned char) (color.x * 255.0f * alpha);
 			col[1] = (unsigned char) (color.y * 255.0f * alpha);
@@ -94,7 +94,7 @@
 			col[3] = ((unsigned char) (40 * alpha)) + 1;
 			va->AddVertexQTC(centerPos + vectors[y*5 + x]     * interSize, texx, texy, col);
 			va->AddVertexQTC(centerPos + vectors[y*5 + x + 1] * interSize, texx, texy, col);
-			alpha = baseAlpha * (1.0f - min(1.0f, (float)(age + globalRendering->timeOffset) / (float) ttl)) * (1 - fabs(y + 1 + ybase - 8.0f) / 8.0f*1.0f);
+			alpha = baseAlpha * (1.0f - min(1.0f, (float)(age + globalRendering->timeOffset) / (float) ttl)) * (1 - math::fabs(y + 1 + ybase - 8.0f) / 8.0f*1.0f);
 
 			col[0] = (unsigned char) (color.x * 255.0f * alpha);
 			col[1] = (unsigned char) (color.y * 255.0f * alpha);
diff -ru spring_89.0/rts/Sim/Projectiles/Unsynced/WakeProjectile.cpp /home/svenstaro/src/spring/rts/Sim/Projectiles/Unsynced/WakeProjectile.cpp
--- spring_89.0/rts/Sim/Projectiles/Unsynced/WakeProjectile.cpp	2012-07-10 00:10:07.000000000 +0200
+++ /home/svenstaro/src/spring/rts/Sim/Projectiles/Unsynced/WakeProjectile.cpp	2012-07-13 06:34:43.072727160 +0200
@@ -79,7 +79,7 @@
 	float interSize = size + sizeExpansion * globalRendering->timeOffset;
 	float interRot = rotation + rotSpeed * globalRendering->timeOffset;
 
-	const float3 dir1 = float3(cos(interRot), 0, sin(interRot)) * interSize;
+	const float3 dir1 = float3(math::cos(interRot), 0, math::sin(interRot)) * interSize;
 	const float3 dir2 = dir1.cross(UpVector);
 
 	#define wt projectileDrawer->waketex
diff -ru spring_89.0/rts/Sim/Projectiles/WeaponProjectiles/MissileProjectile.cpp /home/svenstaro/src/spring/rts/Sim/Projectiles/WeaponProjectiles/MissileProjectile.cpp
--- spring_89.0/rts/Sim/Projectiles/WeaponProjectiles/MissileProjectile.cpp	2012-07-10 00:10:07.000000000 +0200
+++ /home/svenstaro/src/spring/rts/Sim/Projectiles/WeaponProjectiles/MissileProjectile.cpp	2012-07-13 06:34:43.072727160 +0200
@@ -96,7 +96,7 @@
 	drawRadius = radius + maxSpeed * 8;
 
 	float3 camDir = (pos - camera->pos).ANormalize();
-	if ((camera->pos.distance(pos) * 0.2f + (1 - fabs(camDir.dot(dir))) * 3000) < 200) {
+	if ((camera->pos.distance(pos) * 0.2f + (1 - math::fabs(camDir.dot(dir))) * 3000) < 200) {
 		drawTrail = false;
 	}
 
@@ -229,8 +229,8 @@
 					// is too close or height difference too large)
 					const float horDiff = (targPos - pos).Length2D() + 0.01f;
 					const float verDiff = (targPos.y - pos.y) + 0.01f;
-					const float dirDiff = fabs(targetDir.y - dir.y);
-					const float ratio = fabs(verDiff / horDiff);
+					const float dirDiff = math::fabs(targetDir.y - dir.y);
+					const float ratio = math::fabs(verDiff / horDiff);
 
 					dir.y -= (dirDiff * ratio);
 				} else {
@@ -295,7 +295,7 @@
 		if (!drawTrail) {
 			const float3 camDir = (pos - camera->pos).ANormalize();
 
-			if ((camera->pos.distance(pos) * 0.2f + (1 - fabs(camDir.dot(dir))) * 3000) > 300) {
+			if ((camera->pos.distance(pos) * 0.2f + (1 - math::fabs(camDir.dot(dir))) * 3000) > 300) {
 				drawTrail = true;
 			}
 		}
@@ -343,7 +343,7 @@
 			dir2.ANormalize();
 
 			float a1 = (1.0f / (SMOKE_TIME)) * 255;
-			a1 *= 0.7f + fabs(dif.dot(dir));
+			a1 *= 0.7f + math::fabs(dif.dot(dir));
 			const float alpha1 = std::min(255.0f, std::max(0.0f, a1));
 			col[0] = (unsigned char) (color * alpha1);
 			col[1] = (unsigned char) (color * alpha1);
@@ -357,7 +357,7 @@
 				a2 = 0;
 			}
 
-			a2 *= 0.7f + fabs(dif2.dot(oldDir));
+			a2 *= 0.7f + math::fabs(dif2.dot(oldDir));
 			const float alpha2 = std::min(255.0f, std::max(0.0f, a2));
 			col2[0] = (unsigned char) (color * alpha2);
 			col2[1] = (unsigned char) (color * alpha2);
diff -ru spring_89.0/rts/Sim/Projectiles/WeaponProjectiles/StarburstProjectile.cpp /home/svenstaro/src/spring/rts/Sim/Projectiles/WeaponProjectiles/StarburstProjectile.cpp
--- spring_89.0/rts/Sim/Projectiles/WeaponProjectiles/StarburstProjectile.cpp	2012-07-10 00:10:07.000000000 +0200
+++ /home/svenstaro/src/spring/rts/Sim/Projectiles/WeaponProjectiles/StarburstProjectile.cpp	2012-07-13 06:34:43.072727160 +0200
@@ -90,13 +90,13 @@
 		}
 	}
 
-	maxGoodDif = cos(tracking * 0.6f);
+	maxGoodDif = math::cos(tracking * 0.6f);
 	curSpeed = speed.Length();
 	dir = speed / curSpeed;
 	oldSmokeDir = dir;
 
 	const float3 camDir = (pos - camera->pos).ANormalize();
-	const float camDist = (camera->pos.distance(pos) * 0.2f) + ((1.0f - fabs(camDir.dot(dir))) * 3000);
+	const float camDist = (camera->pos.distance(pos) * 0.2f) + ((1.0f - math::fabs(camDir.dot(dir))) * 3000);
 
 	drawTrail = (camDist >= 200.0f);
 	drawRadius = maxSpeed * 8.0f;
@@ -304,7 +304,7 @@
 
 		if (!drawTrail) {
 			const float3 camDir = (pos - camera->pos).ANormalize();
-			const float camDist = (camera->pos.distance(pos) * 0.2f + (1 - fabs(camDir.dot(dir))) * 3000);
+			const float camDist = (camera->pos.distance(pos) * 0.2f + (1 - math::fabs(camDir.dot(dir))) * 3000);
 
 			drawTrail = (camDist > 300.0f);
 		}
@@ -335,11 +335,11 @@
 
 			const float a1 =
 				((1.0f - (0.0f / SMOKE_TIME)) * 255) *
-				(0.7f + fabs(dif1.dot(dir)));
+				(0.7f + math::fabs(dif1.dot(dir)));
 			const float a2 =
 				(age < 8)? 0.0f:
 				((1.0f - (age2 / SMOKE_TIME)) * 255) *
-				(0.7f + fabs(dif2.dot(oldSmokeDir)));
+				(0.7f + math::fabs(dif2.dot(oldSmokeDir)));
 			const int alpha1 = std::min(255, (int) std::max(0.0f, a1));
 			const int alpha2 = std::min(255, (int) std::max(0.0f, a2));
 
diff -ru spring_89.0/rts/Sim/Projectiles/WeaponProjectiles/WeaponProjectile.cpp /home/svenstaro/src/spring/rts/Sim/Projectiles/WeaponProjectiles/WeaponProjectile.cpp
--- spring_89.0/rts/Sim/Projectiles/WeaponProjectiles/WeaponProjectile.cpp	2012-07-10 00:10:07.000000000 +0200
+++ /home/svenstaro/src/spring/rts/Sim/Projectiles/WeaponProjectiles/WeaponProjectile.cpp	2012-07-13 06:34:43.249393836 +0200
@@ -252,8 +252,8 @@
 				const float dot = speed.dot(normal);
 
 				pos -= speed;
-				speed -= (speed + normal * fabs(dot)) * (1 - weaponDef->bounceSlip);
-				speed += (normal * (fabs(dot))) * (1 + weaponDef->bounceRebound);
+				speed -= (speed + normal * math::fabs(dot)) * (1 - weaponDef->bounceSlip);
+				speed += (normal * (math::fabs(dot))) * (1 + weaponDef->bounceRebound);
 				pos += speed;
 
 				if (weaponDef->bounceExplosionGenerator) {
diff -ru spring_89.0/rts/Sim/Units/CommandAI/MobileCAI.cpp /home/svenstaro/src/spring/rts/Sim/Units/CommandAI/MobileCAI.cpp
--- spring_89.0/rts/Sim/Units/CommandAI/MobileCAI.cpp	2012-07-10 00:10:08.000000000 +0200
+++ /home/svenstaro/src/spring/rts/Sim/Units/CommandAI/MobileCAI.cpp	2012-07-13 06:34:43.079393827 +0200
@@ -770,7 +770,7 @@
 			b2 = w->TryTargetRotate(orderTarget, c.GetID() == CMD_MANUALFIRE);
 			b3 = Square(w->range - (w->relWeaponPos).Length()) > (orderTarget->pos.SqDistance(owner->pos));
 			b4 = w->TryTargetHeading(GetHeadingFromVector(-diff.x, -diff.z), orderTarget->pos, orderTarget != NULL, orderTarget);
-			edgeFactor = fabs(w->targetBorder);
+			edgeFactor = math::fabs(w->targetBorder);
 		}
 
 		const float diffLength2D = diff.Length2D();
diff -ru spring_89.0/rts/Sim/Units/CommandAI/TransportCAI.cpp /home/svenstaro/src/spring/rts/Sim/Units/CommandAI/TransportCAI.cpp
--- spring_89.0/rts/Sim/Units/CommandAI/TransportCAI.cpp	2012-07-10 00:10:08.000000000 +0200
+++ /home/svenstaro/src/spring/rts/Sim/Units/CommandAI/TransportCAI.cpp	2012-07-13 06:34:43.079393827 +0200
@@ -349,7 +349,7 @@
 			if (rx <= spread)
 				continue;
 
-			rx = sqrt(rx);
+			rx = math::sqrt(rx);
 	
 			const float minx = std::max(                               spread,  center.x - rx);
 			const float maxx = std::min(float(gs->mapx * SQUARE_SIZE - spread), center.x + rx);
@@ -676,7 +676,7 @@
 				am->ForceHeading(unloadHeading);
 				am->maxDrift = 1;
 				if ((owner->pos.SqDistance(pos) < 64) &&
-						(owner->updir.dot(UpVector) > 0.99f) && fabs(owner->heading - unloadHeading) < AIRTRANSPORT_DOCKING_ANGLE) {
+						(owner->updir.dot(UpVector) > 0.99f) && math::fabs(owner->heading - unloadHeading) < AIRTRANSPORT_DOCKING_ANGLE) {
 					if (!SpotIsClearIgnoreSelf(pos, unit)) {
 						// chosen spot is no longer clear to land, choose a new one
 						// if a new spot cannot be found, don't unload at all
diff -ru spring_89.0/rts/Sim/Units/UnitDef.cpp /home/svenstaro/src/spring/rts/Sim/Units/UnitDef.cpp
--- spring_89.0/rts/Sim/Units/UnitDef.cpp	2012-07-10 00:10:08.000000000 +0200
+++ /home/svenstaro/src/spring/rts/Sim/Units/UnitDef.cpp	2012-07-13 06:34:43.072727160 +0200
@@ -399,9 +399,9 @@
 	selfDCountdown = udTable.GetInt("selfDestructCountdown", 5);
 
 	speed  = udTable.GetFloat("maxVelocity", 0.0f) * GAME_SPEED;
-	speed  = fabs(speed);
+	speed  = math::fabs(speed);
 	rSpeed = udTable.GetFloat("maxReverseVelocity", 0.0f) * GAME_SPEED;
-	rSpeed = fabs(rSpeed);
+	rSpeed = math::fabs(rSpeed);
 
 	fireState = udTable.GetInt("fireState", canFireControl? FIRESTATE_NONE: FIRESTATE_FIREATWILL);
 	fireState = std::min(fireState, int(FIRESTATE_FIREATWILL));
@@ -462,8 +462,8 @@
 	useSmoothMesh  = udTable.GetBool("useSmoothMesh", true);
 
 
-	maxAcc = fabs(udTable.GetFloat("acceleration", 0.5f)); // no negative values
-	maxDec = fabs(udTable.GetFloat("brakeRate", 3.0f * maxAcc)) * (canfly? 0.1f: 1.0f); // no negative values
+	maxAcc = math::fabs(udTable.GetFloat("acceleration", 0.5f)); // no negative values
+	maxDec = math::fabs(udTable.GetFloat("brakeRate", 3.0f * maxAcc)) * (canfly? 0.1f: 1.0f); // no negative values
 
 	turnRate    = udTable.GetFloat("turnRate", 0.0f);
 	turnInPlace = udTable.GetBool("turnInPlace", true);
@@ -709,7 +709,7 @@
 	seismicSignature = udTable.GetFloat("seismicSignature", -1.0f);
 	if (seismicSignature == -1.0f) {
 		if (!canFloat && !canHover && !canfly) {
-			seismicSignature = sqrt(mass / 100.0f);
+			seismicSignature = math::sqrt(mass / 100.0f);
 		} else {
 			seismicSignature = 0.0f;
 		}
diff -ru spring_89.0/rts/Sim/Units/UnitHandler.cpp /home/svenstaro/src/spring/rts/Sim/Units/UnitHandler.cpp
--- spring_89.0/rts/Sim/Units/UnitHandler.cpp	2012-07-10 00:10:08.000000000 +0200
+++ /home/svenstaro/src/spring/rts/Sim/Units/UnitHandler.cpp	2012-07-13 06:34:43.076060493 +0200
@@ -419,8 +419,8 @@
 		// look for a nearby geothermal feature if we need one
 		for (std::vector<CFeature*>::const_iterator fi = features.begin(); fi != features.end(); ++fi) {
 			if ((*fi)->def->geoThermal
-				&& fabs((*fi)->pos.x - pos.x) < (xsize * 4 - 4)
-				&& fabs((*fi)->pos.z - pos.z) < (zsize * 4 - 4)) {
+				&& math::fabs((*fi)->pos.x - pos.x) < (xsize * 4 - 4)
+				&& math::fabs((*fi)->pos.z - pos.z) < (zsize * 4 - 4)) {
 				canBuild = BUILDSQUARE_OPEN;
 				break;
 			}
@@ -589,7 +589,7 @@
 				BuildInfo bi(cmd);
 				tempF1 = pos + dir * ((bi.pos.y - pos.y) / dir.y) - bi.pos;
 
-				if (bi.def && (bi.GetXSize() / 2) * SQUARE_SIZE > fabs(tempF1.x) && (bi.GetZSize() / 2) * SQUARE_SIZE > fabs(tempF1.z)) {
+				if (bi.def && (bi.GetXSize() / 2) * SQUARE_SIZE > math::fabs(tempF1.x) && (bi.GetZSize() / 2) * SQUARE_SIZE > math::fabs(tempF1.z)) {
 					return cmd;
 				}
 			}
diff -ru spring_89.0/rts/Sim/Weapons/BombDropper.cpp /home/svenstaro/src/spring/rts/Sim/Weapons/BombDropper.cpp
--- spring_89.0/rts/Sim/Weapons/BombDropper.cpp	2012-07-10 00:10:08.000000000 +0200
+++ /home/svenstaro/src/spring/rts/Sim/Weapons/BombDropper.cpp	2012-07-13 06:34:43.072727160 +0200
@@ -62,7 +62,7 @@
 			const float s = -owner->speed.y;
 			const float sq = (s - 2*d) / -((weaponDef->myGravity == 0) ? mapInfo->map.gravity : -(weaponDef->myGravity));
 			if (sq > 0) {
-				predict = s / ((weaponDef->myGravity == 0) ? mapInfo->map.gravity : -(weaponDef->myGravity)) + sqrt(sq);
+				predict = s / ((weaponDef->myGravity == 0) ? mapInfo->map.gravity : -(weaponDef->myGravity)) + math::sqrt(sq);
 			} else {
 				predict = 0;
 			}
diff -ru spring_89.0/rts/Sim/Weapons/Cannon.cpp /home/svenstaro/src/spring/rts/Sim/Weapons/Cannon.cpp
--- spring_89.0/rts/Sim/Weapons/Cannon.cpp	2012-07-10 00:10:08.000000000 +0200
+++ /home/svenstaro/src/spring/rts/Sim/Weapons/Cannon.cpp	2012-07-13 06:34:43.072727160 +0200
@@ -169,7 +169,7 @@
 
 	int ttl = 0;
 	float sqSpeed2D = dir.SqLength2D() * projectileSpeed * projectileSpeed;
-	int predict = (int)ceil((sqSpeed2D == 0) ? (-2 * projectileSpeed * dir.y / gravity)
+	int predict = (int)math::ceil((sqSpeed2D == 0) ? (-2 * projectileSpeed * dir.y / gravity)
 			: math::sqrt(diff.SqLength2D() / sqSpeed2D));
 	if(weaponDef->flighttime > 0) {
 		ttl = weaponDef->flighttime;
@@ -216,9 +216,9 @@
 	// try to cache results, sacrifice some (not much too much even for a pewee) accuracy
 	// it saves a dozen or two expensive calculations per second when 5 guardians
 	// are shooting at several slow- and fast-moving targets
-	if (fabs(diff.x - lastDiff.x) < (SQUARE_SIZE / 4.0f) &&
-		fabs(diff.y - lastDiff.y) < (SQUARE_SIZE / 4.0f) &&
-		fabs(diff.z - lastDiff.z) < (SQUARE_SIZE / 4.0f)) {
+	if (math::fabs(diff.x - lastDiff.x) < (SQUARE_SIZE / 4.0f) &&
+		math::fabs(diff.y - lastDiff.y) < (SQUARE_SIZE / 4.0f) &&
+		math::fabs(diff.z - lastDiff.z) < (SQUARE_SIZE / 4.0f)) {
 		return lastDir;
 	}
 
@@ -237,7 +237,7 @@
 		// FIXME: temporary safeguards against FP overflow
 		// (introduced by extreme off-map unit positions; the term
 		// DFsq * Dsq * ... * dy should never even approach 1e38)
-		if (Dsq < 1e12f && fabs(dy) < 1e6f) {
+		if (Dsq < 1e12f && math::fabs(dy) < 1e6f) {
 			const float root1 = v*v*v*v + 2.0f*v*v*g*dy - g*g*DFsq;
 
 			if (root1 >= 0.0f) {
diff -ru spring_89.0/rts/Sim/Weapons/WeaponDefHandler.cpp /home/svenstaro/src/spring/rts/Sim/Weapons/WeaponDefHandler.cpp
--- spring_89.0/rts/Sim/Weapons/WeaponDefHandler.cpp	2012-07-10 00:10:08.000000000 +0200
+++ /home/svenstaro/src/spring/rts/Sim/Weapons/WeaponDefHandler.cpp	2012-07-13 06:34:43.072727160 +0200
@@ -126,9 +126,9 @@
 
 	// should really be tan but TA seem to cap it somehow
 	// should also be 7fff or ffff theoretically but neither seems good
-	wd.accuracy       = sin((accuracy)       * PI / 0xafff);
-	wd.sprayAngle     = sin((sprayAngle)     * PI / 0xafff);
-	wd.movingAccuracy = sin((movingAccuracy) * PI / 0xafff);
+	wd.accuracy       = math::sin((accuracy)       * PI / 0xafff);
+	wd.sprayAngle     = math::sin((sprayAngle)     * PI / 0xafff);
+	wd.movingAccuracy = math::sin((movingAccuracy) * PI / 0xafff);
 
 	wd.targetMoveError = wdTable.GetFloat("targetMoveError", 0.0f);
 	wd.leadLimit = wdTable.GetFloat("leadLimit", -1.0f);
@@ -375,7 +375,7 @@
 
 
 	const float gd = max(30.0f, wd.damages[0] / 20.0f);
-	const float defExpSpeed = (8.0f + (gd * 2.5f)) / (9.0f + (sqrt(gd) * 0.7f)) * 0.5f;
+	const float defExpSpeed = (8.0f + (gd * 2.5f)) / (9.0f + (math::sqrt(gd) * 0.7f)) * 0.5f;
 	wd.explosionSpeed = wdTable.GetFloat("explosionSpeed", defExpSpeed);
 
 	// Dynamic Damage
@@ -461,7 +461,7 @@
 			wd.hitSound.setVolume(0, 5.0f);
 			wd.hitSound.setVolume(1, 5.0f);
 		} else {
-			float fireSoundVolume = sqrt(wd.damages[0] * 0.5f);
+			float fireSoundVolume = math::sqrt(wd.damages[0] * 0.5f);
 
 			if (wd.type == "LaserCannon") {
 				fireSoundVolume *= 0.5f;
@@ -472,7 +472,7 @@
 			if ((fireSoundVolume > 100.0f) &&
 			    ((wd.type == "MissileLauncher") ||
 			     (wd.type == "StarburstLauncher"))) {
-				fireSoundVolume = 10.0f * sqrt(hitSoundVolume);
+				fireSoundVolume = 10.0f * math::sqrt(hitSoundVolume);
 			}
 
 			if (wd.damageAreaOfEffect > 8.0f) {
@@ -564,7 +564,7 @@
 
 	if (inverted == true) {
 		for(int i = 0; i < damageArrayHandler->GetNumTypes(); ++i) {
-			dynDamages[i] = damages[i] - (1 - pow(1 / range * travDist, exp)) * damages[i];
+			dynDamages[i] = damages[i] - (1 - math::pow(1 / range * travDist, exp)) * damages[i];
 
 			if (damageMin > 0)
 				dynDamages[i] = max(damages[i] * ddmod, dynDamages[i]);
@@ -577,7 +577,7 @@
 	}
 	else {
 		for(int i = 0; i < damageArrayHandler->GetNumTypes(); ++i) {
-			dynDamages[i] = (1 - pow(1 / range * travDist, exp)) * damages[i];
+			dynDamages[i] = (1 - math::pow(1 / range * travDist, exp)) * damages[i];
 
 			if (damageMin > 0)
 				dynDamages[i] = max(damages[i] * ddmod, dynDamages[i]);
diff -ru spring_89.0/rts/System/Matrix44f.cpp /home/svenstaro/src/spring/rts/System/Matrix44f.cpp
--- spring_89.0/rts/System/Matrix44f.cpp	2012-07-10 00:10:08.000000000 +0200
+++ /home/svenstaro/src/spring/rts/System/Matrix44f.cpp	2012-07-13 06:34:43.072727160 +0200
@@ -72,8 +72,8 @@
 
 	*this=Mul(rm);
 */
-	const float sr = sin(rad);
-	const float cr = cos(rad);
+	const float sr = math::sin(rad);
+	const float cr = math::cos(rad);
 
 	float a=m[4];
 	m[4] = cr*a - sr*m[8];
@@ -107,8 +107,8 @@
 
 	*this = Mul(rm);
 */
-	const float sr = sin(rad);
-	const float cr = cos(rad);
+	const float sr = math::sin(rad);
+	const float cr = math::cos(rad);
 
 	float a=m[0];
 	m[0] =  cr*a + sr*m[8];
@@ -142,8 +142,8 @@
 
 	*this = Mul(rm);
 */
-	const float sr = sin(rad);
-	const float cr = cos(rad);
+	const float sr = math::sin(rad);
+	const float cr = math::cos(rad);
 
 	float a=m[0];
 	m[0] = cr*a - sr*m[4];
@@ -165,8 +165,8 @@
 
 void CMatrix44f::Rotate(float rad, const float3& axis)
 {
-	const float sr = sin(rad);
-	const float cr = cos(rad);
+	const float sr = math::sin(rad);
+	const float cr = math::cos(rad);
 
 	for(int a=0;a<3;++a){
 		float3 v(m[a*4],m[a*4+1],m[a*4+2]);
diff -ru spring_89.0/rts/System/myMath.cpp /home/svenstaro/src/spring/rts/System/myMath.cpp
--- spring_89.0/rts/System/myMath.cpp	2012-07-10 00:10:08.000000000 +0200
+++ /home/svenstaro/src/spring/rts/System/myMath.cpp	2012-07-13 06:34:43.072727160 +0200
@@ -44,7 +44,7 @@
 	}
 
 	// Set single precision floating point math.
-	streflop_init<streflop::Simple>();
+	streflop::streflop_init<streflop::Simple>();
 #if defined(__SUPPORT_SNAN__) && !defined(USE_GML)
 	streflop::feraiseexcept(streflop::FPU_Exceptions(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW));
 #endif
@@ -58,7 +58,7 @@
 	#pragma omp parallel
 	{
 		//good_fpu_control_registers("OMP-Init");
-		streflop_init<streflop::Simple>();
+		streflop::streflop_init<streflop::Simple>();
 	#if defined(__SUPPORT_SNAN__) && !defined(USE_GML)
 		streflop::feraiseexcept(streflop::FPU_Exceptions(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW));
 	#endif
@@ -77,8 +77,8 @@
 	for (int a = 0; a < NUM_HEADINGS; ++a) {
 		float ang = (a - (NUM_HEADINGS / 2)) * 2 * PI / NUM_HEADINGS;
 		float2 v;
-			v.x = sin(ang);
-			v.y = cos(ang);
+			v.x = math::sin(ang);
+			v.y = math::cos(ang);
 		headingToVectorTable[a] = v;
 	}
 
@@ -107,9 +107,9 @@
 	float3 ret;
 	float h = heading * TAANG2RAD;
 	float p = pitch * TAANG2RAD;
-	ret.x = sin(h) * cos(p);
-	ret.y = sin(p);
-	ret.z = cos(h) * cos(p);
+	ret.x = math::sin(h) * math::cos(p);
+	ret.y = math::sin(p);
+	ret.z = math::cos(h) * math::cos(p);
 	return ret;
 }
 
@@ -138,7 +138,7 @@
 	float3 dir(l2-l1);
 	float3 pdir(p-l1);
 	float length = dir.Length();
-	if (fabs(length) < 1e-4f)
+	if (math::fabs(length) < 1e-4f)
 		return l1;
 	float c = dir.dot(pdir) / length;
 	if (c < 0) c = 0;
diff -ru spring_89.0/rts/System/Net/Socket.cpp /home/svenstaro/src/spring/rts/System/Net/Socket.cpp
--- spring_89.0/rts/System/Net/Socket.cpp	2012-07-10 00:10:08.000000000 +0200
+++ /home/svenstaro/src/spring/rts/System/Net/Socket.cpp	2012-07-13 06:34:42.939393819 +0200
@@ -73,7 +73,7 @@
 	//! (date of note: 08/05/10)
 	//! something in from_string() is invalidating the FPU flags
 	//! tested on win2k and linux (not happening there)
-	streflop_init<streflop::Simple>();
+	streflop::streflop_init<streflop::Simple>();
 #endif
 
 	return addr;
@@ -94,7 +94,7 @@
 #ifdef STREFLOP_H
 	//! (date of note: 08/22/10)
 	//! something in resolve() is invalidating the FPU flags
-	streflop_init<streflop::Simple>();
+	streflop::streflop_init<streflop::Simple>();
 #endif
 
 	return resolveIt;
diff -ru spring_89.0/rts/System/OffscreenGLContext.cpp /home/svenstaro/src/spring/rts/System/OffscreenGLContext.cpp
--- spring_89.0/rts/System/OffscreenGLContext.cpp	2012-07-10 00:10:08.000000000 +0200
+++ /home/svenstaro/src/spring/rts/System/OffscreenGLContext.cpp	2012-07-13 06:34:42.939393819 +0200
@@ -259,7 +259,7 @@
 #ifdef STREFLOP_H
 	// init streflop to make it available for synced computations, too
 	// redundant? threads copy the FPU state of their parent.
-	streflop_init<streflop::Simple>();
+	streflop::streflop_init<streflop::Simple>();
 #endif
 
 	try {
diff -ru spring_89.0/rts/System/Sound/SoundSource.h /home/svenstaro/src/spring/rts/System/Sound/SoundSource.h
--- spring_89.0/rts/System/Sound/SoundSource.h	2012-07-10 00:10:08.000000000 +0200
+++ /home/svenstaro/src/spring/rts/System/Sound/SoundSource.h	2012-07-13 06:34:42.836060480 +0200
@@ -7,7 +7,6 @@
 
 #include <al.h>
 #include <boost/noncopyable.hpp>
-#include <boost/thread/recursive_mutex.hpp>
 
 class IAudioChannel;
 class float3;
diff -ru spring_89.0/rts/System/SpringApp.cpp /home/svenstaro/src/spring/rts/System/SpringApp.cpp
--- spring_89.0/rts/System/SpringApp.cpp	2012-07-10 00:10:08.000000000 +0200
+++ /home/svenstaro/src/spring/rts/System/SpringApp.cpp	2012-07-13 06:34:42.982727155 +0200
@@ -385,7 +385,7 @@
 #ifdef STREFLOP_H
 	//! Something in SDL_SetVideoMode (OpenGL drivers?) messes with the FPU control word.
 	//! Set single precision floating point math.
-	streflop_init<streflop::Simple>();
+	streflop::streflop_init<streflop::Simple>();
 #endif
 
 	//! setup GL smoothing
@@ -1009,7 +1009,7 @@
 			SDL_Event event;
 
 			while (SDL_PollEvent(&event)) {
-				streflop_init<streflop::Simple>(); // SDL_PollEvent may modify FPU flags
+				streflop::streflop_init<streflop::Simple>(); // SDL_PollEvent may modify FPU flags
 				input.PushEvent(event);
 			}
 		}
diff -ru spring_89.0/rts/System/Sync/FPUCheck.cpp /home/svenstaro/src/spring/rts/System/Sync/FPUCheck.cpp
--- spring_89.0/rts/System/Sync/FPUCheck.cpp	2012-07-10 00:10:08.000000000 +0200
+++ /home/svenstaro/src/spring/rts/System/Sync/FPUCheck.cpp	2012-07-13 06:34:42.939393819 +0200
@@ -85,7 +85,7 @@
 		LOG_L(L_WARNING, "[%s] Sync warning: (env.x87_mode) FPUCW 0x%04X instead of 0x%04X or 0x%04X (\"%s\")", __FUNCTION__, fenv.x87_mode, x87_a, x87_b, text);
 
 		// Set single precision floating point math.
-		streflop_init<streflop::Simple>();
+		streflop::streflop_init<streflop::Simple>();
 	#if defined(__SUPPORT_SNAN__) && !defined(USE_GML)
 		streflop::feraiseexcept(streflop::FPU_Exceptions(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW));
 	#endif
