From d8092a1c3ee2183e086312269d0224bf5ffded5e Mon Sep 17 00:00:00 2001
From: Thomas Koch <linrunner@gmx.net>
Date: Mon, 13 Jul 2015 22:05:32 +0200
Subject: [PATCH 1/2] Issues #147, #149: fix udev event processing for AC/BAT
 switching

Background: systemd-udevd version 221 now kills forked processes
when the main process (called by RUN=) terminates and stdout/
stderr have been closed. First occurred on Arch Linux.

Consequences:
TLP's technique to fork udev event processing in a subshell fails
and the code applying the settings is aborted prematurely.

In case of tlp-usb-udev removing the subshell is not an option,
because it would remove the ability to concurrently populate
the subdevices tree and thus incapacitate the driver blacklisting
feature.

Solution:
- Remove subshell forking for AC/BAT switching in tlp
- Do not close stdout/stdin in tlp-usb-udev subshell to prevent
  being killed by udev post-processing
- Reduce wait for subdevices populating in tlp-usb-udev
---
 tlp          | 11 +++--------
 tlp-usb-udev | 62 ++++++++++++++++++++++++++++++++----------------------------
 2 files changed, 36 insertions(+), 37 deletions(-)

diff --git a/tlp b/tlp
index 9f41611..c7c9f12 100755
--- a/tlp
+++ b/tlp
@@ -139,14 +139,9 @@ case "$mode" in
 
     auto) # set mode depending on state (called by udev rule)
         check_root
-        ( # run in a detached subshell to avoid blocking udev,
-          # close stdout/stderr
-            exec 1> /dev/null 2>/dev/null
-
-            apply_common_settings $pwrmode
-            [ "$pwrmode" = "1" ] && poweroff_drivebay 0
-            set_radio_device_states $pwrmode
-        ) &
+        apply_common_settings $pwrmode
+        [ "$pwrmode" = "1" ] && poweroff_drivebay 0
+        set_radio_device_states $pwrmode
         ;;
 
     start) # set mode depending on state (interactive mode)
diff --git a/tlp-usb-udev b/tlp-usb-udev
index c31a686..f3b8546 100755
--- a/tlp-usb-udev
+++ b/tlp-usb-udev
@@ -71,22 +71,9 @@ usbdev=/sys$1
 if [ -f $usbdev/power/autosuspend ] || [ -f $usbdev/power/autosuspend_delay_ms ]; then
     # device is autosuspendable
 
-    ( # run remainder in a detached subshell to avoid blocking udev,
-      # close stdout/stderr
-        exec 1> /dev/null 2>/dev/null
-
-        # initialize driver blacklist from settings
-        drv_bl=${USB_DRIVER_BLACKLIST:-$DEFAULT_USB_DRIVER_BLACKLIST}
-
-        # add wwan driver blacklist if enabled
-        USB_BLACKLIST_WWAN=${USB_BLACKLIST_WWAN:-1} # default is exclude
-
-        if [ $USB_BLACKLIST_WWAN = "1" ]; then
-            drv_bl="$drv_bl $USB_WWAN_DRIVERS"
-        fi
-
-        # wait for subdevices to populate via parallel udev events (not handled here)
-        sleep 2.0
+    (   # run remainder in a detached subshell to allow udev to populate
+        # subdevices in parallel; do *not* close stdin/stdout to avoid
+        # being "sanitized" (killed) by udev post-processing
 
         # apply autosuspend
         ctrlf="control"
@@ -105,19 +92,36 @@ if [ -f $usbdev/power/autosuspend ] || [ -f $usbdev/power/autosuspend_delay_ms ]
             control="on"
             exc="_dev_black"
         else
-            # check subdevices for blacklisted drivers
-            for subdev in $usbdev/*:*; do
-                # get driver name from subdev uevent file
-                drv=$(sed -rn 's/^DRIVER=(.*)/\1/p' $subdev/uevent)
-
-                # check against driver blacklist
-                if wordinlist "$drv" "$drv_bl"; then
-                    # driver is blacklisted
-                    control="on"
-                    exc="_drv_black"
-                    break
-                fi
-            done
+            # initialize driver blacklist from settings
+            drv_bl=${USB_DRIVER_BLACKLIST:-$DEFAULT_USB_DRIVER_BLACKLIST}
+
+            # add wwan driver blacklist if enabled
+            USB_BLACKLIST_WWAN=${USB_BLACKLIST_WWAN:-1} # default is exclude
+            if [ $USB_BLACKLIST_WWAN = "1" ]; then
+                drv_bl="$drv_bl $USB_WWAN_DRIVERS"
+            fi
+
+            if [ -n "$drv_bl" ]; then
+                # proceed only when driver blacklist is not empty
+
+                # wait for subdevices to populate via parallel udev events
+                # (not handled here)
+                sleep 0.5
+
+                # check subdevices for blacklisted drivers
+                for subdev in $usbdev/*:*; do
+                    # get driver name from subdev uevent file
+                    drv=$(sed -rn 's/^DRIVER=(.*)/\1/p' $subdev/uevent)
+
+                    # check against driver blacklist
+                    if wordinlist "$drv" "$drv_bl"; then
+                        # driver is blacklisted
+                        control="on"
+                        exc="_drv_black"
+                        break
+                    fi
+                done
+            fi
         fi
 
         if [ -f $usbdev/power/control ]; then
-- 
1.9.1

