diff -wbBur /home/sergej/community-my.svn/haskell-gtk/trunk/src/gtk-0.12.3.1/Graphics/UI/Gtk/Abstract/Object.chs gtk/Graphics/UI/Gtk/Abstract/Object.chs
--- /home/sergej/community-my.svn/haskell-gtk/trunk/src/gtk-0.12.3.1/Graphics/UI/Gtk/Abstract/Object.chs	2012-06-18 01:39:34.000000000 +0400
+++ gtk/Graphics/UI/Gtk/Abstract/Object.chs	2012-10-02 16:30:54.000000000 +0400
@@ -126,7 +126,8 @@
 
 {#pointer GWeakNotify#}
 
-foreign import ccall "wrapper" mkDestructor :: IO () -> IO GWeakNotify
+foreign import ccall "wrapper" mkDestructor
+  :: (Ptr () -> Ptr GObject -> IO ()) -> IO GWeakNotify
 
 -- | Attach a callback that will be called after the
 -- destroy hooks have been called
@@ -134,7 +135,7 @@
 objectWeakref :: ObjectClass o => o -> IO () -> IO GWeakNotify
 objectWeakref obj uFun = do
   funPtrContainer <- newIORef nullFunPtr
-  uFunPtr <- mkDestructor $ do
+  uFunPtr <- mkDestructor $ \_ _ -> do
     uFun
     funPtr <- readIORef funPtrContainer
     freeHaskellFunPtr funPtr
diff -wbBur /home/sergej/community-my.svn/haskell-gtk/trunk/src/gtk-0.12.3.1/Graphics/UI/Gtk/Entry/Entry.chs gtk/Graphics/UI/Gtk/Entry/Entry.chs
--- /home/sergej/community-my.svn/haskell-gtk/trunk/src/gtk-0.12.3.1/Graphics/UI/Gtk/Entry/Entry.chs	2012-06-18 01:39:34.000000000 +0400
+++ gtk/Graphics/UI/Gtk/Entry/Entry.chs	2012-10-02 16:27:26.000000000 +0400
@@ -78,6 +78,10 @@
   entrySetCompletion,
   entryGetCompletion,
 #endif
+#if GTK_CHECK_VERSION (2,18,0)
+  entryGetBuffer,
+  entrySetBuffer,
+#endif
 #if GTK_CHECK_VERSION(2,20,0)
   entryGetIconWindow,
   entryGetTextWindow,
@@ -104,6 +108,9 @@
   entryAlignment,
   entryCompletion,
 #endif
+#if GTK_CHECK_VERSION (2,18,0)
+  entryBuffer,
+#endif
 
 -- * Signals
   entryActivate,
@@ -157,6 +164,9 @@
 import Graphics.UI.Gtk.Gdk.EventM	(EventM, EButton, EKey)
 import Control.Monad.Reader             ( ask )
 import Control.Monad.Trans              ( liftIO )
+#if GTK_CHECK_VERSION (2,18,0)
+import Graphics.UI.Gtk.Entry.EntryBuffer
+#endif
 {#import Graphics.UI.Gtk.Types#}
 {#import Graphics.UI.Gtk.Signals#}
 
@@ -429,6 +439,23 @@
     (toEntry self)
 #endif
 
+#if GTK_CHECK_VERSION(2,18,0)
+-- | Get the 'EntryBuffer' object which holds the text for this widget.
+entryGetBuffer :: EntryClass self => self
+  -> IO EntryBuffer
+entryGetBuffer self =
+  makeNewGObject mkEntryBuffer $
+  {# call gtk_entry_get_buffer #}
+    (toEntry self)
+
+-- | Set the 'EntryBuffer' object which holds the text for this widget.
+entrySetBuffer :: (EntryClass self, EntryBufferClass buffer) => self
+  -> buffer -> IO ()
+entrySetBuffer self =
+  {# call gtk_entry_set_buffer #}
+    (toEntry self) . toEntryBuffer
+#endif
+
 #if GTK_CHECK_VERSION(2,20,0)
 -- | Returns the 'Window' which contains the entry's icon at @iconPos@. This function is useful when
 -- drawing something to the entry in an 'eventExpose' callback because it enables the callback to
@@ -623,6 +650,15 @@
   entrySetCompletion
 #endif
 
+#if GTK_CHECK_VERSION(2,18,0)
+entryBuffer :: (EntryClass self, EntryBufferClass buffer) =>
+  ReadWriteAttr self EntryBuffer buffer
+entryBuffer = newAttr
+  entryGetBuffer
+  entrySetBuffer
+#endif
+
+
 --------------------
 -- Signals
 
diff -wbBur /home/sergej/community-my.svn/haskell-gtk/trunk/src/gtk-0.12.3.1/Graphics/UI/Gtk/Gdk/EventM.hsc gtk/Graphics/UI/Gtk/Gdk/EventM.hsc
--- /home/sergej/community-my.svn/haskell-gtk/trunk/src/gtk-0.12.3.1/Graphics/UI/Gtk/Gdk/EventM.hsc	2012-06-18 01:39:34.000000000 +0400
+++ gtk/Graphics/UI/Gtk/Gdk/EventM.hsc	2012-10-02 16:27:27.000000000 +0400
@@ -639,14 +639,16 @@
 
 
 -- | Execute an event handler and assume it handled the event unless it
---   threw a pattern match exception.
+--   threw a pattern match exception or calls mzero (e.g. via guard).
 tryEvent :: EventM any () -> EventM any Bool
 tryEvent act = do
   ptr <- ask
   liftIO $ (runReaderT (act >> return True) ptr)
 #if __GLASGOW_HASKELL__ >= 610
     `catches` [ Handler (\ (PatternMatchFail _) -> return False)
-              , Handler (\ e -> if isUserError e && "Pattern" `isPrefixOf` ioeGetErrorString e
+              , Handler (\ e -> if isUserError e &&
+                                   ("Pattern" `isPrefixOf` ioeGetErrorString e ||
+                                    "mzero" == ioeGetErrorString e)
                                 then return False
                                 else throw e) ]
 #else
@@ -654,6 +656,8 @@
                IOException e
                  | "user error (Pattern" `isPrefixOf` show e ->
                    return False
+                 | "user error (mzero" `isPrefixOf` show e ->
+                   return False
                PatternMatchFail _ -> return False
                _ -> throw e)
 #endif
diff -wbBur /home/sergej/community-my.svn/haskell-gtk/trunk/src/gtk-0.12.3.1/Graphics/UI/Gtk/Gdk/Pixbuf.chs gtk/Graphics/UI/Gtk/Gdk/Pixbuf.chs
--- /home/sergej/community-my.svn/haskell-gtk/trunk/src/gtk-0.12.3.1/Graphics/UI/Gtk/Gdk/Pixbuf.chs	2012-06-18 01:39:34.000000000 +0400
+++ gtk/Graphics/UI/Gtk/Gdk/Pixbuf.chs	2012-10-02 16:27:28.000000000 +0400
@@ -69,6 +69,7 @@
 
 -- * Constructors
   pixbufNew,
+  pixbufNewFromData,
   pixbufNewFromFile,
 #if GTK_CHECK_VERSION(2,4,0)
   pixbufNewFromFileAtSize,
@@ -402,6 +403,19 @@
       (fromBool hasAlpha) (fromIntegral bitsPerSample) (fromIntegral width)
       (fromIntegral height)
 
+pixbufNewFromData :: Ptr CUChar -> Colorspace -> Bool -> Int -> Int -> Int -> Int -> IO Pixbuf
+pixbufNewFromData imData cSpace hasAlpha bitsPerSample width height rowStride
+  = wrapNewGObject mkPixbuf $
+     {#call pixbuf_new_from_data #}
+       imData
+       (fromIntegral . fromEnum $ cSpace)
+       (fromBool hasAlpha)
+       (fromIntegral bitsPerSample)
+       (fromIntegral width)
+       (fromIntegral height)
+       (fromIntegral rowStride)
+       nullFunPtr nullPtr
+
 -- | Create a new image from a String.
 --
 -- * Creates a new pixbuf from a string description.
diff -wbBur /home/sergej/community-my.svn/haskell-gtk/trunk/src/gtk-0.12.3.1/Graphics/UI/Gtk/General/Clipboard.chs gtk/Graphics/UI/Gtk/General/Clipboard.chs
--- /home/sergej/community-my.svn/haskell-gtk/trunk/src/gtk-0.12.3.1/Graphics/UI/Gtk/General/Clipboard.chs	2012-06-18 01:39:34.000000000 +0400
+++ gtk/Graphics/UI/Gtk/General/Clipboard.chs	2012-10-02 16:30:54.000000000 +0400
@@ -260,7 +260,7 @@
                               -- data succeeded.
 clipboardSetWithData self targets getFunc clearFunc = do
   gFunPtr <- mkClipboardGetFunc
-    (\_ sPtr info -> runReaderT (getFunc info) sPtr >> return ())
+    (\_ sPtr info _ -> runReaderT (getFunc info) sPtr >> return ())
   cFunPtr <- mkClipboardClearFunc
     (\_ _ -> clearFunc)
   res <- withTargetEntries targets $ \nTargets targets ->
@@ -282,7 +282,7 @@
 {#pointer ClipboardClearFunc#}
 
 foreign import ccall "wrapper" mkClipboardGetFunc ::
-  (Ptr Clipboard -> Ptr () -> {#type guint#} -> IO ()) -> IO ClipboardGetFunc
+  (Ptr Clipboard -> Ptr () -> {#type guint#} -> Ptr () -> IO ()) -> IO ClipboardGetFunc
 
 foreign import ccall "wrapper" mkClipboardClearFunc ::
   (Ptr Clipboard -> Ptr () -> IO ()) -> IO ClipboardClearFunc
@@ -313,7 +313,7 @@
                               -- ignored.
 clipboardSetWithOwner self targets getFunc clearFunc owner = do
   gFunPtr <- mkClipboardGetFunc
-    (\_ sPtr info -> runReaderT (getFunc info) sPtr >> return ())
+    (\_ sPtr info _ -> runReaderT (getFunc info) sPtr >> return ())
   cFunPtr <- mkClipboardClearFunc
     (\_ _ -> clearFunc)
   res <- withTargetEntries targets $ \nTargets targets ->
@@ -404,7 +404,7 @@
 clipboardRequestContents self (Atom target) callback = do
   cbRef <- newIORef nullFunPtr
   cbPtr <- mkClipboardReceivedFunc
-    (\_ sPtr -> do
+    (\_ sPtr _ -> do
       freeHaskellFunPtr =<< readIORef cbRef
       runReaderT callback sPtr
       return ())
@@ -418,7 +418,7 @@
 {#pointer ClipboardReceivedFunc#}
 
 foreign import ccall "wrapper" mkClipboardReceivedFunc ::
-  (Ptr Clipboard -> Ptr () -> IO ()) -> IO ClipboardReceivedFunc
+  (Ptr Clipboard -> Ptr () -> Ptr () -> IO ()) -> IO ClipboardReceivedFunc
 
 -- %hash c:7bb1 d:4ef1
 -- | Requests the contents of the clipboard as text. When the text is later
@@ -439,7 +439,7 @@
 clipboardRequestText self callback = do
   cbRef <- newIORef nullFunPtr
   cbPtr <- mkClipboardTextReceivedFunc
-    (\_ sPtr -> do
+    (\_ sPtr _ -> do
       freeHaskellFunPtr =<< readIORef cbRef
       mStr <- if sPtr==nullPtr then return Nothing else
         liftM Just $ peekUTFString sPtr
@@ -453,7 +453,7 @@
 {#pointer ClipboardTextReceivedFunc#}
 
 foreign import ccall "wrapper" mkClipboardTextReceivedFunc ::
-  (Ptr Clipboard -> CString -> IO ()) -> IO ClipboardTextReceivedFunc
+  (Ptr Clipboard -> CString -> Ptr () -> IO ()) -> IO ClipboardTextReceivedFunc
 
 
 #if GTK_CHECK_VERSION(2,6,0)
@@ -477,7 +477,7 @@
 clipboardRequestImage self callback = do
   cbRef <- newIORef nullFunPtr
   cbPtr <- mkClipboardImageReceivedFunc
-    (\_ sPtr -> do
+    (\_ sPtr _ -> do
       freeHaskellFunPtr =<< readIORef cbRef
       mPixbuf <- maybeNull (makeNewGObject mkPixbuf) (return sPtr)
       callback mPixbuf)
@@ -490,7 +490,7 @@
 {#pointer ClipboardImageReceivedFunc#}
 
 foreign import ccall "wrapper" mkClipboardImageReceivedFunc ::
-  (Ptr Clipboard -> Ptr Pixbuf -> IO ()) -> IO ClipboardImageReceivedFunc
+  (Ptr Clipboard -> Ptr Pixbuf -> Ptr () -> IO ()) -> IO ClipboardImageReceivedFunc
 
 #endif
 
@@ -513,7 +513,7 @@
 clipboardRequestTargets self callback = do
   cbRef <- newIORef nullFunPtr
   cbPtr <- mkClipboardTargetsReceivedFunc
-    (\_ tPtr len -> do
+    (\_ tPtr len _ -> do
       -- We must free Haskell pointer *in* the callback to avoid segfault.
       freeHaskellFunPtr =<< readIORef cbRef
       mTargets <- if tPtr==nullPtr then return Nothing else
@@ -528,7 +528,7 @@
 {#pointer ClipboardTargetsReceivedFunc#}
 
 foreign import ccall "wrapper" mkClipboardTargetsReceivedFunc ::
-  (Ptr Clipboard -> Ptr (Ptr ()) -> {#type gint#} -> IO ()) -> IO ClipboardTargetsReceivedFunc
+  (Ptr Clipboard -> Ptr (Ptr ()) -> {#type gint#} -> Ptr () -> IO ()) -> IO ClipboardTargetsReceivedFunc
 
 #if GTK_CHECK_VERSION(2,10,0)
 -- %hash c:5601 d:d6a6
@@ -552,10 +552,10 @@
 clipboardRequestRichText self buffer callback = do
   cbRef <- newIORef nullFunPtr
   cbPtr <- mkClipboardRichTextReceivedFunc
-    (\_ tPtr sPtr len -> do
+    (\_ tPtr sPtr len _ -> do
       freeHaskellFunPtr =<< readIORef cbRef
       mRes <- if sPtr==nullPtr then return Nothing else liftM Just $ do
-        str <- peekUTFStringLen (sPtr,fromIntegral len)
+        str <- peekUTFStringLen (castPtr sPtr,fromIntegral len)
         return (Atom tPtr, str)
       callback mRes)
   writeIORef cbRef cbPtr
@@ -568,7 +568,7 @@
 {#pointer ClipboardRichTextReceivedFunc#}
 
 foreign import ccall "wrapper" mkClipboardRichTextReceivedFunc ::
-  (Ptr Clipboard -> Ptr () -> CString -> {#type gsize#} -> IO ()) ->
+  (Ptr Clipboard -> Ptr () -> Ptr CUChar -> {#type gsize#} -> Ptr () -> IO ()) ->
   IO ClipboardRichTextReceivedFunc
 #endif
 #endif
diff -wbBur /home/sergej/community-my.svn/haskell-gtk/trunk/src/gtk-0.12.3.1/Graphics/UI/Gtk/General/General.chs gtk/Graphics/UI/Gtk/General/General.chs
--- /home/sergej/community-my.svn/haskell-gtk/trunk/src/gtk-0.12.3.1/Graphics/UI/Gtk/General/General.chs	2012-06-18 01:39:34.000000000 +0400
+++ gtk/Graphics/UI/Gtk/General/General.chs	2012-10-02 16:27:28.000000000 +0400
@@ -202,7 +202,7 @@
 --   their arguments from the main loop, that is, from the OS thread of Gtk,
 --   thereby ensuring that any Gtk and OS function can be called.
 --
-{#fun unsafe gdk_threads_enter as threadsEnter {} -> `()' #}
+{#fun gdk_threads_enter as threadsEnter {} -> `()' #}
 
 -- | Release the global Gtk lock.
 --
diff -wbBur /home/sergej/community-my.svn/haskell-gtk/trunk/src/gtk-0.12.3.1/Graphics/UI/Gtk/MenuComboToolbar/ComboBox.chs gtk/Graphics/UI/Gtk/MenuComboToolbar/ComboBox.chs
--- /home/sergej/community-my.svn/haskell-gtk/trunk/src/gtk-0.12.3.1/Graphics/UI/Gtk/MenuComboToolbar/ComboBox.chs	2012-06-18 01:39:34.000000000 +0400
+++ gtk/Graphics/UI/Gtk/MenuComboToolbar/ComboBox.chs	2012-10-02 16:30:54.000000000 +0400
@@ -493,17 +493,17 @@
   {# call gtk_combo_box_set_row_separator_func #}
     (toComboBox self) nullFunPtr nullPtr nullFunPtr
 comboBoxSetRowSeparatorSource self (Just (model, extract)) = do
-  funPtr <- mkRowSeparatorFunc $ \_ iterPtr -> do
+  funPtr <- mkRowSeparatorFunc $ \_ iterPtr _ -> do
         iter <- peek iterPtr
         value <- customStoreGetRow model iter
-        return (extract value)
+        return (fromBool $ extract value)
   {# call gtk_combo_box_set_row_separator_func #}
     (toComboBox self) funPtr (castFunPtrToPtr funPtr) destroyFunPtr
 
 {#pointer TreeViewRowSeparatorFunc#}
 
 foreign import ccall "wrapper" mkRowSeparatorFunc ::
-  (Ptr TreeModel -> Ptr TreeIter -> IO Bool) -> IO TreeViewRowSeparatorFunc
+  (Ptr TreeModel -> Ptr TreeIter -> Ptr () -> IO {#type gboolean #}) -> IO TreeViewRowSeparatorFunc
 
 -- %hash c:5bf8
 -- | Sets whether the popup menu should have a tearoff menu item.
diff -wbBur /home/sergej/community-my.svn/haskell-gtk/trunk/src/gtk-0.12.3.1/Graphics/UI/Gtk/MenuComboToolbar/MenuItem.chs gtk/Graphics/UI/Gtk/MenuComboToolbar/MenuItem.chs
--- /home/sergej/community-my.svn/haskell-gtk/trunk/src/gtk-0.12.3.1/Graphics/UI/Gtk/MenuComboToolbar/MenuItem.chs	2012-06-18 01:39:34.000000000 +0400
+++ gtk/Graphics/UI/Gtk/MenuComboToolbar/MenuItem.chs	2012-10-02 16:27:30.000000000 +0400
@@ -76,6 +76,12 @@
   menuItemNewWithMnemonic,
 
 -- * Methods
+#if GTK_CHECK_VERSION(2,16,0)
+  menuItemSetLabel,
+  menuItemGetLabel,
+  menuItemSetUseUnderline,
+  menuItemGetUseUnderline,
+#endif
   menuItemSetSubmenu,
   menuItemGetSubmenu,
   menuItemRemoveSubmenu,
@@ -89,6 +95,10 @@
 -- * Attributes
   menuItemSubmenu,
   menuItemRightJustified,
+#if GTK_CHECK_VERSION(2,16,0)
+  menuItemLabel,
+  menuItemUseUnderline,
+#endif
 
 -- * Signals
   menuItemActivateItem,
@@ -163,7 +173,36 @@
 
 --------------------
 -- Methods
+#if GTK_CHECK_VERSION(2,16,0)
+-- | Sets text on the MenuItem label
+
+menuItemSetLabel :: (MenuItemClass self) => self -> String -> IO ()
+menuItemSetLabel self label =
+  withUTFString label $ {# call gtk_menu_item_set_label #} (toMenuItem self)
+
+-- | Gets text on the MenuItem label
+menuItemGetLabel :: (MenuItemClass self) => self -> IO String
+menuItemGetLabel self =
+  {# call gtk_menu_item_get_label #}
+    (toMenuItem self)
+  >>= \strPtr -> if strPtr == nullPtr
+                   then return ""
+                   else peekUTFString strPtr
+
+-- | If True, an underline in the text indicates the next character should be used for the mnemonic accelerator key.
+--
+menuItemSetUseUnderline :: (MenuItemClass self) => self -> Bool -> IO ()
+menuItemSetUseUnderline self =
+  {# call gtk_menu_item_set_use_underline #} (toMenuItem self) . fromBool
 
+-- | Checks if an underline in the text indicates the next character should be used for the mnemonic accelerator key.
+--
+menuItemGetUseUnderline :: (MenuItemClass self) => self -> IO Bool
+menuItemGetUseUnderline self =
+  liftM toBool $ {# call gtk_menu_item_get_use_underline #}
+    (toMenuItem self)
+
+#endif
 -- | Sets the item's submenu, or changes it.
 --
 menuItemSetSubmenu :: (MenuItemClass self, MenuClass submenu) => self -> submenu -> IO ()
@@ -278,6 +317,22 @@
   menuItemGetRightJustified
   menuItemSetRightJustified
 
+#if GTK_CHECK_VERSION(2,16,0)
+-- | \'label\' property. See 'menuItemSetLabel' and 'menuItemGetLabel'
+--
+menuItemLabel :: MenuItemClass self => Attr self String
+menuItemLabel = newAttr
+  menuItemGetLabel
+  menuItemSetLabel
+
+-- | \'useUnderline\' property. See 'menuItemSetUseUnderline' and 
+-- 'menuItemGetUseEUnderline'
+--
+menuItemUseUnderline :: MenuItemClass self => Attr self Bool
+menuItemUseUnderline = newAttr
+  menuItemGetUseUnderline
+  menuItemSetUseUnderline
+#endif
 --------------------
 -- Signals
 
diff -wbBur /home/sergej/community-my.svn/haskell-gtk/trunk/src/gtk-0.12.3.1/Graphics/UI/Gtk/ModelView/CustomStore.chs gtk/Graphics/UI/Gtk/ModelView/CustomStore.chs
--- /home/sergej/community-my.svn/haskell-gtk/trunk/src/gtk-0.12.3.1/Graphics/UI/Gtk/ModelView/CustomStore.chs	2012-06-18 01:39:34.000000000 +0400
+++ gtk/Graphics/UI/Gtk/ModelView/CustomStore.chs	2012-10-02 16:27:33.000000000 +0400
@@ -239,7 +239,7 @@
         customTreeDragSourceIface = fromMaybe dummyDragSource mDragSource,
         customTreeDragDestIface = fromMaybe dummyDragDest mDragDest }
   privPtr <- newStablePtr priv
-  liftM con $ makeNewGObject (CustomStore, objectUnref) $
+  liftM con $ wrapNewGObject (CustomStore, objectUnref) $
     gtk2hs_store_new implPtr privPtr
 
 foreign import ccall unsafe "Gtk2HsStore.h gtk2hs_store_new"
diff -wbBur /home/sergej/community-my.svn/haskell-gtk/trunk/src/gtk-0.12.3.1/Graphics/UI/Gtk/ModelView/TreeModel.chs gtk/Graphics/UI/Gtk/ModelView/TreeModel.chs
--- /home/sergej/community-my.svn/haskell-gtk/trunk/src/gtk-0.12.3.1/Graphics/UI/Gtk/ModelView/TreeModel.chs	2012-06-18 01:39:34.000000000 +0400
+++ gtk/Graphics/UI/Gtk/ModelView/TreeModel.chs	2012-10-02 16:30:54.000000000 +0400
@@ -427,7 +427,7 @@
 {#pointer TreeModelForeachFunc#}
 
 foreign import ccall "wrapper"  mkTreeModelForeachFunc ::
-  (Ptr () -> Ptr () -> Ptr TreeIter -> Ptr () -> IO CInt) ->
+  (Ptr TreeModel -> Ptr NativeTreePath -> Ptr TreeIter -> Ptr () -> IO CInt) ->
   IO TreeModelForeachFunc
 
 #if GTK_CHECK_VERSION(2,2,0)
diff -wbBur /home/sergej/community-my.svn/haskell-gtk/trunk/src/gtk-0.12.3.1/Graphics/UI/Gtk/ModelView/TreeModelFilter.chs gtk/Graphics/UI/Gtk/ModelView/TreeModelFilter.chs
--- /home/sergej/community-my.svn/haskell-gtk/trunk/src/gtk-0.12.3.1/Graphics/UI/Gtk/ModelView/TreeModelFilter.chs	2012-06-18 01:39:34.000000000 +0400
+++ gtk/Graphics/UI/Gtk/ModelView/TreeModelFilter.chs	2012-10-02 16:30:54.000000000 +0400
@@ -160,7 +160,7 @@
 {#pointer TreeModelFilterVisibleFunc #}
 
 foreign import ccall "wrapper" mkTreeModelFilterVisibleFunc ::
-  (Ptr TreeModelFilter -> Ptr TreeIter -> Ptr () -> IO {#type gboolean#}) ->
+  (Ptr TreeModel -> Ptr TreeIter -> Ptr () -> IO {#type gboolean#}) ->
   IO TreeModelFilterVisibleFunc
 
 -- %hash c:a56d d:b42e
diff -wbBur /home/sergej/community-my.svn/haskell-gtk/trunk/src/gtk-0.12.3.1/Graphics/UI/Gtk/ModelView/TreeSelection.chs gtk/Graphics/UI/Gtk/ModelView/TreeSelection.chs
--- /home/sergej/community-my.svn/haskell-gtk/trunk/src/gtk-0.12.3.1/Graphics/UI/Gtk/ModelView/TreeSelection.chs	2012-06-18 01:39:34.000000000 +0400
+++ gtk/Graphics/UI/Gtk/ModelView/TreeSelection.chs	2012-10-02 16:30:54.000000000 +0400
@@ -151,7 +151,7 @@
 treeSelectionSetSelectFunction :: TreeSelectionClass self => self
  -> TreeSelectionCB -> IO ()
 treeSelectionSetSelectFunction ts fun = do
-  fPtr <- mkTreeSelectionFunc (\_ _ tp _ -> do
+  fPtr <- mkTreeSelectionFunc (\_ _ tp _ _ -> do
     path <- peekTreePath (castPtr tp)
     liftM fromBool $ fun path
     )
@@ -168,7 +168,7 @@
 {#pointer TreeSelectionFunc#}
 
 foreign import ccall "wrapper"  mkTreeSelectionFunc ::
-  (Ptr () -> Ptr () -> Ptr TreePath -> Ptr () -> IO CInt)->
+  (Ptr TreeSelection -> Ptr TreeModel -> Ptr NativeTreePath -> {#type gint#} -> Ptr () -> IO CInt)->
   IO TreeSelectionFunc
 
 -- | Retrieve the 'TreeView' widget that this 'TreeSelection' works on.
@@ -199,7 +199,7 @@
  -> TreeSelectionForeachCB
  -> IO ()
 treeSelectionSelectedForeach self fun = do
-  fPtr <- mkTreeSelectionForeachFunc (\_ _ iterPtr -> do
+  fPtr <- mkTreeSelectionForeachFunc (\_ _ iterPtr _ -> do
     -- make a deep copy of the iterator. This makes it possible to store this
     -- iterator in Haskell land somewhere. The TreeModel parameter is not
     -- passed to the function due to performance reasons. But since it is
@@ -219,7 +219,7 @@
 {#pointer TreeSelectionForeachFunc#}
 
 foreign import ccall "wrapper"  mkTreeSelectionForeachFunc ::
-  (Ptr () -> Ptr () -> Ptr TreeIter -> IO ()) -> IO TreeSelectionForeachFunc
+  (Ptr TreeModel -> Ptr NativeTreePath -> Ptr TreeIter -> Ptr () -> IO ()) -> IO TreeSelectionForeachFunc
 
 #if GTK_CHECK_VERSION(2,2,0)
 -- | Creates a list of paths of all selected rows.
diff -wbBur /home/sergej/community-my.svn/haskell-gtk/trunk/src/gtk-0.12.3.1/Graphics/UI/Gtk/ModelView/TreeView.chs gtk/Graphics/UI/Gtk/ModelView/TreeView.chs
--- /home/sergej/community-my.svn/haskell-gtk/trunk/src/gtk-0.12.3.1/Graphics/UI/Gtk/ModelView/TreeView.chs	2012-06-18 01:39:34.000000000 +0400
+++ gtk/Graphics/UI/Gtk/ModelView/TreeView.chs	2012-10-02 16:30:54.000000000 +0400
@@ -582,7 +582,7 @@
 {#pointer TreeViewColumnDropFunc#}
 
 foreign import ccall "wrapper" mkTreeViewColumnDropFunc ::
-  (Ptr () -> Ptr TreeViewColumn -> Ptr TreeViewColumn -> Ptr TreeViewColumn ->
+  (Ptr TreeView -> Ptr TreeViewColumn -> Ptr TreeViewColumn -> Ptr TreeViewColumn ->
   Ptr () -> IO {#type gboolean#}) -> IO TreeViewColumnDropFunc
 
 -- | Scroll to a coordinate.
@@ -798,7 +798,7 @@
 {#pointer TreeViewMappingFunc#}
 
 foreign import ccall "wrapper" mkTreeViewMappingFunc ::
-  (Ptr () -> Ptr NativeTreePath -> Ptr () -> IO ()) ->
+  (Ptr TreeView -> Ptr NativeTreePath -> Ptr () -> IO ()) ->
   IO TreeViewMappingFunc
 
 -- | Check if row is expanded.
diff -wbBur /home/sergej/community-my.svn/haskell-gtk/trunk/src/gtk-0.12.3.1/Graphics/UI/Gtk/Multiline/TextBuffer.chs gtk/Graphics/UI/Gtk/Multiline/TextBuffer.chs
--- /home/sergej/community-my.svn/haskell-gtk/trunk/src/gtk-0.12.3.1/Graphics/UI/Gtk/Multiline/TextBuffer.chs	2012-06-18 01:39:34.000000000 +0400
+++ gtk/Graphics/UI/Gtk/Multiline/TextBuffer.chs	2012-10-02 16:27:34.000000000 +0400
@@ -1251,16 +1251,26 @@
 
 -- | A 'Pixbuf' is inserted into the buffer.
 --
+-- * See note in 'bufferInsertText'.
+--
 insertPixbuf :: TextBufferClass self => Signal self (TextIter -> Pixbuf -> IO ())
 insertPixbuf = Signal (connect_BOXED_OBJECT__NONE "insert-pixbuf" mkTextIterCopy)
 
 -- | The 'insertChildAnchor' signal is emitted to insert a 'TextChildAnchor' in a 'TextBuffer'. 
 -- Insertion actually occurs in the default handler.
 --
+-- * See note in 'bufferInsertText'.
+--
 insertChildAnchor :: TextBufferClass self => Signal self (TextIter -> TextChildAnchor -> IO ())
 insertChildAnchor = Signal (connect_BOXED_OBJECT__NONE "insert-child-anchor" mkTextIterCopy)
 
--- | Some text was inserted.
+-- | Some text is inserted. Insertion actually occurs in the default handler.
+--
+-- * The function connected to this handler may not modify the buffer since
+--   this would invalidate the iterator. If this function replaces the
+--   default handler, it needs to stop the emission of this signal in order
+--   to prevent the default handler from running. If additional text should
+--   be inserted, this can be done using the 'after' function to connect.
 --
 bufferInsertText :: TextBufferClass self => Signal self (TextIter -> String -> IO ())
 bufferInsertText = Signal $ \after obj handler ->
diff -wbBur /home/sergej/community-my.svn/haskell-gtk/trunk/src/gtk-0.12.3.1/Graphics/UI/Gtk/Multiline/TextIter.chs gtk/Graphics/UI/Gtk/Multiline/TextIter.chs
--- /home/sergej/community-my.svn/haskell-gtk/trunk/src/gtk-0.12.3.1/Graphics/UI/Gtk/Multiline/TextIter.chs	2012-06-18 01:39:34.000000000 +0400
+++ gtk/Graphics/UI/Gtk/Multiline/TextIter.chs	2012-10-02 16:30:54.000000000 +0400
@@ -797,7 +797,7 @@
 {#pointer TextCharPredicate#}
 
 foreign import ccall "wrapper" mkTextCharPredicate ::
-  ({#type gunichar#} -> Ptr () -> {#type gboolean#}) -> IO TextCharPredicate
+  ({#type gunichar#} -> Ptr () -> IO {#type gboolean#}) -> IO TextCharPredicate
 
 -- | Move 'TextIter' forward until a
 -- predicate function returns True.
@@ -810,7 +810,7 @@
 textIterForwardFindChar :: TextIter -> (Char -> Bool) -> Maybe TextIter ->
                            IO Bool
 textIterForwardFindChar ti pred limit = do
-  fPtr <- mkTextCharPredicate (\c _ -> fromBool $ pred (chr (fromIntegral c)))
+  fPtr <- mkTextCharPredicate (\c _ -> return $ fromBool $ pred (chr (fromIntegral c)))
   res <- liftM toBool $ {#call text_iter_forward_find_char#} 
     ti fPtr nullPtr (fromMaybe (TextIter nullForeignPtr) limit)
   freeHaskellFunPtr fPtr
@@ -827,7 +827,7 @@
 textIterBackwardFindChar :: TextIter -> (Char -> Bool) -> Maybe TextIter ->
                             IO Bool
 textIterBackwardFindChar ti pred limit = do
-  fPtr <- mkTextCharPredicate (\c _ -> fromBool $ pred (chr (fromIntegral c)))
+  fPtr <- mkTextCharPredicate (\c _ -> return $ fromBool $ pred (chr (fromIntegral c)))
   res <- liftM toBool $ {#call text_iter_backward_find_char#} 
     ti fPtr nullPtr (fromMaybe (TextIter nullForeignPtr) limit)
   freeHaskellFunPtr fPtr
diff -wbBur /home/sergej/community-my.svn/haskell-gtk/trunk/src/gtk-0.12.3.1/Graphics/UI/Gtk/Windows/Assistant.chs gtk/Graphics/UI/Gtk/Windows/Assistant.chs
--- /home/sergej/community-my.svn/haskell-gtk/trunk/src/gtk-0.12.3.1/Graphics/UI/Gtk/Windows/Assistant.chs	2012-06-18 01:39:34.000000000 +0400
+++ gtk/Graphics/UI/Gtk/Windows/Assistant.chs	2012-10-02 16:30:54.000000000 +0400
@@ -274,7 +274,7 @@
 {#pointer AssistantPageFunc#}
 
 foreign import ccall "wrapper" mkAssistantPageFunc ::
-  ({#type glong#} -> Ptr () -> IO {#type glong#})
+  ({#type gint#} -> Ptr () -> IO {#type gint#})
   -> IO AssistantPageFunc
 
 -- | Sets the page type for @page@. The page type determines the page behavior
