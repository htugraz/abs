diff --git a/backends/alpm/Makefile.am b/backends/alpm/Makefile.am
index d8c3dfc..8e14790 100644
--- a/backends/alpm/Makefile.am
+++ b/backends/alpm/Makefile.am
@@ -23,6 +23,7 @@ DEFS = -DPK_BACKEND_CONFIG_FILE=\"$(PK_BACKEND_CONFIG_FILE)\" \
        -DPK_BACKEND_DEFAULT_LOGFILE=\"$(PK_BACKEND_DEFAULT_LOGFILE)\" \
        -DALPM_CACHE_PATH=\"$(ALPM_CACHE_PATH)\" \
        -DALPM_PACKAGE_URL=\"$(ALPM_PACKAGE_URL)\" \
+       -DPK_LOG_PREFIX=\"PACKAGEKIT\" \
        -DG_LOG_DOMAIN=\"PackageKit-alpm\"
 
 confdir = $(PK_CONF_DIR)/alpm.d
@@ -47,10 +48,11 @@ libpk_backend_alpm_la_SOURCES = pk-backend-alpm.c \
 				pk-backend-transaction.c \
 				pk-backend-update.c
 libpk_backend_alpm_la_LIBADD = $(PK_PLUGIN_LIBS) \
-			       -lalpm
+			       $(ALPM_LIBS)
 libpk_backend_alpm_la_LDFLAGS = -module \
 				-avoid-version
 libpk_backend_alpm_la_CFLAGS = $(PK_PLUGIN_CFLAGS) \
+			       $(ALPM_CFLAGS) \
 			       $(WARNINGFLAGS_C)
 
 EXTRA_DIST = $(conf_DATA) $(libpk_backend_alpm_la_SOURCES:.c=.h)
diff --git a/backends/alpm/pk-backend-alpm.c b/backends/alpm/pk-backend-alpm.c
index 5c6b629..a4cd197 100644
--- a/backends/alpm/pk-backend-alpm.c
+++ b/backends/alpm/pk-backend-alpm.c
@@ -284,9 +284,9 @@ pk_backend_initialize_alpm (PkBackend *self, GError **error)
 	backend = self;
 	alpm_option_set_logcb (alpm, pk_backend_logcb);
 
-	localdb = alpm_option_get_localdb (alpm);
+	localdb = alpm_get_localdb (alpm);
 	if (localdb == NULL) {
-		enum _alpm_errno_t errno = alpm_errno (alpm);
+		alpm_errno_t errno = alpm_errno (alpm);
 		g_set_error (error, ALPM_ERROR, errno, "[%s]: %s", "local",
 			     alpm_strerror (errno));
 	}
diff --git a/backends/alpm/pk-backend-config.c b/backends/alpm/pk-backend-config.c
index c8fd13b..03adb47 100644
--- a/backends/alpm/pk-backend-config.c
+++ b/backends/alpm/pk-backend-config.c
@@ -33,35 +33,32 @@
 
 typedef struct
 {
-	 gboolean	 checkspace, ilovecandy, totaldl, usedelta, usesyslog,
-			 verbosepkglists;
+	 gboolean		 checkspace, color, ilovecandy, totaldl,
+				 usesyslog, verbosepkglists;
+	 gdouble		 deltaratio;
 
-	 gchar		*arch, *cleanmethod, *dbpath, *gpgdir, *logfile, *root,
-			*xfercmd;
+	 gchar			*arch, *cleanmethod, *dbpath, *gpgdir, *logfile,
+				*root, *xfercmd;
 
-	 alpm_list_t	*cachedirs, *holdpkgs, *ignoregroups, *ignorepkgs,
-			*noextracts, *noupgrades, *syncfirsts;
+	 alpm_list_t		*cachedirs, *holdpkgs, *ignoregroups,
+				*ignorepkgs, *localfilesiglevels, *noextracts,
+				*noupgrades, *remotefilesiglevels;
 
-	 alpm_list_t	*repos;
-	 GHashTable	*servers;
-	 GHashTable	*levels;
-	 GRegex		*xrepo, *xarch;
+	 alpm_list_t		*sections;
+	 GRegex			*xrepo, *xarch;
 } PkBackendConfig;
 
+typedef struct
+{
+	 gchar		*name;
+	 alpm_list_t	*servers, *siglevels;
+} PkBackendConfigSection;
+
 static PkBackendConfig *
 pk_backend_config_new (void)
 {
 	PkBackendConfig *config = g_new0 (PkBackendConfig, 1);
-	alpm_siglevel_t *level = g_new0 (alpm_siglevel_t, 1);
-
-	config->servers = g_hash_table_new_full (g_str_hash, g_str_equal,
-						 g_free, NULL);
-	config->levels = g_hash_table_new_full (g_str_hash, g_str_equal, g_free,
-						g_free);
-
-	*level |= ALPM_SIG_PACKAGE | ALPM_SIG_PACKAGE_OPTIONAL;
-	*level |= ALPM_SIG_DATABASE | ALPM_SIG_DATABASE_OPTIONAL;
-	g_hash_table_insert (config->levels, g_strdup ("options"), level);
+	config->deltaratio = 0.0;
 
 	config->xrepo = g_regex_new ("\\$repo", 0, 0, NULL);
 	config->xarch = g_regex_new ("\\$arch", 0, 0, NULL);
@@ -70,17 +67,17 @@ pk_backend_config_new (void)
 }
 
 static void
-pk_backend_config_list_free (alpm_list_t *list)
+pk_backend_config_section_free (gpointer data)
 {
-	alpm_list_free_inner (list, g_free);
-	alpm_list_free (list);
-}
+	PkBackendConfigSection *section = data;
 
-static gboolean
-pk_backend_config_servers_free (gpointer repo, gpointer list, gpointer data)
-{
-	pk_backend_config_list_free ((alpm_list_t *) list);
-	return TRUE;
+	if (section != NULL) {
+		g_free (section->name);
+		alpm_list_free_inner (section->servers, g_free);
+		alpm_list_free (section->servers);
+		FREELIST (section->siglevels);
+		g_free (section);
+	}
 }
 
 static void
@@ -100,15 +97,13 @@ pk_backend_config_free (PkBackendConfig *config)
 	FREELIST (config->holdpkgs);
 	FREELIST (config->ignoregroups);
 	FREELIST (config->ignorepkgs);
+	FREELIST (config->localfilesiglevels);
 	FREELIST (config->noextracts);
 	FREELIST (config->noupgrades);
-	FREELIST (config->syncfirsts);
+	FREELIST (config->remotefilesiglevels);
 
-	pk_backend_config_list_free (config->repos);
-	g_hash_table_foreach_remove (config->servers,
-				     pk_backend_config_servers_free, NULL);
-	g_hash_table_unref (config->servers);
-	g_hash_table_unref (config->levels);
+	alpm_list_free_inner (config->sections, pk_backend_config_section_free);
+	alpm_list_free (config->sections);
 
 	g_regex_unref (config->xrepo);
 	g_regex_unref (config->xarch);
@@ -123,6 +118,14 @@ pk_backend_config_set_checkspace (PkBackendConfig *config)
 }
 
 static void
+pk_backend_config_set_color (PkBackendConfig *config)
+{
+	g_return_if_fail (config != NULL);
+
+	config->color = TRUE;
+}
+
+static void
 pk_backend_config_set_ilovecandy (PkBackendConfig *config)
 {
 	g_return_if_fail (config != NULL);
@@ -143,7 +146,7 @@ pk_backend_config_set_usedelta (PkBackendConfig *config)
 {
 	g_return_if_fail (config != NULL);
 
-	config->usedelta = TRUE;
+	config->deltaratio = 0.7;
 }
 
 static void
@@ -171,6 +174,7 @@ typedef struct
 /* keep this in alphabetical order */
 static const PkBackendConfigBoolean pk_backend_config_boolean_options[] = {
 	{ "CheckSpace", pk_backend_config_set_checkspace },
+	{ "Color", pk_backend_config_set_color },
 	{ "ILoveCandy", pk_backend_config_set_ilovecandy },
 	{ "TotalDownload", pk_backend_config_set_totaldl },
 	{ "UseDelta", pk_backend_config_set_usedelta },
@@ -284,6 +288,22 @@ pk_backend_config_set_root (PkBackendConfig *config, const gchar *path)
 }
 
 static void
+pk_backend_config_set_deltaratio (PkBackendConfig *config, const gchar *number)
+{
+	gdouble ratio;
+	gchar *endptr;
+
+	g_return_if_fail (config != NULL);
+	g_return_if_fail (number != NULL);
+
+	ratio = g_ascii_strtod (number, &endptr);
+	/* this ignores invalid values whereas pacman reports an error */
+	if (*endptr == '\0' && 0.0 <= ratio && ratio <= 2.0) {
+		config->deltaratio = ratio;
+	}
+}
+
+static void
 pk_backend_config_set_xfercmd (PkBackendConfig *config, const gchar *command)
 {
 	g_return_if_fail (config != NULL);
@@ -308,6 +328,7 @@ static const PkBackendConfigString pk_backend_config_string_options[] = {
 	{ "GPGDir", pk_backend_config_set_gpgdir },
 	{ "LogFile", pk_backend_config_set_logfile },
 	{ "RootDir", pk_backend_config_set_root },
+	{ "UseDelta", pk_backend_config_set_deltaratio },
 	{ "XferCommand", pk_backend_config_set_xfercmd },
 	{ NULL, NULL }
 };
@@ -335,102 +356,51 @@ pk_backend_config_set_string (PkBackendConfig *config, const gchar *option,
 	}
 }
 
-static void
-pk_backend_config_add_holdpkg (PkBackendConfig *config, gchar *package)
-{
-	g_return_if_fail (config != NULL);
-	g_return_if_fail (package != NULL);
-
-	config->holdpkgs = alpm_list_add (config->holdpkgs, package);
-}
-
-static void
-pk_backend_config_add_ignoregroup (PkBackendConfig *config, gchar *group)
-{
-	g_return_if_fail (config != NULL);
-	g_return_if_fail (group != NULL);
-
-	config->ignoregroups = alpm_list_add (config->ignoregroups, group);
-}
-
-static void
-pk_backend_config_add_ignorepkg (PkBackendConfig *config, gchar *package)
-{
-	g_return_if_fail (config != NULL);
-	g_return_if_fail (package != NULL);
-
-	config->ignorepkgs = alpm_list_add (config->ignorepkgs, package);
-}
-
-static void
-pk_backend_config_add_noextract (PkBackendConfig *config, gchar *filename)
-{
-	g_return_if_fail (config != NULL);
-	g_return_if_fail (filename != NULL);
-
-	config->noextracts = alpm_list_add (config->noextracts, filename);
-}
-
-static void
-pk_backend_config_add_noupgrade (PkBackendConfig *config, gchar *filename)
-{
-	g_return_if_fail (config != NULL);
-	g_return_if_fail (filename != NULL);
-
-	config->noupgrades = alpm_list_add (config->noupgrades, filename);
-}
-
-static void
-pk_backend_config_add_syncfirst (PkBackendConfig *config, gchar *package)
-{
-	g_return_if_fail (config != NULL);
-	g_return_if_fail (package != NULL);
-
-	config->syncfirsts = alpm_list_add (config->syncfirsts, package);
-}
-
 typedef struct
 {
 	const gchar	*name;
-	void		(*func) (PkBackendConfig *config, gchar *value);
+	glong		 offset;
 } PkBackendConfigList;
 
 /* keep this in alphabetical order */
 static const PkBackendConfigList pk_backend_config_list_options[] = {
-	{ "HoldPkg", pk_backend_config_add_holdpkg },
-	{ "IgnoreGroup", pk_backend_config_add_ignoregroup },
-	{ "IgnorePkg", pk_backend_config_add_ignorepkg },
-	{ "NoExtract", pk_backend_config_add_noextract },
-	{ "NoUpgrade", pk_backend_config_add_noupgrade },
-	{ "SyncFirst", pk_backend_config_add_syncfirst },
-	{ NULL, NULL }
+	{ "HoldPkg", G_STRUCT_OFFSET (PkBackendConfig, holdpkgs) },
+	{ "IgnoreGroup", G_STRUCT_OFFSET (PkBackendConfig, ignoregroups) },
+	{ "IgnorePkg", G_STRUCT_OFFSET (PkBackendConfig, ignorepkgs) },
+	{ "LocalFileSigLevel", G_STRUCT_OFFSET (PkBackendConfig,
+						localfilesiglevels) },
+	{ "NoExtract", G_STRUCT_OFFSET (PkBackendConfig, noextracts) },
+	{ "NoUpgrade", G_STRUCT_OFFSET (PkBackendConfig, noupgrades) },
+	{ "RemoteFileSigLevel", G_STRUCT_OFFSET (PkBackendConfig,
+						 remotefilesiglevels) },
+	{ NULL, 0 }
 };
 
-static void
-pk_backend_config_list_add (PkBackendConfig *config, gsize option,
-			    const gchar *list)
+static alpm_list_t *
+alpm_list_add_words (alpm_list_t *list, const gchar *words)
 {
 	gchar *str;
 
-	for (str = strchr (list, ' '); str != NULL; str = strchr (list, ' ')) {
+	while ((str = strchr (words, ' ')) != NULL) {
 		/* allocate normally */
-		gchar *value = malloc ((++str - list) * sizeof (gchar));
-		g_strlcpy (value, list, str - list);
-		pk_backend_config_list_options[option].func (config, value);
-		list = str;
+		gchar *word = malloc ((++str - words) * sizeof (gchar));
+		g_strlcpy (word, words, str - words);
+		list = alpm_list_add (list, word);
+		words = str;
 	}
-	pk_backend_config_list_options[option].func (config, strdup (list));
+
+	return alpm_list_add (list, strdup (words));
 }
 
 static gboolean
 pk_backend_config_set_list (PkBackendConfig *config, const gchar *option,
-			    const gchar *list)
+			    const gchar *words)
 {
 	gsize i;
 
 	g_return_val_if_fail (config != NULL, FALSE);
 	g_return_val_if_fail (option != NULL, FALSE);
-	g_return_val_if_fail (list != NULL, FALSE);
+	g_return_val_if_fail (words != NULL, FALSE);
 
 	for (i = 0;; ++i) {
 		const gchar *name = pk_backend_config_list_options[i].name;
@@ -439,37 +409,57 @@ pk_backend_config_set_list (PkBackendConfig *config, const gchar *option,
 		if (name == NULL || cmp < 0) {
 			return FALSE;
 		} else if (cmp == 0) {
-			pk_backend_config_list_add (config, i, list);
+			glong offset = pk_backend_config_list_options[i].offset;
+			alpm_list_t **list = G_STRUCT_MEMBER_P (config, offset);
+			*list = alpm_list_add_words (*list, words);
 			return TRUE;
 		}
 	}
 }
 
-static void
-pk_backend_config_add_repo (PkBackendConfig *config, const gchar *repo)
+static gint
+pk_backend_config_section_match (gconstpointer element, gconstpointer name)
 {
-	g_return_if_fail (config != NULL);
-	g_return_if_fail (repo != NULL);
+	const PkBackendConfigSection *section = element;
+
+	g_return_val_if_fail (section != NULL, -1);
+
+	return g_strcmp0 (section->name, name);
+}
 
-	if (alpm_list_find_str (config->repos, repo) == NULL) {
-		config->repos = alpm_list_add (config->repos, g_strdup (repo));
+static PkBackendConfigSection *
+pk_backend_config_enter_section (PkBackendConfig *config, const gchar *name)
+{
+	PkBackendConfigSection *section;
+
+	g_return_val_if_fail (config != NULL, NULL);
+	g_return_val_if_fail (name != NULL, NULL);
+
+	section = alpm_list_find (config->sections, name,
+				  pk_backend_config_section_match);
+	if (section != NULL) {
+		return section;
 	}
+
+	section = g_new0 (PkBackendConfigSection, 1);
+	section->name = g_strdup (name);
+	config->sections = alpm_list_add (config->sections, section);
+	return section;
 }
 
 static gboolean
-pk_backend_config_repo_add_server (PkBackendConfig *config, const gchar *repo,
-				   const gchar *value, GError **e)
+pk_backend_config_add_server (PkBackendConfig *config,
+			      PkBackendConfigSection *section,
+			      const gchar *address, GError **e)
 {
-	alpm_list_t *list;
 	gchar *url;
 
 	g_return_val_if_fail (config != NULL, FALSE);
-	g_return_val_if_fail (repo != NULL, FALSE);
-	g_return_val_if_fail (alpm_list_find_str (config->repos, repo) != NULL,
-			      FALSE);
-	g_return_val_if_fail (value != NULL, FALSE);
+	g_return_val_if_fail (section != NULL, FALSE);
+	g_return_val_if_fail (address != NULL, FALSE);
 
-	url = g_regex_replace_literal (config->xrepo, value, -1, 0, repo, 0, e);
+	url = g_regex_replace_literal (config->xrepo, address, -1, 0,
+				       section->name, 0, e);
 	if (url == NULL) {
 		return FALSE;
 	}
@@ -488,105 +478,26 @@ pk_backend_config_repo_add_server (PkBackendConfig *config, const gchar *repo,
 			     "url contained $arch, which is not set");
 	}
 
-	list = (alpm_list_t *) g_hash_table_lookup (config->servers, repo);
-	list = alpm_list_add (list, url);
-	g_hash_table_insert (config->servers, g_strdup (repo), list);
+	section->servers = alpm_list_add (section->servers, url);
 
 	return TRUE;
 }
 
-static gboolean
-pk_backend_config_set_siglevel (PkBackendConfig *config, const gchar *section,
-				const gchar *list, GError **error)
+static void
+pk_backend_config_add_siglevel (PkBackendConfig *config,
+				PkBackendConfigSection *section,
+				const gchar *words)
 {
-	alpm_siglevel_t *level;
-
-	g_return_val_if_fail (config != NULL, FALSE);
-	g_return_val_if_fail (section != NULL, FALSE);
-	g_return_val_if_fail (list != NULL, FALSE);
-
-	level = g_hash_table_lookup (config->levels, section);
-	if (level == NULL) {
-		level = g_hash_table_lookup (config->levels, "options");
-		level = g_memdup (level, sizeof (alpm_siglevel_t));
-		g_hash_table_insert (config->levels, g_strdup (section), level);
-	}
-
-	while (TRUE) {
-		gboolean package = TRUE, database = TRUE;
-
-		if (g_str_has_prefix (list, "Package")) {
-			database = FALSE;
-			list += 7;
-		} else if (g_str_has_prefix (list, "Database")) {
-			package = FALSE;
-			list += 8;
-		}
-
-		/* this also allows e.g. NeverEver, so put prefixes last */
-		if (g_str_has_prefix (list, "Never")) {
-			if (package) {
-				*level &= ~ALPM_SIG_PACKAGE;
-			}
-			if (database) {
-				*level &= ~ALPM_SIG_DATABASE;
-			}
-		} else if (g_str_has_prefix (list, "Optional")) {
-			if (package) {
-				*level |= ALPM_SIG_PACKAGE;
-				*level |= ALPM_SIG_PACKAGE_OPTIONAL;
-			}
-			if (database) {
-				*level |= ALPM_SIG_DATABASE;
-				*level |= ALPM_SIG_DATABASE_OPTIONAL;
-			}
-		} else if (g_str_has_prefix (list, "Required")) {
-			if (package) {
-				*level |= ALPM_SIG_PACKAGE;
-				*level &= ~ALPM_SIG_PACKAGE_OPTIONAL;
-			}
-			if (database) {
-				*level |= ALPM_SIG_DATABASE;
-				*level &= ~ALPM_SIG_DATABASE_OPTIONAL;
-			}
-		} else if (g_str_has_prefix (list, "TrustedOnly")) {
-			if (package) {
-				*level &= ~ALPM_SIG_PACKAGE_MARGINAL_OK;
-				*level &= ~ALPM_SIG_PACKAGE_UNKNOWN_OK;
-			}
-			if (database) {
-				*level &= ~ALPM_SIG_DATABASE_MARGINAL_OK;
-				*level &= ~ALPM_SIG_DATABASE_UNKNOWN_OK;
-			}
-		} else if (g_str_has_prefix (list, "TrustAll")) {
-			if (package) {
-				*level |= ALPM_SIG_PACKAGE_MARGINAL_OK;
-				*level |= ALPM_SIG_PACKAGE_UNKNOWN_OK;
-			}
-			if (database) {
-				*level |= ALPM_SIG_DATABASE_MARGINAL_OK;
-				*level |= ALPM_SIG_DATABASE_UNKNOWN_OK;
-			}
-		} else {
-			g_set_error (error, ALPM_ERROR, ALPM_ERR_CONFIG_INVALID,
-				     "invalid SigLevel value: %s", list);
-			return FALSE;
-		}
-
-		list = strchr (list, ' ');
-		if (list == NULL) {
-			break;
-		} else {
-			++list;
-		}
-	}
+	g_return_if_fail (config != NULL);
+	g_return_if_fail (section != NULL);
+	g_return_if_fail (words != NULL);
 
-	return TRUE;
+	section->siglevels = alpm_list_add_words (section->siglevels, words);
 }
 
 static gboolean
 pk_backend_config_parse (PkBackendConfig *config, const gchar *filename,
-			 gchar *section, GError **error)
+			 PkBackendConfigSection *section, GError **error)
 {
 	GFile *file;
 	GFileInputStream *is;
@@ -610,7 +521,6 @@ pk_backend_config_parse (PkBackendConfig *config, const gchar *filename,
 	}
 
 	input = g_data_input_stream_new (G_INPUT_STREAM (is));
-	section = g_strdup (section);
 
 	for (;; g_free (line), ++num) {
 		line = g_data_input_stream_read_line (input, NULL, NULL, &e);
@@ -642,13 +552,7 @@ pk_backend_config_parse (PkBackendConfig *config, const gchar *filename,
 				break;
 			}
 
-			g_free (section);
-			section = g_strdup (str);
-
-			if (g_strcmp0 (section, "options") != 0) {
-				pk_backend_config_add_repo (config, section);
-			}
-
+			section = pk_backend_config_enter_section (config, str);
 			continue;
 		}
 
@@ -668,7 +572,8 @@ pk_backend_config_parse (PkBackendConfig *config, const gchar *filename,
 
 		if (str == NULL) {
 			/* set a boolean directive */
-			if (g_strcmp0 (section, "options") == 0 &&
+			if (pk_backend_config_section_match (section,
+							     "options") == 0 &&
 			    pk_backend_config_set_boolean (config, key)) {
 				continue;
 			}
@@ -697,7 +602,8 @@ pk_backend_config_parse (PkBackendConfig *config, const gchar *filename,
 			} else {
 				continue;
 			}
-		} else if (g_strcmp0 (section, "options") == 0) {
+		} else if (pk_backend_config_section_match (section,
+							    "options") == 0) {
 			/* set a string or list directive */
 			if (pk_backend_config_set_string (config, key, str) ||
 			    pk_backend_config_set_list (config, key, str)) {
@@ -705,8 +611,8 @@ pk_backend_config_parse (PkBackendConfig *config, const gchar *filename,
 			}
 			/* report error below */
 		} else if (g_strcmp0 (key, "Server") == 0) {
-			if (!pk_backend_config_repo_add_server (config, section,
-								str, &e)) {
+			if (!pk_backend_config_add_server (config, section,
+							   str, &e)) {
 				break;
 			} else {
 				continue;
@@ -714,12 +620,8 @@ pk_backend_config_parse (PkBackendConfig *config, const gchar *filename,
 		}
 	
 		if (g_strcmp0 (key, "SigLevel") == 0 && str != NULL) {
-			if (!pk_backend_config_set_siglevel (config, section,
-							     str, &e)) {
-				break;
-			} else {
-				continue;
-			}
+			pk_backend_config_add_siglevel (config, section, str);
+			continue;
 		}
 
 		/* report errors from above */
@@ -728,8 +630,6 @@ pk_backend_config_parse (PkBackendConfig *config, const gchar *filename,
 		break;
 	}
 
-	g_free (section);
-
 	g_object_unref (input);
 	g_object_unref (is);
 	g_object_unref (file);
@@ -746,7 +646,7 @@ static alpm_handle_t *
 pk_backend_config_initialize_alpm (PkBackendConfig *config, GError **error)
 {
 	alpm_handle_t *handle;
-	enum _alpm_errno_t errno;
+	alpm_errno_t errno;
 	gsize dir = 1;
 
 	g_return_val_if_fail (config != NULL, FALSE);
@@ -817,11 +717,160 @@ pk_backend_config_initialize_alpm (PkBackendConfig *config, GError **error)
 	return handle;
 }
 
+static alpm_siglevel_t
+alpm_siglevel_parse (alpm_siglevel_t base, const alpm_list_t *list,
+		     GError **error)
+{
+	for (; list != NULL; list = list->next) {
+		gboolean package = TRUE, database = TRUE;
+		const gchar *level = (const gchar *) list->data;
+
+		if (g_str_has_prefix (level, "Package")) {
+			database = FALSE;
+			level += 7;
+		} else if (g_str_has_prefix (level, "Database")) {
+			package = FALSE;
+			level += 8;
+		}
+
+		if (g_strcmp0 (level, "Never") == 0) {
+			if (package) {
+				base &= ~ALPM_SIG_PACKAGE;
+				base |= ALPM_SIG_PACKAGE_SET;
+			}
+			if (database) {
+				base &= ~ALPM_SIG_DATABASE;
+			}
+		} else if (g_strcmp0 (level, "Optional") == 0) {
+			if (package) {
+				base |= ALPM_SIG_PACKAGE;
+				base |= ALPM_SIG_PACKAGE_OPTIONAL;
+				base |= ALPM_SIG_PACKAGE_SET;
+			}
+			if (database) {
+				base |= ALPM_SIG_DATABASE;
+				base |= ALPM_SIG_DATABASE_OPTIONAL;
+			}
+		} else if (g_strcmp0 (level, "Required") == 0) {
+			if (package) {
+				base |= ALPM_SIG_PACKAGE;
+				base &= ~ALPM_SIG_PACKAGE_OPTIONAL;
+				base |= ALPM_SIG_PACKAGE_SET;
+			}
+			if (database) {
+				base |= ALPM_SIG_DATABASE;
+				base &= ~ALPM_SIG_DATABASE_OPTIONAL;
+			}
+		} else if (g_strcmp0 (level, "TrustedOnly") == 0) {
+			if (package) {
+				base &= ~ALPM_SIG_PACKAGE_MARGINAL_OK;
+				base &= ~ALPM_SIG_PACKAGE_UNKNOWN_OK;
+				base |= ALPM_SIG_PACKAGE_TRUST_SET;
+			}
+			if (database) {
+				base &= ~ALPM_SIG_DATABASE_MARGINAL_OK;
+				base &= ~ALPM_SIG_DATABASE_UNKNOWN_OK;
+			}
+		} else if (g_strcmp0 (level, "TrustAll") == 0) {
+			if (package) {
+				base |= ALPM_SIG_PACKAGE_MARGINAL_OK;
+				base |= ALPM_SIG_PACKAGE_UNKNOWN_OK;
+				base |= ALPM_SIG_PACKAGE_TRUST_SET;
+			}
+			if (database) {
+				base |= ALPM_SIG_DATABASE_MARGINAL_OK;
+				base |= ALPM_SIG_DATABASE_UNKNOWN_OK;
+			}
+		} else {
+			g_set_error (error, ALPM_ERROR, ALPM_ERR_CONFIG_INVALID,
+				     "invalid SigLevel value: %s", level);
+			return ALPM_SIG_USE_DEFAULT;
+		}
+	}
+
+	return base;
+}
+
+static alpm_siglevel_t
+alpm_siglevel_cross (alpm_siglevel_t base, const alpm_list_t *list,
+		     GError **error)
+{
+	alpm_siglevel_t level;
+
+	if (list == NULL) {
+		return base;
+	}
+
+	level = alpm_siglevel_parse (0, list, error);
+	if (level == ALPM_SIG_USE_DEFAULT) {
+		return level;
+	}
+
+	/* based on unexplained code in pacman */
+	if ((level & ALPM_SIG_PACKAGE_SET) == 0) {
+		level |= base & (ALPM_SIG_PACKAGE | ALPM_SIG_PACKAGE_OPTIONAL);
+	}
+	if ((level & ALPM_SIG_PACKAGE_TRUST_SET) == 0) {
+		level |= base & (ALPM_SIG_PACKAGE_MARGINAL_OK |
+				 ALPM_SIG_PACKAGE_UNKNOWN_OK);
+	}
+
+	return level;
+}
+
+static gboolean
+pk_backend_config_configure_repos (PkBackendConfig *config,
+				   alpm_handle_t *handle, GError **error)
+{
+	alpm_siglevel_t base, local, remote;
+	const alpm_list_t *i;
+	PkBackendConfigSection *options;
+
+	g_return_val_if_fail (config != NULL, FALSE);
+
+	base = ALPM_SIG_PACKAGE | ALPM_SIG_PACKAGE_OPTIONAL |
+	       ALPM_SIG_DATABASE | ALPM_SIG_DATABASE_OPTIONAL;
+
+	i = config->sections;
+	options = i->data;
+
+	base = alpm_siglevel_parse (base, options->siglevels, error);
+	if (base == ALPM_SIG_USE_DEFAULT) {
+		return FALSE;
+	}
+
+	local = alpm_siglevel_cross (base, config->localfilesiglevels, error);
+	if (local == ALPM_SIG_USE_DEFAULT) {
+		return FALSE;
+	}
+
+	remote = alpm_siglevel_cross (base, config->remotefilesiglevels, error);
+	if (remote == ALPM_SIG_USE_DEFAULT) {
+		return FALSE;
+	}
+
+	alpm_option_set_default_siglevel (handle, base);
+	alpm_option_set_local_file_siglevel (handle, local);
+	alpm_option_set_remote_file_siglevel (handle, remote);
+
+	while ((i = i->next) != NULL) {
+		PkBackendConfigSection *repo = i->data;
+		alpm_siglevel_t level;
+
+		level = alpm_siglevel_parse (base, repo->siglevels, error);
+		if (level == ALPM_SIG_USE_DEFAULT) {
+			return FALSE;
+		}
+		pk_backend_add_database (repo->name, repo->servers, level);
+	}
+
+	return TRUE;
+}
+
 static alpm_handle_t *
 pk_backend_config_configure_alpm (PkBackendConfig *config, GError **error)
 {
 	alpm_handle_t *handle;
-	alpm_siglevel_t *level;
 
 	g_return_val_if_fail (config != NULL, FALSE);
 
@@ -831,12 +880,9 @@ pk_backend_config_configure_alpm (PkBackendConfig *config, GError **error)
 	}
 
 	alpm_option_set_checkspace (handle, config->checkspace);
-	alpm_option_set_usedelta (handle, config->usedelta);
 	alpm_option_set_usesyslog (handle, config->usesyslog);
 	alpm_option_set_arch (handle, config->arch);
-
-	level = g_hash_table_lookup (config->levels, "options");
-	alpm_option_set_default_siglevel (handle, *level);
+	alpm_option_set_deltaratio (handle, config->deltaratio);
 
 	/* backend takes ownership */
 	g_free (xfercmd);
@@ -854,11 +900,6 @@ pk_backend_config_configure_alpm (PkBackendConfig *config, GError **error)
 	holdpkgs = config->holdpkgs;
 	config->holdpkgs = NULL;
 
-	/* backend takes ownership */
-	FREELIST (syncfirsts);
-	syncfirsts = config->syncfirsts;
-	config->syncfirsts = NULL;
-
 	/* alpm takes ownership */
 	alpm_option_set_ignoregroups (handle, config->ignoregroups);
 	config->ignoregroups = NULL;
@@ -875,8 +916,7 @@ pk_backend_config_configure_alpm (PkBackendConfig *config, GError **error)
 	alpm_option_set_noupgrades (handle, config->noupgrades);
 	config->noupgrades = NULL;
 
-	pk_backend_configure_repos (config->repos, config->servers,
-				    config->levels);
+	pk_backend_config_configure_repos (config, handle, error);
 
 	return handle;
 }
@@ -892,6 +932,7 @@ pk_backend_configure (const gchar *filename, GError **error)
 
 	g_debug ("reading config from %s", filename);
 	config = pk_backend_config_new ();
+	pk_backend_config_enter_section (config, "options");
 
 	if (pk_backend_config_parse (config, filename, NULL, &e)) {
 		handle = pk_backend_config_configure_alpm (config, &e);
diff --git a/backends/alpm/pk-backend-databases.c b/backends/alpm/pk-backend-databases.c
index a123297..09d5a73 100644
--- a/backends/alpm/pk-backend-databases.c
+++ b/backends/alpm/pk-backend-databases.c
@@ -140,8 +140,8 @@ disabled_repos_configure (GHashTable *table, gboolean only_trusted,
 	g_return_val_if_fail (table != NULL, FALSE);
 	g_return_val_if_fail (alpm != NULL, FALSE);
 
-	if (alpm_db_unregister_all (alpm) < 0) {
-		enum _alpm_errno_t errno = alpm_errno (alpm);
+	if (alpm_unregister_all_syncdbs (alpm) < 0) {
+		alpm_errno_t errno = alpm_errno (alpm);
 		g_set_error_literal (error, ALPM_ERROR, errno,
 				     alpm_strerror (errno));
 		return FALSE;
@@ -161,9 +161,9 @@ disabled_repos_configure (GHashTable *table, gboolean only_trusted,
 			level &= ~ALPM_SIG_USE_DEFAULT;
 		}
 
-		db = alpm_db_register_sync (alpm, repo->name, level);
+		db = alpm_register_syncdb (alpm, repo->name, level);
 		if (db == NULL) {
-			enum _alpm_errno_t errno = alpm_errno (alpm);
+			alpm_errno_t errno = alpm_errno (alpm);
 			g_set_error (error, ALPM_ERROR, errno, "[%s]: %s",
 				     repo->name, alpm_strerror (errno));
 			return FALSE;
@@ -176,29 +176,18 @@ disabled_repos_configure (GHashTable *table, gboolean only_trusted,
 }
 
 void
-pk_backend_configure_repos (alpm_list_t *repos, GHashTable *servers,
-			    GHashTable *levels)
+pk_backend_add_database (const gchar *name, alpm_list_t *servers,
+			 alpm_siglevel_t level)
 {
-	alpm_list_t *i;
-
-	g_return_if_fail (servers != NULL);
-
-	for (i = repos; i != NULL; i = i->next) {
-		PkBackendRepo *repo = g_new (PkBackendRepo, 1);
-		gpointer value = g_hash_table_lookup (servers, i->data);
+	PkBackendRepo *repo = g_new (PkBackendRepo, 1);
 
-		repo->name = g_strdup ((const gchar *) i->data);
-		repo->servers = alpm_list_strdup ((alpm_list_t *) value);
+	g_return_if_fail (name != NULL);
 
-		value = g_hash_table_lookup (levels, i->data);
-		if (value != NULL) {
-			repo->level = *(alpm_siglevel_t *) value;
-		} else {
-			repo->level = ALPM_SIG_USE_DEFAULT;
-		}
+	repo->name = g_strdup (name);
+	repo->servers = alpm_list_strdup (servers);
+	repo->level = level;
 
-		configured = alpm_list_add (configured, repo);
-	}
+	configured = alpm_list_add (configured, repo);
 }
 
 gboolean
@@ -282,7 +271,7 @@ pk_backend_get_repo_list_thread (PkBackend *self)
 	g_return_val_if_fail (disabled != NULL, FALSE);
 
 	/* emit enabled repos */
-	for (i = alpm_option_get_syncdbs (alpm); i != NULL; i = i->next) {
+	for (i = alpm_get_syncdbs (alpm); i != NULL; i = i->next) {
 		alpm_db_t *db = (alpm_db_t *) i->data;
 		const gchar *repo = alpm_db_get_name (db);
 
@@ -368,13 +357,13 @@ pk_backend_repo_disable_thread (PkBackend *self)
 
 	g_return_val_if_fail (repo != NULL, FALSE);
 
-	for (i = alpm_option_get_syncdbs (alpm); i != NULL; i = i->next) {
+	for (i = alpm_get_syncdbs (alpm); i != NULL; i = i->next) {
 		alpm_db_t *db = (alpm_db_t *) i->data;
 		const gchar *name = alpm_db_get_name (db);
 
 		if (g_strcmp0 (repo, name) == 0) {
 			if (alpm_db_unregister (db) < 0) {
-				enum _alpm_errno_t errno = alpm_errno (alpm);
+				alpm_errno_t errno = alpm_errno (alpm);
 				g_set_error (&error, ALPM_ERROR, errno,
 					     "[%s]: %s", repo,
 					     alpm_strerror (errno));
diff --git a/backends/alpm/pk-backend-databases.h b/backends/alpm/pk-backend-databases.h
index d9b9e78..d0dbb7c 100644
--- a/backends/alpm/pk-backend-databases.h
+++ b/backends/alpm/pk-backend-databases.h
@@ -24,9 +24,9 @@
 #include <alpm.h>
 #include <pk-backend.h>
 
-void		 pk_backend_configure_repos		(alpm_list_t *repos,
-							 GHashTable *servers,
-							 GHashTable *levels);
+void		 pk_backend_add_database		(const gchar *name,
+							 alpm_list_t *servers,
+							 alpm_siglevel_t level);
 
 gboolean	 pk_backend_disable_signatures		(PkBackend *self,
 							 GError **error);
diff --git a/backends/alpm/pk-backend-depends.c b/backends/alpm/pk-backend-depends.c
index 7c7b45a..c3d82a0 100644
--- a/backends/alpm/pk-backend-depends.c
+++ b/backends/alpm/pk-backend-depends.c
@@ -85,7 +85,7 @@ pk_backend_find_provider (PkBackend *self, alpm_list_t *pkgs,
 	}
 
 	/* look for remote dependencies */
-	syncdbs = alpm_option_get_syncdbs (alpm);
+	syncdbs = alpm_get_syncdbs (alpm);
 	provider = alpm_find_dbs_satisfier (alpm, syncdbs, depend);
 
 	if (provider != NULL) {
@@ -184,7 +184,7 @@ pk_backend_get_depends_thread (PkBackend *self)
 			depend = alpm_dep_compute_string (depends->data);
 			pkgs = pk_backend_find_provider (self, pkgs, depend,
 							 &error);
-			g_free (depend);
+			free (depend);
 		}
 	}
 
diff --git a/backends/alpm/pk-backend-install.c b/backends/alpm/pk-backend-install.c
index d0cbca2..0b036f3 100644
--- a/backends/alpm/pk-backend-install.c
+++ b/backends/alpm/pk-backend-install.c
@@ -39,7 +39,7 @@ alpm_add_file (const gchar *filename)
 	g_return_val_if_fail (filename != NULL, -1);
 	g_return_val_if_fail (alpm != NULL, -1);
 
-	level = alpm_option_get_default_siglevel (alpm);
+	level = alpm_option_get_local_file_siglevel (alpm);
 
 	if (alpm_pkg_load (alpm, filename, 1, level, &pkg) < 0) {
 		return -1;
@@ -66,7 +66,7 @@ pk_backend_transaction_add_targets (PkBackend *self, GError **error)
 
 	for (; *paths != NULL; ++paths) {
 		if (alpm_add_file (*paths) < 0) {
-			enum _alpm_errno_t errno = alpm_errno (alpm);
+			alpm_errno_t errno = alpm_errno (alpm);
 			g_set_error (error, ALPM_ERROR, errno, "%s: %s",
 				     *paths, alpm_strerror (errno));
 			return FALSE;
diff --git a/backends/alpm/pk-backend-packages.c b/backends/alpm/pk-backend-packages.c
index c90cd7d..86b1ef7 100644
--- a/backends/alpm/pk-backend-packages.c
+++ b/backends/alpm/pk-backend-packages.c
@@ -42,7 +42,7 @@ alpm_pkg_build_id (alpm_pkg_t *pkg)
 	}
 
 	/* TODO: check correctness */
-	if (alpm_pkg_get_origin (pkg) == PKG_FROM_SYNCDB) {
+	if (alpm_pkg_get_origin (pkg) == ALPM_PKG_FROM_SYNCDB) {
 		repo = alpm_db_get_name (alpm_pkg_get_db (pkg));
 	} else {
 		repo = "installed";
@@ -84,7 +84,7 @@ pk_backend_find_pkg (PkBackend *self, const gchar *package_id, GError **error)
 	if (g_strcmp0 (repo_id, "installed") == 0) {
 		db = localdb;
 	} else {
-		const alpm_list_t *i = alpm_option_get_syncdbs (alpm);
+		const alpm_list_t *i = alpm_get_syncdbs (alpm);
 		for (; i != NULL; i = i->next) {
 			const gchar *repo = alpm_db_get_name (i->data);
 
@@ -140,7 +140,7 @@ pk_backend_resolve_package (PkBackend *self, const gchar *package,
 					  PK_FILTER_ENUM_NOT_INSTALLED);
 	skip_remote = pk_bitfield_contain (filters, PK_FILTER_ENUM_INSTALLED);
 
-	if (alpm_pkg_get_origin (pkg) == PKG_FROM_LOCALDB) {
+	if (alpm_pkg_get_origin (pkg) == ALPM_PKG_FROM_LOCALDB) {
 		if (!skip_local) {
 			pk_backend_pkg (self, pkg, PK_INFO_ENUM_INSTALLED);
 		}
@@ -179,7 +179,7 @@ pk_backend_resolve_name (PkBackend *self, const gchar *name, GError **error)
 			return TRUE;
 		}
 	} else if (!skip_remote) {
-		const alpm_list_t *i = alpm_option_get_syncdbs (alpm);
+		const alpm_list_t *i = alpm_get_syncdbs (alpm);
 		for (; i != NULL; i = i->next) {
 			pkg = alpm_db_get_pkg (i->data, name);
 			if (pkg != NULL) {
@@ -287,7 +287,7 @@ pk_backend_get_details_thread (PkBackend *self)
 		desc = alpm_pkg_get_desc (pkg);
 		url = alpm_pkg_get_url (pkg);
 
-		if (alpm_pkg_get_origin (pkg) == PKG_FROM_LOCALDB) {
+		if (alpm_pkg_get_origin (pkg) == ALPM_PKG_FROM_LOCALDB) {
 			size = alpm_pkg_get_isize (pkg);
 		} else {
 			size = alpm_pkg_download_size (pkg);
diff --git a/backends/alpm/pk-backend-remove.c b/backends/alpm/pk-backend-remove.c
index 1993061..331684f 100644
--- a/backends/alpm/pk-backend-remove.c
+++ b/backends/alpm/pk-backend-remove.c
@@ -48,7 +48,7 @@ pk_backend_transaction_remove_targets (PkBackend *self, GError **error)
 
 		alpm_pkg_t *pkg = alpm_db_get_pkg (localdb, name);
 		if (pkg == NULL || alpm_remove_pkg (alpm, pkg) < 0) {
-			enum _alpm_errno_t errno = alpm_errno (alpm);
+			alpm_errno_t errno = alpm_errno (alpm);
 			g_set_error (error, ALPM_ERROR, errno, "%s: %s", name,
 				     alpm_strerror (errno));
 			g_strfreev (package);
diff --git a/backends/alpm/pk-backend-search.c b/backends/alpm/pk-backend-search.c
index c4e80ae..4cfeeb2 100644
--- a/backends/alpm/pk-backend-search.c
+++ b/backends/alpm/pk-backend-search.c
@@ -374,7 +374,7 @@ pk_backend_search_thread (PkBackend *self)
 		goto out;
 	}
 
-	for (i = alpm_option_get_syncdbs (alpm); i != NULL; i = i->next) {
+	for (i = alpm_get_syncdbs (alpm); i != NULL; i = i->next) {
 		if (pk_backend_cancelled (self)) {
 			break;
 		}
diff --git a/backends/alpm/pk-backend-sync.c b/backends/alpm/pk-backend-sync.c
index d2f363b..80d5ae0 100644
--- a/backends/alpm/pk-backend-sync.c
+++ b/backends/alpm/pk-backend-sync.c
@@ -48,7 +48,7 @@ pk_backend_transaction_sync_targets (PkBackend *self, GError **error)
 		gchar *repo = package[PK_PACKAGE_ID_DATA];
 		gchar *name = package[PK_PACKAGE_ID_NAME];
 
-		const alpm_list_t *i = alpm_option_get_syncdbs (alpm);
+		const alpm_list_t *i = alpm_get_syncdbs (alpm);
 		alpm_pkg_t *pkg;
 
 		for (; i != NULL; i = i->next) {
@@ -58,7 +58,7 @@ pk_backend_transaction_sync_targets (PkBackend *self, GError **error)
 		}
 
 		if (i == NULL) {
-			enum _alpm_errno_t errno = ALPM_ERR_DB_NOT_FOUND;
+			alpm_errno_t errno = ALPM_ERR_DB_NOT_FOUND;
 			g_set_error (error, ALPM_ERROR, errno, "%s/%s: %s",
 				     repo, name, alpm_strerror (errno));
 			g_strfreev (package);
@@ -67,7 +67,7 @@ pk_backend_transaction_sync_targets (PkBackend *self, GError **error)
 
 		pkg = alpm_db_get_pkg (i->data, name);
 		if (pkg == NULL || alpm_add_pkg (alpm, pkg) < 0) {
-			enum _alpm_errno_t errno = alpm_errno (alpm);
+			alpm_errno_t errno = alpm_errno (alpm);
 			g_set_error (error, ALPM_ERROR, errno, "%s/%s: %s",
 				     repo, name, alpm_strerror (errno));
 			g_strfreev (package);
@@ -274,7 +274,7 @@ pk_backend_update_packages_thread (PkBackend *self)
 	for (i = asdeps; i != NULL; i = i->next) {
 		const gchar *name = (const gchar *) i->data;
 		alpm_pkg_t *pkg = alpm_db_get_pkg (localdb, name);
-		alpm_db_set_pkgreason (alpm, pkg, ALPM_PKG_REASON_DEPEND);
+		alpm_pkg_set_reason (pkg, ALPM_PKG_REASON_DEPEND);
 	}
 
 out:
diff --git a/backends/alpm/pk-backend-transaction.c b/backends/alpm/pk-backend-transaction.c
index 76402f0..554f06d 100644
--- a/backends/alpm/pk-backend-transaction.c
+++ b/backends/alpm/pk-backend-transaction.c
@@ -63,7 +63,7 @@ alpm_pkg_has_basename (alpm_pkg_t *pkg, const gchar *basename)
 		return TRUE;
 	}
 
-	if (alpm_option_get_usedelta (alpm) == 0) {
+	if (alpm_option_get_deltaratio (alpm) == 0.0) {
 		return FALSE;
 	}
 
@@ -210,16 +210,18 @@ pk_backend_transaction_progress_cb (alpm_progress_t type, const gchar *target,
 	static gint recent = 101;
 	gsize overall = percent + (current - 1) * 100;
 
-	/* TODO: revert when fixed upstream */
+	/* TODO: remove block if/when this is made consistent upstream */
 	if (type == ALPM_PROGRESS_CONFLICTS_START ||
 	    type == ALPM_PROGRESS_DISKSPACE_START ||
 	    type == ALPM_PROGRESS_INTEGRITY_START ||
-	    type == ALPM_PROGRESS_LOAD_START) {
+	    type == ALPM_PROGRESS_LOAD_START ||
+	    type == ALPM_PROGRESS_KEYRING_START) {
 		if (current < targets) {
-			overall = percent + current++ * 100;
+			++current;
+			overall += 100;
 		}
 	}
-	
+
 	if (current < 1 || targets < current) {
 		g_warning ("TODO: CURRENT/TARGETS FAILED for %d", type);
 	}
@@ -233,11 +235,14 @@ pk_backend_transaction_progress_cb (alpm_progress_t type, const gchar *target,
 	switch (type) {
 		case ALPM_PROGRESS_ADD_START:
 		case ALPM_PROGRESS_UPGRADE_START:
+		case ALPM_PROGRESS_DOWNGRADE_START:
+		case ALPM_PROGRESS_REINSTALL_START:
 		case ALPM_PROGRESS_REMOVE_START:
 		case ALPM_PROGRESS_CONFLICTS_START:
 		case ALPM_PROGRESS_DISKSPACE_START:
 		case ALPM_PROGRESS_INTEGRITY_START:
 		case ALPM_PROGRESS_LOAD_START:
+		case ALPM_PROGRESS_KEYRING_START:
 			if (percent == recent) {
 				break;
 			}
@@ -316,7 +321,6 @@ pk_backend_transaction_conv_cb (alpm_question_t question, gpointer data1,
 		case ALPM_QUESTION_REPLACE_PKG:
 		case ALPM_QUESTION_CONFLICT_PKG:
 		case ALPM_QUESTION_CORRUPTED_PKG:
-		case ALPM_QUESTION_LOCAL_NEWER:
 			/* these actions are mostly harmless */
 			g_debug ("safe question %d", question);
 			*result = 1;
@@ -388,6 +392,17 @@ pk_backend_output (PkBackend *self, const gchar *output)
 }
 
 static void
+pk_backend_output_once (PkBackend *self, alpm_pkg_t *pkg, const gchar *output)
+{
+	g_return_if_fail (self != NULL);
+	g_return_if_fail (pkg != NULL);
+	g_return_if_fail (output != NULL);
+
+	pk_backend_message (self, PK_MESSAGE_ENUM_UNKNOWN, "<b>%s</b>\n%s",
+			    alpm_pkg_get_name (pkg), output);
+}
+
+static void
 pk_backend_transaction_dep_resolve (PkBackend *self)
 {
 	g_return_if_fail (self != NULL);
@@ -427,7 +442,8 @@ pk_backend_transaction_add_done (PkBackend *self, alpm_pkg_t *pkg)
 	name = alpm_pkg_get_name (pkg);
 	version = alpm_pkg_get_version (pkg);
 
-	alpm_logaction (alpm, "installed %s (%s)\n", name, version);
+	alpm_logaction (alpm, PK_LOG_PREFIX, "installed %s (%s)\n", name,
+			version);
 	pk_backend_pkg (self, pkg, PK_INFO_ENUM_FINISHED);
 
 	optdepends = alpm_pkg_get_optdepends (pkg);
@@ -435,8 +451,10 @@ pk_backend_transaction_add_done (PkBackend *self, alpm_pkg_t *pkg)
 		pk_backend_output (self, "Optional dependencies:\n");
 
 		for (i = optdepends; i != NULL; i = i->next) {
-			const gchar *depend = i->data;
+			gchar *depend = alpm_dep_compute_string (i->data);
 			gchar *output = g_strdup_printf ("%s\n", depend);
+			free (depend);
+
 			pk_backend_output (self, output);
 			g_free (output);
 		}
@@ -467,7 +485,8 @@ pk_backend_transaction_remove_done (PkBackend *self, alpm_pkg_t *pkg)
 	name = alpm_pkg_get_name (pkg);
 	version = alpm_pkg_get_version (pkg);
 
-	alpm_logaction (alpm, "removed %s (%s)\n", name, version);
+	alpm_logaction (alpm, PK_LOG_PREFIX, "removed %s (%s)\n", name,
+			version);
 	pk_backend_pkg (self, pkg, PK_INFO_ENUM_FINISHED);
 	pk_backend_output_end (self);
 }
@@ -498,45 +517,106 @@ pk_backend_transaction_upgrade_start (PkBackend *self, alpm_pkg_t *pkg,
 	pk_backend_output_start (self, pkg);
 }
 
+static gint
+alpm_depend_compare (gconstpointer a, gconstpointer b)
+{
+	const alpm_depend_t *first = a;
+	const alpm_depend_t *second = b;
+	gint result;
+
+	g_return_val_if_fail (first != NULL, 0);
+	g_return_val_if_fail (second != NULL, 0);
+
+	result = g_strcmp0 (first->name, second->name);
+	if (result == 0) {
+		result = first->mod - second->mod;
+		if (result == 0) {
+			result = g_strcmp0 (first->version, second->version);
+			if (result == 0) {
+				result = g_strcmp0 (first->desc, second->desc);
+			}
+		}
+	}
+
+	return result;
+}
+
 static void
-pk_backend_transaction_upgrade_done (PkBackend *self, alpm_pkg_t *pkg,
-				     alpm_pkg_t *old)
+pk_backend_transaction_process_new_optdepends (PkBackend *self, alpm_pkg_t *pkg,
+					       alpm_pkg_t *old)
 {
-	const gchar *name, *pre, *post;
-	const alpm_list_t *i;
 	alpm_list_t *optdepends;
+	const alpm_list_t *i;
 
 	g_return_if_fail (self != NULL);
 	g_return_if_fail (pkg != NULL);
 	g_return_if_fail (old != NULL);
+
+	optdepends = alpm_list_diff (alpm_pkg_get_optdepends (pkg),
+				     alpm_pkg_get_optdepends (old),
+				     alpm_depend_compare);
+	if (optdepends == NULL) {
+		return;
+	}
+
+	pk_backend_output (self, "New optional dependencies:\n");
+
+	for (i = optdepends; i != NULL; i = i->next) {
+		gchar *depend = alpm_dep_compute_string (i->data);
+		gchar *output = g_strdup_printf ("%s\n", depend);
+		free (depend);
+
+		pk_backend_output (self, output);
+		g_free (output);
+	}
+
+	alpm_list_free (optdepends);
+}
+
+static void
+pk_backend_transaction_upgrade_done (PkBackend *self, alpm_pkg_t *pkg,
+				     alpm_pkg_t *old, gint direction)
+{
+	const gchar *name, *pre, *post;
+
+	g_return_if_fail (self != NULL);
+	g_return_if_fail (pkg != NULL);
+	g_return_if_fail (old != NULL || direction == 0);
 	g_return_if_fail (alpm != NULL);
 
 	name = alpm_pkg_get_name (pkg);
-	pre = alpm_pkg_get_version (old);
+	if (direction != 0) {
+		pre = alpm_pkg_get_version (old);
+	}
 	post = alpm_pkg_get_version (pkg);
 
-	alpm_logaction (alpm, "upgraded %s (%s -> %s)\n", name, pre, post);
+	if (direction > 0) {
+		alpm_logaction (alpm, PK_LOG_PREFIX, "upgraded %s (%s -> %s)\n",
+				name, pre, post);
+	} else if (direction < 0) {
+		alpm_logaction (alpm, PK_LOG_PREFIX,
+				"downgraded %s (%s -> %s)\n", name, pre, post);
+	} else {
+		alpm_logaction (alpm, PK_LOG_PREFIX, "reinstalled %s (%s)\n",
+				name, post);
+	}
 	pk_backend_pkg (self, pkg, PK_INFO_ENUM_FINISHED);
 
-	optdepends = alpm_list_diff (alpm_pkg_get_optdepends (pkg),
-				     alpm_pkg_get_optdepends (old),
-				     (alpm_list_fn_cmp) g_strcmp0);
-	if (optdepends != NULL) {
-		pk_backend_output (self, "New optional dependencies:\n");
-
-		for (i = optdepends; i != NULL; i = i->next) {
-			const gchar *depend = i->data;
-			gchar *output = g_strdup_printf ("%s\n", depend);
-			pk_backend_output (self, output);
-			g_free (output);
-		}
-
-		alpm_list_free (optdepends);
+	if (direction != 0) {
+		pk_backend_transaction_process_new_optdepends (self, pkg, old);
 	}
 	pk_backend_output_end (self);
 }
 
 static void
+pk_backend_transaction_sig_check (PkBackend *self)
+{
+	g_return_if_fail (self != NULL);
+
+	pk_backend_set_status (self, PK_STATUS_ENUM_SIG_CHECK);
+}
+
+static void
 pk_backend_transaction_setup (PkBackend *self)
 {
 	g_return_if_fail (self != NULL);
@@ -545,12 +625,46 @@ pk_backend_transaction_setup (PkBackend *self)
 }
 
 static void
+pk_backend_transaction_repackaging (PkBackend *self)
+{
+	g_return_if_fail (self != NULL);
+
+	pk_backend_set_status (self, PK_STATUS_ENUM_REPACKAGING);
+}
+
+static void
+pk_backend_transaction_download (PkBackend *self)
+{
+	g_return_if_fail (self != NULL);
+
+	pk_backend_set_status (self, PK_STATUS_ENUM_DOWNLOAD);
+}
+
+static void
+pk_backend_transaction_optdepend_required (PkBackend *self, alpm_pkg_t *pkg,
+					   alpm_depend_t *optdepend)
+{
+	gchar *depend, *output;
+
+	g_return_if_fail (self != NULL);
+	g_return_if_fail (pkg != NULL);
+	g_return_if_fail (optdepend != NULL);
+
+	depend = alpm_dep_compute_string (optdepend);
+	output = g_strdup_printf ("optionally requires %s\n", depend);
+	free (depend);
+
+	pk_backend_output_once (self, pkg, output);
+	g_free (output);
+}
+
+static void
 pk_backend_transaction_event_cb (alpm_event_t event, gpointer data,
 				 gpointer old)
 {
 	g_return_if_fail (backend != NULL);
 
-	/* figure out the backend status and package info */
+	/* figure out backend status and process package changes */
 	switch (event) {
 		case ALPM_EVENT_CHECKDEPS_START:
 		case ALPM_EVENT_RESOLVEDEPS_START:
@@ -559,7 +673,6 @@ pk_backend_transaction_event_cb (alpm_event_t event, gpointer data,
 
 		case ALPM_EVENT_FILECONFLICTS_START:
 		case ALPM_EVENT_INTERCONFLICTS_START:
-		case ALPM_EVENT_INTEGRITY_START:
 		case ALPM_EVENT_DELTA_INTEGRITY_START:
 		case ALPM_EVENT_DISKSPACE_START:
 			pk_backend_transaction_test_commit (backend);
@@ -582,23 +695,73 @@ pk_backend_transaction_event_cb (alpm_event_t event, gpointer data,
 			break;
 
 		case ALPM_EVENT_UPGRADE_START:
+		case ALPM_EVENT_DOWNGRADE_START:
+		case ALPM_EVENT_REINSTALL_START:
 			pk_backend_transaction_upgrade_start (backend, data,
 							      old);
 			break;
 
 		case ALPM_EVENT_UPGRADE_DONE:
 			pk_backend_transaction_upgrade_done (backend, data,
-							     old);
+							     old, 1);
+			break;
+
+		case ALPM_EVENT_DOWNGRADE_DONE:
+			pk_backend_transaction_upgrade_done (backend, data,
+							     old, -1);
+			break;
+
+		case ALPM_EVENT_REINSTALL_DONE:
+			pk_backend_transaction_upgrade_done (backend, data,
+							     old, 0);
+			break;
+
+		case ALPM_EVENT_INTEGRITY_START:
+		case ALPM_EVENT_KEYRING_START:
+			pk_backend_transaction_sig_check (backend);
 			break;
 
 		case ALPM_EVENT_LOAD_START:
 			pk_backend_transaction_setup (backend);
 			break;
 
+		case ALPM_EVENT_DELTA_PATCHES_START:
+		case ALPM_EVENT_DELTA_PATCH_START:
+			pk_backend_transaction_repackaging (backend);
+			break;
+
 		case ALPM_EVENT_SCRIPTLET_INFO:
 			pk_backend_output (backend, data);
 			break;
 
+		case ALPM_EVENT_RETRIEVE_START:
+			pk_backend_transaction_download (backend);
+			break;
+
+		case ALPM_EVENT_OPTDEP_REQUIRED:
+			/* TODO: remove if this results in notification spam */
+			pk_backend_transaction_optdepend_required (backend,
+								   data, old);
+			break;
+
+		case ALPM_EVENT_CHECKDEPS_DONE:
+		case ALPM_EVENT_FILECONFLICTS_DONE:
+		case ALPM_EVENT_RESOLVEDEPS_DONE:
+		case ALPM_EVENT_INTERCONFLICTS_DONE:
+		case ALPM_EVENT_INTEGRITY_DONE:
+		case ALPM_EVENT_LOAD_DONE:
+		case ALPM_EVENT_DELTA_INTEGRITY_DONE:
+		case ALPM_EVENT_DELTA_PATCHES_DONE:
+		case ALPM_EVENT_DELTA_PATCH_DONE:
+		case ALPM_EVENT_DELTA_PATCH_FAILED:
+		case ALPM_EVENT_DISKSPACE_DONE:
+		case ALPM_EVENT_DATABASE_MISSING:
+		case ALPM_EVENT_KEYRING_DONE:
+		case ALPM_EVENT_KEY_DOWNLOAD_START:
+		case ALPM_EVENT_KEY_DOWNLOAD_DONE:
+			/* ignored */
+			break;
+
 		default:
 			g_debug ("unhandled event %d", event);
 			break;
@@ -623,7 +786,7 @@ pk_backend_transaction_initialize (PkBackend *self, alpm_transflag_t flags,
 	g_return_val_if_fail (cancellable != NULL, FALSE);
 
 	if (alpm_trans_init (alpm, flags) < 0) {
-		enum _alpm_errno_t errno = alpm_errno (alpm);
+		alpm_errno_t errno = alpm_errno (alpm);
 		g_set_error_literal (error, ALPM_ERROR, errno,
 				     alpm_strerror (errno));
 		return FALSE;
@@ -692,6 +855,7 @@ alpm_depend_free (alpm_depend_t *depend)
 {
 	free (depend->name);
 	free (depend->version);
+	free (depend->desc);
 	free (depend);
 }
 
@@ -731,7 +895,7 @@ alpm_conflict_build_list (const alpm_list_t *i)
 			g_string_append_printf (list, "%s <-> %s (%s), ",
 						conflict->package1,
 						conflict->package2, reason);
-			g_free (reason);
+			free (reason);
 		}
 	}
 
@@ -837,12 +1001,12 @@ pk_backend_transaction_simulate (PkBackend *self, GError **error)
 	}
 
 	if (prefix != NULL) {
-		enum _alpm_errno_t errno = alpm_errno (alpm);
+		alpm_errno_t errno = alpm_errno (alpm);
 		g_set_error (error, ALPM_ERROR, errno, "%s: %s", prefix,
 			     alpm_strerror (errno));
 		g_free (prefix);
 	} else {
-		enum _alpm_errno_t errno = alpm_errno (alpm);
+		alpm_errno_t errno = alpm_errno (alpm);
 		g_set_error_literal (error, ALPM_ERROR, errno,
 				     alpm_strerror (errno));
 	}
@@ -959,12 +1123,12 @@ pk_backend_transaction_commit (PkBackend *self, GError **error)
 	}
 
 	if (prefix != NULL) {
-		enum _alpm_errno_t errno = alpm_errno (alpm);
+		alpm_errno_t errno = alpm_errno (alpm);
 		g_set_error (error, ALPM_ERROR, errno, "%s: %s", prefix,
 			     alpm_strerror (errno));
 		g_free (prefix);
 	} else {
-		enum _alpm_errno_t errno = alpm_errno (alpm);
+		alpm_errno_t errno = alpm_errno (alpm);
 		g_set_error_literal (error, ALPM_ERROR, errno,
 				     alpm_strerror (errno));
 	}
@@ -993,7 +1157,7 @@ pk_backend_transaction_end (PkBackend *self, GError **error)
 	}
 
 	if (alpm_trans_release (alpm) < 0) {
-		enum _alpm_errno_t errno = alpm_errno (alpm);
+		alpm_errno_t errno = alpm_errno (alpm);
 		g_set_error_literal (error, ALPM_ERROR, errno,
 				     alpm_strerror (errno));
 		return FALSE;
diff --git a/backends/alpm/pk-backend-update.c b/backends/alpm/pk-backend-update.c
index 37ade1e..ff83b5e 100644
--- a/backends/alpm/pk-backend-update.c
+++ b/backends/alpm/pk-backend-update.c
@@ -130,6 +130,20 @@ alpm_pkg_same_pkgver (alpm_pkg_t *a, alpm_pkg_t *b)
 	}
 }
 
+static gchar *
+alpm_time_to_iso8601 (alpm_time_t time)
+{
+	GDateTime *date = g_date_time_new_from_unix_utc (time);
+
+	if (date != NULL) {
+		gchar *result = g_date_time_format (date, "%FT%TZ");
+		g_date_time_unref (date);
+		return result;
+	} else {
+		return NULL;
+	}
+}
+
 static gboolean
 pk_backend_get_update_detail_thread (PkBackend *self)
 {
@@ -154,7 +168,7 @@ pk_backend_get_update_detail_thread (PkBackend *self)
 		PkRestartEnum restart;
 		PkUpdateStateEnum state;
 
-		GTimeVal built = { 0 }, installed = { 0 };
+		alpm_time_t built, installed;
 		gchar *issued, *updated;
 
 		if (pk_backend_cancelled (self)) {
@@ -195,17 +209,17 @@ pk_backend_get_update_detail_thread (PkBackend *self)
 			state = PK_UPDATE_STATE_ENUM_STABLE;
 		}
 
-		built.tv_sec = alpm_pkg_get_builddate (pkg);
-		if (built.tv_sec > 0) {
-			issued = g_time_val_to_iso8601 (&built);
+		built = alpm_pkg_get_builddate (pkg);
+		if (built > 0) {
+			issued = alpm_time_to_iso8601 (built);
 		} else {
 			issued = NULL;
 		}
 
 		if (upgrades != NULL) {
-			installed.tv_sec = alpm_pkg_get_installdate (old);
-			if (installed.tv_sec > 0) {
-				updated = g_time_val_to_iso8601 (&installed);
+			installed = alpm_pkg_get_installdate (old);
+			if (installed > 0) {
+				updated = alpm_time_to_iso8601 (installed);
 			} else {
 				updated = NULL;
 			}
@@ -251,13 +265,14 @@ pk_backend_update_databases (PkBackend *self, gint force, GError **error) {
 		return FALSE;
 	}
 
-	alpm_logaction (alpm, "synchronizing package lists\n");
+	alpm_logaction (alpm, PK_LOG_PREFIX, "synchronizing package lists\n");
+	pk_backend_set_status (self, PK_STATUS_ENUM_DOWNLOAD_PACKAGELIST);
 
 	dlcb = alpm_option_get_dlcb (alpm);
 	totaldlcb = alpm_option_get_totaldlcb (alpm);
 
 	/* set total size to minus the number of databases */
-	i = alpm_option_get_syncdbs (alpm);
+	i = alpm_get_syncdbs (alpm);
 	totaldlcb (-alpm_list_count (i));
 
 	for (; i != NULL; i = i->next) {
@@ -275,7 +290,7 @@ pk_backend_update_databases (PkBackend *self, gint force, GError **error) {
 			/* fake the download when already up to date */
 			dlcb ("", 1, 1);
 		} else if (result < 0) {
-			enum _alpm_errno_t errno = alpm_errno (alpm);
+			alpm_errno_t errno = alpm_errno (alpm);
 			g_set_error (error, ALPM_ERROR, errno, "[%s]: %s",
 				     alpm_db_get_name (i->data),
 				     alpm_strerror (errno));
@@ -398,7 +413,7 @@ pk_backend_get_updates_thread (PkBackend *self)
 	}
 
 	/* find outdated and replacement packages */
-	syncdbs = alpm_option_get_syncdbs (alpm);
+	syncdbs = alpm_get_syncdbs (alpm);
 	for (i = alpm_db_get_pkgcache (localdb); i != NULL; i = i->next) {
 		alpm_pkg_t *upgrade = alpm_pkg_find_update (i->data, syncdbs);
 
diff --git a/configure.ac b/configure.ac
index 37e8a64..4a33dbd 100644
--- a/configure.ac
+++ b/configure.ac
@@ -707,9 +707,7 @@ if test x$enable_opkg = xyes; then
 fi
 
 if test x$enable_alpm = xyes; then
-	AC_CHECK_HEADER([alpm.h],
-			[],
-			[AC_MSG_ERROR([No ALPM headers found])])
+	PKG_CHECK_MODULES(ALPM, libalpm >= 8.0.1)
 fi
 
 if test x$enable_poldek = xyes; then
