diff --git a/src/doc/common/conf.py b/src/doc/common/conf.py
index 00b10dc..ddc0ffb 100644
--- a/src/doc/common/conf.py
+++ b/src/doc/common/conf.py
@@ -703,9 +703,9 @@ base_class_as_func = [
 # link to the Python documentation several links where broken because there
 # where class listed as functions. Expand the list 'base_class_as_func'
 # above instead of marking the link as broken.
-nitpick_ignore = (
+nitpick_ignore = [
     ('py:class', 'twisted.web2.resource.Resource'),
-    ('py:class', 'twisted.web2.resource.PostableResource'))
+    ('py:class', 'twisted.web2.resource.PostableResource')]
 
 def nitpick_patch_config(app):
     """
diff --git a/src/doc/common/sage_autodoc.py b/src/doc/common/sage_autodoc.py
index 7f71b9c..9c223f8 100644
--- a/src/doc/common/sage_autodoc.py
+++ b/src/doc/common/sage_autodoc.py
@@ -9,7 +9,7 @@
     the doctree, thus avoiding duplication between docstrings and documentation
     for those who like elaborate docstrings.
 
-    :copyright: Copyright 2007-2009 by the Sphinx team, see AUTHORS.
+    :copyright: Copyright 2007-2015 by the Sphinx team, see AUTHORS.
     :license: BSD, see LICENSE for details.
 
     AUTHORS:
@@ -24,29 +24,27 @@
 import re
 import sys
 import inspect
-from types import FunctionType, BuiltinFunctionType, MethodType, ClassType
+import traceback
+from types import FunctionType, BuiltinFunctionType, MethodType
 
+from six import iteritems, itervalues, text_type, class_types, string_types
 from docutils import nodes
 from docutils.utils import assemble_option_dict
 from docutils.statemachine import ViewList
 
-from sphinx.util import rpartition, nested_parse_with_titles, force_decode
+from sphinx.util import rpartition, force_decode
 from sphinx.locale import _
 from sphinx.pycode import ModuleAnalyzer, PycodeError
 from sphinx.application import ExtensionError
+from sphinx.util.nodes import nested_parse_with_titles
 from sphinx.util.compat import Directive
-from sphinx.util.inspect import isdescriptor, safe_getmembers, safe_getattr
+from sphinx.util.inspect import getargspec, isdescriptor, safe_getmembers, \
+    safe_getattr, object_description, is_builtin_class_method
 from sphinx.util.docstrings import prepare_docstring
 
 from sage.misc.sageinspect import sage_getdoc_original, sage_getargspec, isclassinstance
 from sage.misc.lazy_import import LazyImport
 
-try:
-    base_exception = BaseException
-except NameError:
-    base_exception = Exception
-
-
 #: extended signature RE: with explicit module name separated by ::
 py_ext_sig_re = re.compile(
     r'''^ ([\w.]+::)?            # explicit module name
@@ -63,16 +61,21 @@ class DefDict(dict):
     def __init__(self, default):
         dict.__init__(self)
         self.default = default
+
     def __getitem__(self, key):
         try:
             return dict.__getitem__(self, key)
         except KeyError:
             return self.default
-    def __nonzero__(self):
+
+    def __bool__(self):
         # docutils check "if option_spec"
         return True
+    __nonzero__ = __bool__  # for python2 compatibility
+
 
-identity = lambda x: x
+def identity(x):
+    return x
 
 
 class Options(dict):
@@ -84,7 +87,39 @@ class Options(dict):
             return None
 
 
+class _MockModule(object):
+    """Used by autodoc_mock_imports."""
+    def __init__(self, *args, **kwargs):
+        pass
+
+    def __call__(self, *args, **kwargs):
+        return _MockModule()
+
+    @classmethod
+    def __getattr__(cls, name):
+        if name in ('__file__', '__path__'):
+            return '/dev/null'
+        elif name[0] == name[0].upper():
+            # Not very good, we assume Uppercase names are classes...
+            mocktype = type(name, (), {})
+            mocktype.__module__ = __name__
+            return mocktype
+        else:
+            return _MockModule()
+
+
+def mock_import(modname):
+    if '.' in modname:
+        pkg, _n, mods = modname.rpartition('.')
+        mock_import(pkg)
+    mod = _MockModule()
+    sys.modules[modname] = mod
+    return mod
+
+
 ALL = object()
+INSTANCEATTR = object()
+
 
 def members_option(arg):
     """Used to convert the :members: option to auto directives."""
@@ -92,15 +127,28 @@ def members_option(arg):
         return ALL
     return [x.strip() for x in arg.split(',')]
 
+
 def members_set_option(arg):
     """Used to convert the :members: option to auto directives."""
     if arg is None:
         return ALL
     return set(x.strip() for x in arg.split(','))
 
+SUPPRESS = object()
+
+
+def annotation_option(arg):
+    if arg is None:
+        # suppress showing the representation of the object
+        return SUPPRESS
+    else:
+        return arg
+
+
 def bool_option(arg):
     """Used to convert flag options to auto directives.  (Instead of
-    directives.flag(), which returns None.)"""
+    directives.flag(), which returns None).
+    """
     return True
 
 
@@ -117,7 +165,7 @@ class AutodocReporter(object):
         return getattr(self.reporter, name)
 
     def system_message(self, level, message, *children, **kwargs):
-        if 'line' in kwargs:
+        if 'line' in kwargs and 'source' not in kwargs:
             try:
                 source, line = self.viewlist.items[kwargs['line']]
             except IndexError:
@@ -148,8 +196,7 @@ class AutodocReporter(object):
 # Some useful event listener factories for autodoc-process-docstring.
 
 def cut_lines(pre, post=0, what=None):
-    """
-    Return a listener that removes the first *pre* and last *post*
+    """Return a listener that removes the first *pre* and last *post*
     lines of every docstring.  If *what* is a sequence of strings,
     only docstrings of a type in *what* will be processed.
 
@@ -174,21 +221,23 @@ def cut_lines(pre, post=0, what=None):
             lines.append('')
     return process
 
-def between(marker, what=None, keepempty=False):
-    """
-    Return a listener that only keeps lines between lines that match the
-    *marker* regular expression.  If no line matches, the resulting docstring
-    would be empty, so no change will be made unless *keepempty* is true.
+
+def between(marker, what=None, keepempty=False, exclude=False):
+    """Return a listener that either keeps, or if *exclude* is True excludes,
+    lines between lines that match the *marker* regular expression.  If no line
+    matches, the resulting docstring would be empty, so no change will be made
+    unless *keepempty* is true.
 
     If *what* is a sequence of strings, only docstrings of a type in *what* will
     be processed.
     """
     marker_re = re.compile(marker)
+
     def process(app, what_, name, obj, options, lines):
         if what and what_ not in what:
             return
         deleted = 0
-        delete = True
+        delete = not exclude
         orig_lines = lines[:]
         for i, line in enumerate(orig_lines):
             if delete:
@@ -206,6 +255,12 @@ def between(marker, what=None, keepempty=False):
             lines.append('')
     return process
 
+
+def formatargspec(*argspec):
+    return inspect.formatargspec(*argspec,
+                                 formatvalue=lambda x: '=' + object_description(x))
+
+
 class Documenter(object):
     """
     A Documenter knows how to autodocument a single object type.  When
@@ -230,13 +285,15 @@ class Documenter(object):
     priority = 0
     #: order if autodoc_member_order is set to 'groupwise'
     member_order = 0
+    #: true if the generated content may contain titles
+    titles_allowed = False
 
     option_spec = {'noindex': bool_option}
 
     @staticmethod
     def get_attr(obj, name, *defargs):
         """getattr() override for types such as Zope interfaces."""
-        for typ, func in AutoDirective._special_attrgetters.iteritems():
+        for typ, func in iteritems(AutoDirective._special_attrgetters):
             if isinstance(obj, typ):
                 return func(obj, name, *defargs)
         return safe_getattr(obj, name, *defargs)
@@ -264,6 +321,9 @@ class Documenter(object):
         self.retann = None
         # the object to document (set after import_object succeeds)
         self.object = None
+        self.object_name = None
+        # the parent/owner of the object to document
+        self.parent = None
         # the module analyzer to get at attribute docs, or None
         self.analyzer = None
 
@@ -272,8 +332,7 @@ class Documenter(object):
         self.directive.result.append(self.indent + line, source, *lineno)
 
     def resolve_name(self, modname, parents, path, base):
-        """
-        Resolve the module and name of the object to document given by the
+        """Resolve the module and name of the object to document given by the
         arguments and the current module/class.
 
         Must return a pair of the module name and a chain of attributes; for
@@ -283,8 +342,7 @@ class Documenter(object):
         raise NotImplementedError('must be implemented in subclasses')
 
     def parse_name(self):
-        """
-        Determine what module to import and what attribute to document.
+        """Determine what module to import and what attribute to document.
 
         Returns True and sets *self.modname*, *self.objpath*, *self.fullname*,
         *self.args* and *self.retann* if parsing and resolving was successful.
@@ -294,7 +352,7 @@ class Documenter(object):
         # an autogenerated one
         try:
             explicit_modname, path, base, args, retann = \
-                 py_ext_sig_re.match(self.name).groups()
+                py_ext_sig_re.match(self.name).groups()
         except AttributeError:
             self.directive.warn('invalid signature for auto%s (%r)' %
                                 (self.objtype, self.name))
@@ -309,7 +367,7 @@ class Documenter(object):
             parents = []
 
         self.modname, self.objpath = \
-                      self.resolve_name(modname, parents, path, base)
+            self.resolve_name(modname, parents, path, base)
 
         if not self.modname:
             return False
@@ -321,53 +379,94 @@ class Documenter(object):
         return True
 
     def import_object(self):
-        """
-        Import the object given by *self.modname* and *self.objpath* and sets
+        """Import the object given by *self.modname* and *self.objpath* and set
         it as *self.object*.
 
         Returns True if successful, False if an error occurred.
         """
+        dbg = self.env.app.debug
+        if self.objpath:
+            dbg('[autodoc] from %s import %s',
+                self.modname, '.'.join(self.objpath))
         try:
+            dbg('[autodoc] import %s', self.modname)
+            for modname in self.env.config.autodoc_mock_imports:
+                dbg('[autodoc] adding a mock module %s!', self.modname)
+                mock_import(modname)
             __import__(self.modname)
+            parent = None
             obj = self.module = sys.modules[self.modname]
+            dbg('[autodoc] => %r', obj)
             for part in self.objpath:
+                parent = obj
+                dbg('[autodoc] getattr(_, %r)', part)
                 obj = self.get_attr(obj, part)
+                dbg('[autodoc] => %r', obj)
+                self.object_name = part
+            self.parent = parent
             self.object = obj
             return True
-        except (SyntaxError, ImportError, AttributeError) as err:
-            self.directive.warn(
-                'autodoc can\'t import/find %s %r, it reported error: '
-                '"%s", please check your spelling and sys.path' %
-                (self.objtype, str(self.fullname), err))
+        # this used to only catch SyntaxError, ImportError and AttributeError,
+        # but importing modules with side effects can raise all kinds of errors
+        except (Exception, SystemExit) as e:
+            if self.objpath:
+                errmsg = 'autodoc: failed to import %s %r from module %r' % \
+                         (self.objtype, '.'.join(self.objpath), self.modname)
+            else:
+                errmsg = 'autodoc: failed to import %s %r' % \
+                         (self.objtype, self.fullname)
+            if isinstance(e, SystemExit):
+                errmsg += ('; the module executes module level statement ' +
+                           'and it might call sys.exit().')
+            else:
+                errmsg += '; the following exception was raised:\n%s' % \
+                          traceback.format_exc()
+            dbg(errmsg)
+            self.directive.warn(errmsg)
+            self.env.note_reread()
             return False
 
     def get_real_modname(self):
-        """
-        Get the real module name of an object to document.  (It can differ
-        from the name of the module through which the object was imported.)
+        """Get the real module name of an object to document.
+
+        It can differ from the name of the module through which the object was
+        imported.
         """
         return self.get_attr(self.object, '__module__', None) or self.modname
 
     def check_module(self):
-        """
-        Check if *self.object* is really defined in the module given by
+        """Check if *self.object* is really defined in the module given by
         *self.modname*.
         """
+        if self.options.imported_members:
+            return True
+
         modname = self.get_attr(self.object, '__module__', None)
         if modname and modname != self.modname:
             return False
         return True
 
     def format_args(self):
-        """
-        Format the argument signature of *self.object*.  Should return None if
-        the object does not have a signature.
+        """Format the argument signature of *self.object*.
+
+        Should return None if the object does not have a signature.
         """
         return None
 
-    def format_signature(self):
+    def format_name(self):
+        """Format the name of *self.object*.
+
+        This normally should be something that can be parsed by the generated
+        directive, but doesn't need to be (Sphinx will display it unparsed
+        then).
         """
-        Format the signature (arguments and return annotation) of the object.
+        # normally the name doesn't contain the module (except for module
+        # directives of course)
+        return '.'.join(self.objpath) or self.modname
+
+    def format_signature(self):
+        """Format the signature (arguments and return annotation) of the object.
+
         Let the user process it via the ``autodoc-process-signature`` event.
         """
         if self.args is not None:
@@ -375,9 +474,13 @@ class Documenter(object):
             args = "(%s)" % self.args
         else:
             # try to introspect the signature
-            args = self.format_args()
-        if args is None:
-            return ''
+            try:
+                args = self.format_args()
+            except Exception as err:
+                self.directive.warn('error while formatting arguments for '
+                                    '%s: %s' % (self.fullname, err))
+                args = None
+
         retann = self.retann
 
         result = self.env.app.emit_firstresult(
@@ -393,26 +496,30 @@ class Documenter(object):
 
     def add_directive_header(self, sig):
         """Add the directive header and options to the generated content."""
+        domain = getattr(self, 'domain', 'py')
         directive = getattr(self, 'directivetype', self.objtype)
-        # the name to put into the generated directive -- doesn't contain
-        # the module (except for module directive of course)
-        name_in_directive = '.'.join(self.objpath) or self.modname
-        self.add_line(u'.. %s:: %s%s' % (directive, name_in_directive, sig),
-                      '<autodoc>')
+        name = self.format_name()
+        sourcename = self.get_sourcename()
+        self.add_line(u'.. %s:%s:: %s%s' % (domain, directive, name, sig),
+                      sourcename)
         if self.options.noindex:
-            self.add_line(u'   :noindex:', '<autodoc>')
+            self.add_line(u'   :noindex:', sourcename)
         if self.objpath:
             # Be explicit about the module, this is necessary since .. class::
             # etc. don't support a prepended module name
-            self.add_line(u'   :module: %s' % self.modname, '<autodoc>')
+            self.add_line(u'   :module: %s' % self.modname, sourcename)
 
-    def get_doc(self, encoding=None):
+    def get_doc(self, encoding=None, ignore=1):
         """Decode and return lines of the docstring(s) for the object."""
         docstring = sage_getdoc_original(self.object)
-        if docstring:
-            # make sure we have Unicode docstrings, then sanitize and split
-            # into lines
-            return [prepare_docstring(force_decode(docstring, encoding))]
+        # make sure we have Unicode docstrings, then sanitize and split
+        # into lines
+        if isinstance(docstring, text_type):
+            return [prepare_docstring(docstring, ignore)]
+        elif isinstance(docstring, str):  # this will not trigger on Py3
+            return [prepare_docstring(force_decode(docstring, encoding),
+                                      ignore)]
+        # ... else it is something strange, let's ignore it
         return []
 
     def process_doc(self, docstrings):
@@ -426,15 +533,22 @@ class Documenter(object):
             for line in docstringlines:
                 yield line
 
+    def get_sourcename(self):
+        if self.analyzer:
+            # prevent encoding errors when the file name is non-ASCII
+            if not isinstance(self.analyzer.srcname, text_type):
+                filename = text_type(self.analyzer.srcname,
+                                     sys.getfilesystemencoding(), 'replace')
+            else:
+                filename = self.analyzer.srcname
+            return u'%s:docstring of %s' % (filename, self.fullname)
+        return u'docstring of %s' % self.fullname
+
     def add_content(self, more_content, no_docstring=False):
         """Add content from docstrings, attribute documentation and user."""
         # set sourcename and add content from attribute documentation
+        sourcename = self.get_sourcename()
         if self.analyzer:
-            # prevent encoding errors when the file name is non-ASCII
-            filename = unicode(self.analyzer.srcname,
-                               sys.getfilesystemencoding(), 'replace')
-            sourcename = u'%s:docstring of %s' % (filename, self.fullname)
-
             attr_docs = self.analyzer.find_attr_docs()
             if self.objpath:
                 key = ('.'.join(self.objpath[:-1]), self.objpath[-1])
@@ -443,13 +557,16 @@ class Documenter(object):
                     docstrings = [attr_docs[key]]
                     for i, line in enumerate(self.process_doc(docstrings)):
                         self.add_line(line, sourcename, i)
-        else:
-            sourcename = u'docstring of %s' % self.fullname
 
         # add content from docstrings
         if not no_docstring:
             encoding = self.analyzer and self.analyzer.encoding
             docstrings = self.get_doc(encoding)
+            if not docstrings:
+                # append at least a dummy docstring, so that the event
+                # autodoc-process-docstring is fired and can add some
+                # content if desired
+                docstrings.append([])
             for i, line in enumerate(self.process_doc(docstrings)):
                 self.add_line(line, sourcename, i)
 
@@ -459,45 +576,66 @@ class Documenter(object):
                 self.add_line(line, src[0], src[1])
 
     def get_object_members(self, want_all):
-        """
-        Return `(members_check_module, members)` where `members` is a
+        """Return `(members_check_module, members)` where `members` is a
         list of `(membername, member)` pairs of the members of *self.object*.
 
         If *want_all* is True, return all members.  Else, only return those
         members given by *self.options.members* (which may also be none).
         """
+        analyzed_member_names = set()
+        if self.analyzer:
+            attr_docs = self.analyzer.find_attr_docs()
+            namespace = '.'.join(self.objpath)
+            for item in iteritems(attr_docs):
+                if item[0][0] == namespace:
+                    analyzed_member_names.add(item[0][1])
         if not want_all:
             if not self.options.members:
                 return False, []
             # specific members given
-            ret = []
+            members = []
             for mname in self.options.members:
                 try:
-                    ret.append((mname, self.get_attr(self.object, mname)))
+                    members.append((mname, self.get_attr(self.object, mname)))
                 except AttributeError:
-                    self.directive.warn('missing attribute %s in object %s'
-                                        % (mname, self.fullname))
-            return False, ret
+                    if mname not in analyzed_member_names:
+                        self.directive.warn('missing attribute %s in object %s'
+                                            % (mname, self.fullname))
         elif self.options.inherited_members:
             # safe_getmembers() uses dir() which pulls in members from all
             # base classes
-            return False, safe_getmembers(self.object)
+            members = safe_getmembers(self.object, attr_getter=self.get_attr)
         else:
             # __dict__ contains only the members directly defined in
             # the class (but get them via getattr anyway, to e.g. get
             # unbound method objects instead of function objects);
             # using keys() because apparently there are objects for which
             # __dict__ changes while getting attributes
-            return False, sorted([
-                (mname, self.get_attr(self.object, mname, None))
-                for mname in self.get_attr(self.object, '__dict__').keys()])
+            try:
+                obj_dict = self.get_attr(self.object, '__dict__')
+            except AttributeError:
+                members = []
+            else:
+                members = [(mname, self.get_attr(self.object, mname, None))
+                           for mname in obj_dict.keys()]
+        membernames = set(m[0] for m in members)
+        # add instance attributes from the analyzer
+        for aname in analyzed_member_names:
+            if aname not in membernames and \
+               (want_all or aname in self.options.members):
+                members.append((aname, INSTANCEATTR))
+        return False, sorted(members)
 
     def filter_members(self, members, want_all):
-        """
-        Filter the given member list: members are skipped if
+        """Filter the given member list.
 
-        - they are private (except if given explicitly)
-        - they are undocumented (except if undoc-members is given)
+        Members are skipped if
+
+        - they are private (except if given explicitly or the private-members
+          option is set)
+        - they are special methods (except if given explicitly or the
+          special-members option is set)
+        - they are undocumented (except if the undoc-members option is set)
 
         The user can override the skipping decision by connecting to the
         ``autodoc-skip-member`` event.
@@ -522,18 +660,38 @@ class Documenter(object):
             # if isattr is True, the member is documented as an attribute
             isattr = False
 
-            if want_all and membername.startswith('_'):
+            doc = sage_getdoc_original(member)
+            # if the member __doc__ is the same as self's __doc__, it's just
+            # inherited and therefore not the member's doc
+            cls = self.get_attr(member, '__class__', None)
+            if cls:
+                cls_doc = self.get_attr(cls, '__doc__', None)
+                if cls_doc == doc:
+                    doc = None
+            has_doc = bool(doc)
+
+            keep = False
+            if want_all and membername.startswith('__') and \
+                    membername.endswith('__') and len(membername) > 4:
+                # special __methods__
+                if self.options.special_members is ALL and \
+                        membername != '__doc__':
+                    keep = has_doc or self.options.undoc_members
+                elif self.options.special_members and \
+                    self.options.special_members is not ALL and \
+                        membername in self.options.special_members:
+                    keep = has_doc or self.options.undoc_members
+            elif want_all and membername.startswith('_'):
                 # ignore members whose name starts with _ by default
-                skip = True
+                keep = self.options.private_members and \
+                    (has_doc or self.options.undoc_members)
             elif (namespace, membername) in attr_docs:
                 # keep documented attributes
-                skip = False
+                keep = True
                 isattr = True
             else:
-                # ignore undocumented members if :undoc-members:
-                # is not given
-                doc = sage_getdoc_original(member)
-                skip = not self.options.undoc_members and not doc
+                # ignore undocumented members if :undoc-members: is not given
+                keep = has_doc or self.options.undoc_members
 
             # give the user a chance to decide whether this member
             # should be skipped
@@ -541,28 +699,28 @@ class Documenter(object):
                 # let extensions preprocess docstrings
                 skip_user = self.env.app.emit_firstresult(
                     'autodoc-skip-member', self.objtype, membername, member,
-                    skip, self.options)
+                    not keep, self.options)
                 if skip_user is not None:
-                    skip = skip_user
-            if skip:
-                continue
+                    keep = not skip_user
 
-            ret.append((membername, member, isattr))
+            if keep:
+                ret.append((membername, member, isattr))
 
         return ret
 
     def document_members(self, all_members=False):
-        """
-        Generate reST for member documentation.  If *all_members* is True,
-        do all members, else those given by *self.options.members*.
+        """Generate reST for member documentation.
+
+        If *all_members* is True, do all members, else those given by
+        *self.options.members*.
         """
         # set current namespace for finding members
-        self.env.autodoc_current_module = self.modname
+        self.env.temp_data['autodoc:module'] = self.modname
         if self.objpath:
-            self.env.autodoc_current_class = self.objpath[0]
+            self.env.temp_data['autodoc:class'] = self.objpath[0]
 
         want_all = all_members or self.options.inherited_members or \
-                   self.options.members is ALL
+            self.options.members is ALL
         # find out which members are documentable
         members_check_module, members = self.get_object_members(want_all)
 
@@ -574,7 +732,7 @@ class Documenter(object):
         # document non-skipped members
         memberdocumenters = []
         for (mname, member, isattr) in self.filter_members(members, want_all):
-            classes = [cls for cls in AutoDirective._registry.itervalues()
+            classes = [cls for cls in itervalues(AutoDirective._registry)
                        if cls.can_document_member(member, mname, isattr, self)]
             if not classes:
                 # don't know how to document this member
@@ -584,29 +742,37 @@ class Documenter(object):
             # give explicitly separated module name, so that members
             # of inner classes can be documented
             full_mname = self.modname + '::' + \
-                              '.'.join(self.objpath + [mname])
-            memberdocumenters.append(
-                classes[-1](self.directive, full_mname, self.indent))
-
-        if (self.options.member_order or self.env.config.autodoc_member_order) \
-               == 'groupwise':
+                '.'.join(self.objpath + [mname])
+            documenter = classes[-1](self.directive, full_mname, self.indent)
+            memberdocumenters.append((documenter, isattr))
+        member_order = self.options.member_order or \
+            self.env.config.autodoc_member_order
+        if member_order == 'groupwise':
             # sort by group; relies on stable sort to keep items in the
             # same group sorted alphabetically
-            memberdocumenters.sort(key=lambda d: d.member_order)
+            memberdocumenters.sort(key=lambda e: e[0].member_order)
+        elif member_order == 'bysource' and self.analyzer:
+            # sort by source order, by virtue of the module analyzer
+            tagorder = self.analyzer.tagorder
+
+            def keyfunc(entry):
+                fullname = entry[0].name.split('::')[1]
+                return tagorder.get(fullname, len(tagorder))
+            memberdocumenters.sort(key=keyfunc)
 
-        for documenter in memberdocumenters:
-            documenter.generate(all_members=True,
-                                real_modname=self.real_modname,
-                                check_module=members_check_module)
+        for documenter, isattr in memberdocumenters:
+            documenter.generate(
+                all_members=True, real_modname=self.real_modname,
+                check_module=members_check_module and not isattr)
 
         # reset current objects
-        self.env.autodoc_current_module = None
-        self.env.autodoc_current_class = None
+        self.env.temp_data['autodoc:module'] = None
+        self.env.temp_data['autodoc:class'] = None
 
     def generate(self, more_content=None, real_modname=None,
                  check_module=False, all_members=False):
-        """
-        Generate reST for the object given by *self.name*, and possibly members.
+        """Generate reST for the object given by *self.name*, and possibly for
+        its members.
 
         If *more_content* is given, include that content. If *real_modname* is
         given, use that module name to find attribute docs. If *check_module* is
@@ -640,6 +806,7 @@ class Documenter(object):
             # be cached anyway)
             self.analyzer.find_attr_docs()
         except PycodeError as err:
+            self.env.app.debug('[autodoc] module analyzer failed: %s', err)
             # no source file -- e.g. for builtin and C modules
             self.analyzer = None
             # at least add the module.__file__ as a dependency
@@ -653,22 +820,19 @@ class Documenter(object):
             if not self.check_module():
                 return
 
+        sourcename = self.get_sourcename()
+
         # make sure that the result starts with an empty line.  This is
         # necessary for some situations where another directive preprocesses
         # reST and no starting newline is present
-        self.add_line(u'', '')
+        self.add_line(u'', sourcename)
 
         # format the object's signature, if any
-        try:
-            sig = self.format_signature()
-        except Exception as err:
-            self.directive.warn('error while formatting signature for '
-                                '%s: %s' % (self.fullname, err))
-            sig = ''
+        sig = self.format_signature()
 
         # generate the directive header and options, if applicable
         self.add_directive_header(sig)
-        self.add_line(u'', '<autodoc>')
+        self.add_line(u'', sourcename)
 
         # e.g. the module directive doesn't have content
         self.indent += self.content_indent
@@ -686,6 +850,7 @@ class ModuleDocumenter(Documenter):
     """
     objtype = 'module'
     content_indent = u''
+    titles_allowed = True
 
     option_spec = {
         'members': members_option, 'undoc-members': bool_option,
@@ -693,6 +858,8 @@ class ModuleDocumenter(Documenter):
         'show-inheritance': bool_option, 'synopsis': identity,
         'platform': identity, 'deprecated': bool_option,
         'member-order': identity, 'exclude-members': members_set_option,
+        'private-members': bool_option, 'special-members': members_option,
+        'imported-members': bool_option,
     }
 
     @classmethod
@@ -715,15 +882,17 @@ class ModuleDocumenter(Documenter):
     def add_directive_header(self, sig):
         Documenter.add_directive_header(self, sig)
 
+        sourcename = self.get_sourcename()
+
         # add some module-specific options
         if self.options.synopsis:
             self.add_line(
-                u'   :synopsis: ' + self.options.synopsis, '<autodoc>')
+                u'   :synopsis: ' + self.options.synopsis, sourcename)
         if self.options.platform:
             self.add_line(
-                u'   :platform: ' + self.options.platform, '<autodoc>')
+                u'   :platform: ' + self.options.platform, sourcename)
         if self.options.deprecated:
-            self.add_line(u'   :deprecated:', '<autodoc>')
+            self.add_line(u'   :deprecated:', sourcename)
 
     def get_object_members(self, want_all):
         if want_all:
@@ -733,6 +902,15 @@ class ModuleDocumenter(Documenter):
                 return True, safe_getmembers(self.object)
             else:
                 memberlist = self.object.__all__
+                # Sometimes __all__ is broken...
+                if not isinstance(memberlist, (list, tuple)) or not \
+                   all(isinstance(entry, string_types) for entry in memberlist):
+                    self.directive.warn(
+                        '__all__ should be a list of strings, not %r '
+                        '(in module %s) -- ignoring __all__' %
+                        (memberlist, self.fullname))
+                    # fall back to all members
+                    return True, safe_getmembers(self.object)
         else:
             memberlist = self.options.members or []
         ret = []
@@ -743,7 +921,7 @@ class ModuleDocumenter(Documenter):
                 self.directive.warn(
                     'missing attribute mentioned in :members: or __all__: '
                     'module %s, attribute %s' % (
-                    safe_getattr(self.object, '__name__', '???'), mname))
+                        safe_getattr(self.object, '__name__', '???'), mname))
         return False, ret
 
 
@@ -759,11 +937,10 @@ class ModuleLevelDocumenter(Documenter):
             else:
                 # if documenting a toplevel object without explicit module,
                 # it can be contained in another auto directive ...
-                if hasattr(self.env, 'autodoc_current_module'):
-                    modname = self.env.autodoc_current_module
+                modname = self.env.temp_data.get('autodoc:module')
                 # ... or in the scope of a module directive
                 if not modname:
-                    modname = self.env.currmodule
+                    modname = self.env.ref_context.get('py:module')
                 # ... else, it stays None, which means invalid
         return modname, parents + [base]
 
@@ -782,26 +959,93 @@ class ClassLevelDocumenter(Documenter):
                 # if documenting a class-level object without path,
                 # there must be a current class, either from a parent
                 # auto directive ...
-                if hasattr(self.env, 'autodoc_current_class'):
-                    mod_cls = self.env.autodoc_current_class
+                mod_cls = self.env.temp_data.get('autodoc:class')
                 # ... or from a class directive
                 if mod_cls is None:
-                    mod_cls = self.env.currclass
+                    mod_cls = self.env.ref_context.get('py:class')
                 # ... if still None, there's no way to know
                 if mod_cls is None:
                     return None, []
             modname, cls = rpartition(mod_cls, '.')
             parents = [cls]
             # if the module name is still missing, get it like above
-            if not modname and hasattr(self.env, 'autodoc_current_module'):
-                modname = self.env.autodoc_current_module
             if not modname:
-                modname = self.env.currmodule
+                modname = self.env.temp_data.get('autodoc:module')
+            if not modname:
+                modname = self.env.ref_context.get('py:module')
             # ... else, it stays None, which means invalid
         return modname, parents + [base]
 
 
-class FunctionDocumenter(ModuleLevelDocumenter):
+class DocstringSignatureMixin(object):
+    """
+    Mixin for FunctionDocumenter and MethodDocumenter to provide the
+    feature of reading the signature from the docstring.
+    """
+
+    def _find_signature(self, encoding=None):
+        docstrings = self.get_doc(encoding)
+        self._new_docstrings = docstrings[:]
+        result = None
+        for i, doclines in enumerate(docstrings):
+            # no lines in docstring, no match
+            if not doclines:
+                continue
+            # match first line of docstring against signature RE
+            match = py_ext_sig_re.match(doclines[0])
+            if not match:
+                continue
+            exmod, path, base, args, retann = match.groups()
+            # the base name must match ours
+            valid_names = [self.objpath[-1]]
+            if isinstance(self, ClassDocumenter):
+                valid_names.append('__init__')
+                if hasattr(self.object, '__mro__'):
+                    valid_names.extend(cls.__name__ for cls in self.object.__mro__)
+            if base not in valid_names:
+                continue
+            # re-prepare docstring to ignore more leading indentation
+            self._new_docstrings[i] = prepare_docstring('\n'.join(doclines[1:]))
+            result = args, retann
+            # don't look any further
+            break
+        return result
+
+    def get_doc(self, encoding=None, ignore=1):
+        lines = getattr(self, '_new_docstrings', None)
+        if lines is not None:
+            return lines
+        return Documenter.get_doc(self, encoding, ignore)
+
+    def format_signature(self):
+        if self.args is None and self.env.config.autodoc_docstring_signature:
+            # only act if a signature is not explicitly given already, and if
+            # the feature is enabled
+            result = self._find_signature()
+            if result is not None:
+                self.args, self.retann = result
+        return Documenter.format_signature(self)
+
+
+class DocstringStripSignatureMixin(DocstringSignatureMixin):
+    """
+    Mixin for AttributeDocumenter to provide the
+    feature of stripping any function signature from the docstring.
+    """
+    def format_signature(self):
+        if self.args is None and self.env.config.autodoc_docstring_signature:
+            # only act if a signature is not explicitly given already, and if
+            # the feature is enabled
+            result = self._find_signature()
+            if result is not None:
+                # Discarding _args is a only difference with
+                # DocstringSignatureMixin.format_signature.
+                # Documenter.format_signature use self.args value to format.
+                _args, self.retann = result
+        return Documenter.format_signature(self)
+
+
+class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):
     """
     Specialized Documenter subclass for functions.
     """
@@ -838,7 +1082,7 @@ class FunctionDocumenter(ModuleLevelDocumenter):
                     return argspec
                 else:
                     return None
-            argspec = sage_getargspec(obj) #inspect.getargspec(obj)
+            argspec = sage_getargspec(obj)  # getargspec(obj)
             if isclassinstance(obj) or inspect.isclass(obj):
                 # if a class should be documented as function, we try
                 # to use the constructor signature as function
@@ -847,13 +1091,13 @@ class FunctionDocumenter(ModuleLevelDocumenter):
                     del argspec[0][0]
             return argspec
         argspec = args_on_obj(self.object)
-        return inspect.formatargspec(*argspec) if argspec is not None else None
+        return formatargspec(*argspec) if argspec is not None else None
 
     def document_members(self, all_members=False):
         pass
 
 
-class ClassDocumenter(ModuleLevelDocumenter):
+class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):
     """
     Specialized Documenter subclass for classes.
     """
@@ -864,11 +1108,12 @@ class ClassDocumenter(ModuleLevelDocumenter):
         'noindex': bool_option, 'inherited-members': bool_option,
         'show-inheritance': bool_option, 'member-order': identity,
         'exclude-members': members_set_option,
+        'private-members': bool_option, 'special-members': members_option,
     }
 
     @classmethod
     def can_document_member(cls, member, membername, isattr, parent):
-        return isinstance(member, (type, ClassType))
+        return isinstance(member, class_types)
 
     def import_object(self):
         ret = ModuleLevelDocumenter.import_object(self)
@@ -925,23 +1170,29 @@ class ClassDocumenter(ModuleLevelDocumenter):
         return ret
 
     def format_args(self):
-        args = None
         # for classes, the relevant signature is the __init__ method's
         initmeth = self.get_attr(self.object, '__init__', None)
         # classes without __init__ method, default __init__ or
         # __init__ written in C?
-        if initmeth is None or initmeth is object.__init__ or not \
-               (inspect.ismethod(initmeth) or inspect.isfunction(initmeth)):
+        if initmeth is None or \
+                is_builtin_class_method(self.object, '__init__') or \
+                not(inspect.ismethod(initmeth) or inspect.isfunction(initmeth)):
+            return None
+        try:
+            argspec = sage_getargspec(initmeth) #getargspec(initmeth)
+        except TypeError:
+            # still not possible: happens e.g. for old-style classes
+            # with __init__ in C
             return None
-        argspec = sage_getargspec(initmeth) #inspect.getargspec(initmeth)
         if argspec[0] and argspec[0][0] in ('cls', 'self'):
             del argspec[0][0]
-        return inspect.formatargspec(*argspec)
+        return formatargspec(*argspec)
 
     def format_signature(self):
         if self.doc_as_attr:
             return ''
-        return ModuleLevelDocumenter.format_signature(self)
+
+        return DocstringSignatureMixin.format_signature(self)
 
     def add_directive_header(self, sig):
         if self.doc_as_attr:
@@ -950,22 +1201,27 @@ class ClassDocumenter(ModuleLevelDocumenter):
 
         # add inheritance info, if wanted
         if not self.doc_as_attr and self.options.show_inheritance:
-            self.add_line(u'', '<autodoc>')
-            if len(self.object.__bases__):
-                bases = [b.__module__ == '__builtin__' and
+            sourcename = self.get_sourcename()
+            self.add_line(u'', sourcename)
+            if hasattr(self.object, '__bases__') and len(self.object.__bases__):
+                bases = [b.__module__ in ('__builtin__', 'builtins') and
                          u':class:`%s`' % b.__name__ or
                          u':class:`%s.%s`' % (b.__module__, b.__name__)
                          for b in self.object.__bases__]
                 self.add_line(_(u'   Bases: %s') % ', '.join(bases),
-                              '<autodoc>')
+                              sourcename)
+
+    def get_doc(self, encoding=None, ignore=1):
+        lines = getattr(self, '_new_docstrings', None)
+        if lines is not None:
+            return lines
 
-    def get_doc(self, encoding=None):
         content = self.env.config.autoclass_content
 
         docstrings = []
-        docstring = sage_getdoc_original(self.object)
-        if docstring:
-            docstrings.append(docstring)
+        attrdocstring = sage_getdoc_original(self.object)
+        if attrdocstring:
+            docstrings.append(attrdocstring)
 
         # for classes, what the "docstring" is can be controlled via a
         # config value; the default is only the class docstring
@@ -973,16 +1229,21 @@ class ClassDocumenter(ModuleLevelDocumenter):
             initdocstring = sage_getdoc_original(
                 self.get_attr(self.object, '__init__', None))
             # for new-style classes, no __init__ means default __init__
-            if initdocstring == object.__init__.__doc__:
+            if (initdocstring is not None and
+                (initdocstring == object.__init__.__doc__ or  # for pypy
+                 initdocstring.strip() == object.__init__.__doc__)):  # for !pypy
                 initdocstring = None
             if initdocstring:
                 if content == 'init':
                     docstrings = [initdocstring]
                 else:
                     docstrings.append(initdocstring)
-
-        return [prepare_docstring(force_decode(docstring, encoding))
-                for docstring in docstrings]
+        doc = []
+        for docstring in docstrings:
+            if not isinstance(docstring, text_type):
+                docstring = force_decode(docstring, encoding)
+            doc.append(prepare_docstring(docstring))
+        return doc
 
     def add_content(self, more_content, no_docstring=False):
         if self.doc_as_attr:
@@ -1013,8 +1274,8 @@ class ExceptionDocumenter(ClassDocumenter):
 
     @classmethod
     def can_document_member(cls, member, membername, isattr, parent):
-        return isinstance(member, (type, ClassType)) and \
-               issubclass(member, base_exception)
+        return isinstance(member, class_types) and \
+            issubclass(member, BaseException)
 
 
 class DataDocumenter(ModuleLevelDocumenter):
@@ -1023,39 +1284,60 @@ class DataDocumenter(ModuleLevelDocumenter):
     """
     objtype = 'data'
     member_order = 40
+    priority = -10
+    option_spec = dict(ModuleLevelDocumenter.option_spec)
+    option_spec["annotation"] = annotation_option
 
     @classmethod
     def can_document_member(cls, member, membername, isattr, parent):
         return isinstance(parent, ModuleDocumenter) and isattr
 
+    def add_directive_header(self, sig):
+        ModuleLevelDocumenter.add_directive_header(self, sig)
+        sourcename = self.get_sourcename()
+        if not self.options.annotation:
+            try:
+                objrepr = object_description(self.object)
+            except ValueError:
+                pass
+            else:
+                self.add_line(u'   :annotation: = ' + objrepr, sourcename)
+        elif self.options.annotation is SUPPRESS:
+            pass
+        else:
+            self.add_line(u'   :annotation: %s' % self.options.annotation,
+                          sourcename)
+
     def document_members(self, all_members=False):
         pass
 
 
-class MethodDocumenter(ClassLevelDocumenter):
+class MethodDocumenter(DocstringSignatureMixin, ClassLevelDocumenter):
     """
     Specialized Documenter subclass for methods (normal, static and class).
     """
     objtype = 'method'
     member_order = 50
+    priority = 1  # must be more than FunctionDocumenter
 
     @classmethod
     def can_document_member(cls, member, membername, isattr, parent):
-        # other attributes are recognized via the module analyzer
         return inspect.isroutine(member) and \
-               not isinstance(parent, ModuleDocumenter)
+            not isinstance(parent, ModuleDocumenter)
 
     def import_object(self):
         ret = ClassLevelDocumenter.import_object(self)
-        if isinstance(self.object, classmethod) or \
-               (isinstance(self.object, MethodType) and
-                self.object.im_self is not None):
+        if not ret:
+            return ret
+
+        # to distinguish classmethod/staticmethod
+        obj = self.parent.__dict__.get(self.object_name)
+
+        if isinstance(obj, classmethod):
             self.directivetype = 'classmethod'
             # document class and static members before ordinary ones
             self.member_order = self.member_order - 1
-        elif isinstance(self.object, FunctionType) or \
-             (isinstance(self.object, BuiltinFunctionType) and
-              self.object.__self__ is not None):
+        elif isinstance(obj, staticmethod):
             self.directivetype = 'staticmethod'
             # document class and static members before ordinary ones
             self.member_order = self.member_order - 1
@@ -1096,12 +1378,20 @@ class MethodDocumenter(ClassLevelDocumenter):
         pass
 
 
-class AttributeDocumenter(ClassLevelDocumenter):
+class AttributeDocumenter(DocstringStripSignatureMixin, ClassLevelDocumenter):
     """
     Specialized Documenter subclass for attributes.
     """
     objtype = 'attribute'
     member_order = 60
+    option_spec = dict(ModuleLevelDocumenter.option_spec)
+    option_spec["annotation"] = annotation_option
+
+    # must be higher than the MethodDocumenter, else it will recognize
+    # some non-data descriptors as methods
+    priority = 10
+
+    method_types = (FunctionType, BuiltinFunctionType, MethodType)
 
     @classmethod
     def can_document_member(cls, member, membername, isattr, parent):
@@ -1109,13 +1399,80 @@ class AttributeDocumenter(ClassLevelDocumenter):
         # is true for public cython attributes of a class. But in this case, the doc string is None,
         # and so we would not include it into the documentation.
         return (isdescriptor(member) and not
-                isinstance(member, (FunctionType, BuiltinFunctionType))
+                isinstance(member, cls.method_types)
                 and (hasattr(member,'__doc__') and member.__doc__ is not None)) \
                or (not isinstance(parent, ModuleDocumenter) and isattr)
 
     def document_members(self, all_members=False):
         pass
 
+    def import_object(self):
+        ret = ClassLevelDocumenter.import_object(self)
+        if isdescriptor(self.object) and \
+                not isinstance(self.object, self.method_types):
+            self._datadescriptor = True
+        else:
+            # if it's not a data descriptor
+            self._datadescriptor = False
+        return ret
+
+    def get_real_modname(self):
+        return self.get_attr(self.parent or self.object, '__module__', None) \
+            or self.modname
+
+    def add_directive_header(self, sig):
+        ClassLevelDocumenter.add_directive_header(self, sig)
+        sourcename = self.get_sourcename()
+        if not self.options.annotation:
+            if not self._datadescriptor:
+                try:
+                    objrepr = object_description(self.object)
+                except ValueError:
+                    pass
+                else:
+                    self.add_line(u'   :annotation: = ' + objrepr, sourcename)
+        elif self.options.annotation is SUPPRESS:
+            pass
+        else:
+            self.add_line(u'   :annotation: %s' % self.options.annotation,
+                          sourcename)
+
+    def add_content(self, more_content, no_docstring=False):
+        if not self._datadescriptor:
+            # if it's not a data descriptor, its docstring is very probably the
+            # wrong thing to display
+            no_docstring = True
+        ClassLevelDocumenter.add_content(self, more_content, no_docstring)
+
+
+class InstanceAttributeDocumenter(AttributeDocumenter):
+    """
+    Specialized Documenter subclass for attributes that cannot be imported
+    because they are instance attributes (e.g. assigned in __init__).
+    """
+    objtype = 'instanceattribute'
+    directivetype = 'attribute'
+    member_order = 60
+
+    # must be higher than AttributeDocumenter
+    priority = 11
+
+    @classmethod
+    def can_document_member(cls, member, membername, isattr, parent):
+        """This documents only INSTANCEATTR members."""
+        return isattr and (member is INSTANCEATTR)
+
+    def import_object(self):
+        """Never import anything."""
+        # disguise as an attribute
+        self.objtype = 'attribute'
+        self._datadescriptor = False
+        return True
+
+    def add_content(self, more_content, no_docstring=False):
+        """Never try to get a docstring from the object."""
+        AttributeDocumenter.add_content(self, more_content, no_docstring=True)
+
 
 class AutoDirective(Directive):
     """
@@ -1138,6 +1495,12 @@ class AutoDirective(Directive):
     # a registry of type -> getattr function
     _special_attrgetters = {}
 
+    # flags that can be given in autodoc_default_flags
+    _default_flags = set([
+        'members', 'undoc-members', 'inherited-members', 'show-inheritance',
+        'private-members', 'special-members',
+    ])
+
     # standard docutils directive settings
     has_content = True
     required_arguments = 1
@@ -1157,22 +1520,46 @@ class AutoDirective(Directive):
         self.warnings = []
         self.result = ViewList()
 
+        try:
+            source, lineno = self.reporter.get_source_and_line(self.lineno)
+        except AttributeError:
+            source = lineno = None
+        self.env.app.debug('[autodoc] %s:%s: input:\n%s',
+                           source, lineno, self.block_text)
+
         # find out what documenter to call
         objtype = self.name[4:]
         doc_class = self._registry[objtype]
+        # add default flags
+        for flag in self._default_flags:
+            if flag not in doc_class.option_spec:
+                continue
+            negated = self.options.pop('no-' + flag, 'not given') is None
+            if flag in self.env.config.autodoc_default_flags and \
+               not negated:
+                self.options[flag] = None
         # process the options with the selected documenter's option_spec
-        self.genopt = Options(assemble_option_dict(
-            self.options.items(), doc_class.option_spec))
+        try:
+            self.genopt = Options(assemble_option_dict(
+                self.options.items(), doc_class.option_spec))
+        except (KeyError, ValueError, TypeError) as err:
+            # an option is either unknown or has a wrong type
+            msg = self.reporter.error('An option to %s is either unknown or '
+                                      'has an invalid value: %s' % (self.name, err),
+                                      line=self.lineno)
+            return [msg]
         # generate the output
         documenter = doc_class(self, self.arguments[0])
         documenter.generate(more_content=self.content)
         if not self.result:
             return self.warnings
 
+        self.env.app.debug2('[autodoc] output:\n%s', '\n'.join(self.result))
+
         # record all filenames as dependencies -- this will at least
         # partially make automatic invalidation possible
         for fn in self.filename_set:
-            self.env.note_dependency(fn)
+            self.state.document.settings.record_dependencies.add(fn)
 
         # use a custom reporter that correctly assigns lines to source
         # filename/description and lineno
@@ -1180,7 +1567,7 @@ class AutoDirective(Directive):
         self.state.memo.reporter = AutodocReporter(self.result,
                                                    self.state.memo.reporter)
 
-        if self.name == 'automodule':
+        if documenter.titles_allowed:
             node = nodes.section()
             # necessary so that the child nodes get the right source/line set
             node.document = self.state.document
@@ -1199,7 +1586,7 @@ def add_documenter(cls):
         raise ExtensionError('autodoc documenter %r must be a subclass '
                              'of Documenter' % cls)
     # actually, it should be possible to override Documenters
-    #if cls.objtype in AutoDirective._registry:
+    # if cls.objtype in AutoDirective._registry:
     #    raise ExtensionError('autodoc documenter for %r is already '
     #                         'registered' % cls.objtype)
     AutoDirective._registry[cls.objtype] = cls
@@ -1225,10 +1612,14 @@ def setup(app):
     app.add_autodocumenter(FunctionDocumenter)
     app.add_autodocumenter(MethodDocumenter)
     app.add_autodocumenter(AttributeDocumenter)
+    app.add_autodocumenter(InstanceAttributeDocumenter)
 
     app.add_config_value('autoclass_content', 'class', True)
     app.add_config_value('autodoc_member_order', 'alphabetic', True)
     app.add_config_value('autodoc_builtin_argspec', None, True)
+    app.add_config_value('autodoc_default_flags', [], True)
+    app.add_config_value('autodoc_docstring_signature', True, True)
+    app.add_config_value('autodoc_mock_imports', [], True)
     app.add_event('autodoc-process-docstring')
     app.add_event('autodoc-process-signature')
     app.add_event('autodoc-skip-member')
diff --git a/src/doc/common/themes/sage/theme.conf b/src/doc/common/themes/sage/theme.conf
index 4fbb8e4..3d84627 100644
--- a/src/doc/common/themes/sage/theme.conf
+++ b/src/doc/common/themes/sage/theme.conf
@@ -1,5 +1,5 @@
 [theme]
-inherit = default
+inherit = classic
 stylesheet = sage.css
 pygments_style = sphinx
 
diff --git a/src/doc/common/themes/sageref/theme.conf b/src/doc/common/themes/sageref/theme.conf
index 4fbb8e4..3d84627 100644
--- a/src/doc/common/themes/sageref/theme.conf
+++ b/src/doc/common/themes/sageref/theme.conf
@@ -1,5 +1,5 @@
 [theme]
-inherit = default
+inherit = classic
 stylesheet = sage.css
 pygments_style = sphinx
 
