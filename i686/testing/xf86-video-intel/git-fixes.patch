From 127aae5a72a69df325fed0b63d345e81583d5ca1 Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Mon, 16 Feb 2015 21:37:35 +0000
Subject: tools/intel-virtual-output: Check for DRI3 more carefully

Using xcb, we cannot simply call xcb_dri3_query_version() without it
terminating the connection if DRI3 is not enabled on the target display.
Oops.

Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=89172
Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/tools/virtual.c b/tools/virtual.c
index 8e2b4a2..3bcd057 100644
--- a/tools/virtual.c
+++ b/tools/virtual.c
@@ -218,6 +218,13 @@ static inline XRRScreenResources *_XRRGetScreenResourcesCurrent(Display *dpy, Wi
 static int _x_error_occurred;
 
 static int
+_io_error_handler(Display *display)
+{
+	fprintf(stderr, "XIO error on display %s\n", DisplayString(display));
+	abort();
+}
+
+static int
 _check_error_handler(Display     *display,
 		     XErrorEvent *event)
 {
@@ -320,6 +327,7 @@ can_use_shm(Display *dpy,
 #include <X11/Xlib-xcb.h>
 #include <X11/xshmfence.h>
 #include <xcb/xcb.h>
+#include <xcb/xcbext.h>
 #include <xcb/dri3.h>
 #include <xcb/sync.h>
 static Pixmap dri3_create_pixmap(Display *dpy,
@@ -357,6 +365,7 @@ static int dri3_query_version(Display *dpy, int *major, int *minor)
 {
 	xcb_connection_t *c = XGetXCBConnection(dpy);
 	xcb_dri3_query_version_reply_t *reply;
+	xcb_generic_error_t *error;
 
 	*major = *minor = -1;
 
@@ -364,7 +373,8 @@ static int dri3_query_version(Display *dpy, int *major, int *minor)
 					     xcb_dri3_query_version(c,
 								    XCB_DRI3_MAJOR_VERSION,
 								    XCB_DRI3_MINOR_VERSION),
-					     NULL);
+					     &error);
+	free(error);
 	if (reply == NULL)
 		return -1;
 
@@ -377,8 +387,14 @@ static int dri3_query_version(Display *dpy, int *major, int *minor)
 
 static int dri3_exists(Display *dpy)
 {
+	xcb_extension_t dri3 = { "DRI3", 0 };
+	const xcb_query_extension_reply_t *ext;
 	int major, minor;
 
+	ext = xcb_get_extension_data(XGetXCBConnection(dpy), &dri3);
+	if (ext == NULL || !ext->present)
+		return 0;
+
 	if (dri3_query_version(dpy, &major, &minor) < 0)
 		return 0;
 
@@ -3228,6 +3244,7 @@ int main(int argc, char **argv)
 		return -ret;
 
 	XSetErrorHandler(_check_error_handler);
+	XSetIOErrorHandler(_io_error_handler);
 
 	ret = add_fd(&ctx, display_open(&ctx, src_name));
 	if (ret) {
-- 
cgit v0.10.2
From db82617464e55432522e6199a88408ff0187f6ff Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Wed, 4 Mar 2015 17:12:30 +0000
Subject: sna: Decouple RandR pointers early in CloseScreen

RR resources are freed before CloseScreen (as they are a ServerClient
resource), but on entering our CloseScreen callbacks we are left with a
set of stale pointers. Decouple those before proceeding so that we are
not tempted to dereference them.

Bugzilla: https://bugs.archlinux.org/task/43906
Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/src/sna/sna_display.c b/src/sna/sna_display.c
index 88db508..fd6c46c 100644
--- a/src/sna/sna_display.c
+++ b/src/sna/sna_display.c
@@ -6292,9 +6292,26 @@ sna_mode_enable(struct sna *sna)
 	sna->mode.dirty = false;
 }
 
+static void sna_randr_close(struct sna *sna)
+{
+	xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR(sna->scrn);
+	int n;
+
+	/* The RR structs are freed early during CloseScreen as they
+	 * are tracked as Resources. However, we may be tempted to
+	 * access them during shutdown so decouple them now.
+	 */
+	  for (n = 0; n < config->num_output; n++)
+		  config->output[n]->randr_output = NULL;
+
+	  for (n = 0; n < config->num_crtc; n++)
+		  config->crtc[n]->randr_crtc = NULL;
+}
+
 void
 sna_mode_close(struct sna *sna)
 {
+	sna_randr_close(sna);
 	sna_mode_wakeup(sna);
 
 	if (sna->flags & SNA_IS_HOSTED)
-- 
cgit v0.10.2
From 9c109f3dc56621215e580e74a6161f00035bdac3 Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Sun, 12 Apr 2015 21:15:54 +0100
Subject: [PATCH] sna: Mark the GPU as available before doing the mode restore
 on VT enter

Sometimes we want to render with the GPU when doing a mode switch, e.g.
if we need to initialise an output surface. To do so, we need to prepare
the acceleration layer first.

Lots of thanks to Vasily for tracking this one down.

Reported-by: Vasily Khoruzhick <anarsoul@gmail.com>
Bugzilla: https://bugs.archlinux.org/task/43534
Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
---
 src/sna/sna_driver.c | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/src/sna/sna_driver.c b/src/sna/sna_driver.c
index 31500e7..488ca9b 100644
--- a/src/sna/sna_driver.c
+++ b/src/sna/sna_driver.c
@@ -1213,6 +1213,8 @@ static Bool sna_enter_vt(VT_FUNC_ARGS_DECL)
 	if (intel_get_master(sna->dev))
 		return FALSE;
 
+	sna_accel_enter(sna);
+
 	if (sna->flags & SNA_REPROBE) {
 		DBG(("%s: reporting deferred hotplug event\n", __FUNCTION__));
 		sna_mode_discover(sna);
@@ -1221,11 +1223,11 @@ static Bool sna_enter_vt(VT_FUNC_ARGS_DECL)
 	sna_mode_check(sna);
 
 	if (!sna_set_desired_mode(sna)) {
+		sna_accel_leave(sna);
 		intel_put_master(sna->dev);
 		return FALSE;
 	}
 
-	sna_accel_enter(sna);
 	return TRUE;
 }
 
-- 
2.3.5
From 12af8a575d1518d40416f83195049157c3a062a5 Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Tue, 24 Feb 2015 15:25:40 +0000
Subject: sna: udev integration depends on fstat and sys/stat.h

src/sna/sna_driver.c: In function 'sna_handle_uevents':
src/sna/sna_driver.c:759:2: error: implicit declaration of function 'fstat' [-Werror=implicit-function-declaration]

Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/src/sna/sna_driver.c b/src/sna/sna_driver.c
index 8c0d0b5..bc20ef0 100644
--- a/src/sna/sna_driver.c
+++ b/src/sna/sna_driver.c
@@ -740,6 +740,8 @@ sna_wakeup_handler(WAKEUPHANDLER_ARGS_DECL)
 }
 
 #if HAVE_UDEV
+#include <sys/stat.h>
+
 static void
 sna_handle_uevents(int fd, void *closure)
 {
-- 
cgit v0.10.2
From 369ceec0e4910ba2c37736a59c55c0d6c26433bf Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Tue, 24 Feb 2015 15:25:40 +0000
Subject: uxa: udev integration depends on fstat and sys/stat.h

src/uxa/intel_driver.c: In function 'I830HandleUEvents':
src/uxa/intel_driver.c:738:14: error: storage size of 's' isn't known
src/uxa/intel_driver.c:746:2: error: implicit declaration of function 'fstat' [-Werror=implicit-function-declaration]

Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/src/uxa/intel_driver.c b/src/uxa/intel_driver.c
index c554124..6e64b8c 100644
--- a/src/uxa/intel_driver.c
+++ b/src/uxa/intel_driver.c
@@ -728,6 +728,8 @@ intel_flush_callback(CallbackListPtr *list,
 }
 
 #if HAVE_UDEV
+#include <sys/stat.h>
+
 static void
 I830HandleUEvents(int fd, void *closure)
 {
-- 
cgit v0.10.2
From c43617b739e358064396912c7a7a8028ca91d201 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Ville=20Syrj=C3=A4l=C3=A4?= <ville.syrjala@linux.intel.com>
Date: Thu, 16 Apr 2015 20:40:39 +0300
Subject: gen8: Fix the YUV->RGB shader
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Use the correct register (Yn_01) with first half of the
Y samples instead of using the register (Yn_23) with the
second half twice when computing the green channel.

Also use the Yn_01 register name instead of Yn for the red
channel as well, just for a bit of extra consistency.

Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=89807
Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
Tested-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/src/render_program/exa_wm_yuv_rgb.g8a b/src/render_program/exa_wm_yuv_rgb.g8a
index 7def093..34973ba 100644
--- a/src/render_program/exa_wm_yuv_rgb.g8a
+++ b/src/render_program/exa_wm_yuv_rgb.g8a
@@ -76,7 +76,7 @@ add (16)    Cbn<1>F		Cb<8,8,1>F	-0.501961F  { compr align1 };
     /* 
      * R = Y + Cr * 1.596
      */
-mov (8)    acc0<1>F		Yn<8,8,1>F		    { compr align1 };
+mov (8)    acc0<1>F		Yn_01<8,8,1>F		    { compr align1 };
 mac.sat(8) src_sample_r_01<1>F	Crn_01<8,8,1>F	1.596F	    { compr align1 };
      
 mov (8)    acc0<1>F		Yn_23<8,8,1>F		    { compr align1 };
@@ -84,7 +84,7 @@ mac.sat(8) src_sample_r_23<1>F	Crn_23<8,8,1>F	1.596F	    { compr align1 };
     /*
      * G = Crn * -0.813 + Cbn * -0.392 + Y
      */
-mov (8)    acc0<1>F		Yn_23<8,8,1>F		    { compr align1 };
+mov (8)    acc0<1>F		Yn_01<8,8,1>F		    { compr align1 };
 mac (8)    acc0<1>F		Crn_01<8,8,1>F    	-0.813F	    { compr align1 };
 mac.sat(8) src_sample_g_01<1>F	Cbn_01<8,8,1>F    	-0.392F	    { compr align1 };
 
diff --git a/src/render_program/exa_wm_yuv_rgb.g8b b/src/render_program/exa_wm_yuv_rgb.g8b
index 4494953..2cd6fc4 100644
--- a/src/render_program/exa_wm_yuv_rgb.g8b
+++ b/src/render_program/exa_wm_yuv_rgb.g8b
@@ -6,7 +6,7 @@
    { 0x80600048, 0x21c03ae8, 0x3e8d02c0, 0x3fcc49ba },
    { 0x00600001, 0x24003ae0, 0x008d0320, 0x00000000 },
    { 0x80600048, 0x21e03ae8, 0x3e8d02e0, 0x3fcc49ba },
-   { 0x00600001, 0x24003ae0, 0x008d0320, 0x00000000 },
+   { 0x00600001, 0x24003ae0, 0x008d0300, 0x00000000 },
    { 0x00600048, 0x24003ae0, 0x3e8d02c0, 0xbf5020c5 },
    { 0x80600048, 0x22003ae8, 0x3e8d0340, 0xbec8b439 },
    { 0x00600001, 0x24003ae0, 0x008d0320, 0x00000000 },
-- 
cgit v0.10.2

